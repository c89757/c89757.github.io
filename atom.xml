<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://c89757.github.io/atom.xml" rel="self"/>
  
  <link href="https://c89757.github.io/"/>
  <updated>2024-08-07T14:14:03.587Z</updated>
  <id>https://c89757.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次mysql死锁问题</title>
    <link href="https://c89757.github.io/2024/08/07/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <id>https://c89757.github.io/2024/08/07/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</id>
    <published>2024-08-07T13:41:21.000Z</published>
    <updated>2024-08-07T14:14:03.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>线上生产报障，查看程序日志，发现某条更新sql报错，报错信息<code>dead lock</code></p><h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p>在mysql客户端执行命令：<code>show engine innodb status</code>，可以查看到死锁信息（默认只会记录最后一次发生死锁的信息）</p><blockquote><p>前文有一篇类似的文章，只是场景不一样，根因是一样的。这里不再赘述</p></blockquote><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><ul><li>事务隔离级别</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@global</span>.tx_isolation</span><br></pre></td></tr></table></figure><blockquote><p>REPEATABLE-READ</p></blockquote><ul><li>新建测试表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test_deadlock`  (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `account_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `message_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  INDEX `idx_tenant_id`(`tenant_id`, `account_id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  INDEX `idx_message_id`(`message_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br></pre></td></tr></table></figure><ul><li>插入测试数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tmp`.`test_deadlock` (`id`, `tenant_id`, `account_id`, `message_id`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tmp`.`test_deadlock` (`id`, `tenant_id`, `account_id`, `message_id`) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tmp`.`test_deadlock` (`id`, `tenant_id`, `account_id`, `message_id`) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tmp`.`test_deadlock` (`id`, `tenant_id`, `account_id`, `message_id`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tmp`.`test_deadlock` (`id`, `tenant_id`, `account_id`, `message_id`) <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tmp`.`test_deadlock` (`id`, `tenant_id`, `account_id`, `message_id`) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><ul><li>复现</li></ul><table><thead><tr><th>时刻</th><th>事务1</th><th>事务2</th></tr></thead><tbody><tr><td>T1</td><td>begin;</td><td>begin;</td></tr><tr><td>T2</td><td>SELECT * FROM test_deadlock force index(idx_tenant_id) where tenant_id = ‘123’ and account_id in (‘X’) for update</td><td></td></tr><tr><td>T3</td><td></td><td>SELECT * FROM test_deadlock force index(idx_message_id) where message_id = 200 and account_id in (‘A’,’B’,’C’,’D’) for update</td></tr><tr><td>T4</td><td></td><td>阻塞</td></tr><tr><td>T5</td><td>SELECT * FROM test_deadlock force index(idx_tenant_id) where tenant_id = ‘123’ and account_id in (‘Z’) for update</td><td></td></tr></tbody></table><br><p>根本原因就是并发情况下，加锁顺序不一致导致的</p><br><img src="/2024/08/07/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/image-20240807221137413.png" class><br><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul><li>诱导<code>mysql</code>执行器走同一个索引</li><li>从业务上面，避免这种场景</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;线上生产报障，查看程序日志，发现某条更新sql报错，报错信息&lt;code&gt;dead lock&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;排查&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="mysql" scheme="https://c89757.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="https://c89757.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>matcher.find()与matcher.match()</title>
    <link href="https://c89757.github.io/2024/07/10/matcher-find-%E4%B8%8Ematcher-match/"/>
    <id>https://c89757.github.io/2024/07/10/matcher-find-%E4%B8%8Ematcher-match/</id>
    <published>2024-07-10T14:55:02.000Z</published>
    <updated>2024-07-10T14:55:02.467Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>科学上网-自建梯子</title>
    <link href="https://c89757.github.io/2024/05/11/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90/"/>
    <id>https://c89757.github.io/2024/05/11/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90/</id>
    <published>2024-05-11T12:12:58.000Z</published>
    <updated>2024-05-11T14:20:38.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="购买VPS"><a href="#购买VPS" class="headerlink" title="购买VPS"></a>购买VPS</h1><ul><li><p><a href="https://www.vultr.com/">vultr</a>：截至2024-05-10，基本已死。服务器ip大多都ping不通</p></li><li><p><a href="https://manage.hostease.com/store/go-vps">hostease</a>：美国主机商，在香港有机房，香港服务器不需要备案，且支持支付宝付款</p></li></ul><br><blockquote><p>以下操作基于centos7，建议镜像选用centos</p></blockquote><h1 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h1><blockquote><p>用xshell或其他客户端，远程连接上服务器</p></blockquote><h2 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h2><p>依次执行以下命令</p><br><blockquote><p>如果没有wget，先安装：yum install -y wget</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br><span class="line"></span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line"></span><br><span class="line">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure><br><p>根据提示，输入密码、端口、加密方式，等待安装即可。</p><br><p>上述安装完成之后，一般速度较慢，所以我们需要配置加速（类似于一种算法，能加速网络传输）</p><p>安装Google BBR：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget — no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span><br><span class="line"></span><br><span class="line">chmod +x bbr.sh</span><br><span class="line"></span><br><span class="line">./bbr.sh</span><br></pre></td></tr></table></figure><br><p>显示 “Press any key to start…” 按回车确认。</p><p>提示重启VPS，输入Y确认，等待重启即可</p><br><p><strong>补充</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/shadowsocks start      # 启动</span><br><span class="line">/etc/init.d/shadowsocks stop       # 停止</span><br><span class="line">/etc/init.d/shadowsocks restart    # 重启</span><br><span class="line">/etc/init.d/shadowsocks status     # 状态</span><br></pre></td></tr></table></figure><p><a href="https://jackmezone.medium.com/vultr%E6%90%AD%E5%BB%BAss%E5%8F%8A%E9%94%90%E9%80%9F%E4%BC%98%E5%8C%96%E5%8A%A0%E9%80%9F%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B-69763d7e2cdc">原文链接</a></p><h1 id="安装客户端"><a href="#安装客户端" class="headerlink" title="安装客户端"></a>安装客户端</h1><h2 id="shadowsocks-1"><a href="#shadowsocks-1" class="headerlink" title="shadowsocks"></a>shadowsocks</h2><p>官网下载客户端：</p><p><a href="https://github.com/shadowsocks/shadowsocks-windows/releases">https://github.com/shadowsocks/shadowsocks-windows/releases</a></p><p>下载完成安装之后，打开客户端，配置ip、密码、加速方式即可</p><br><img src="/2024/05/11/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90/image-20240511214852432.png" class><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="godaddy"><a href="#godaddy" class="headerlink" title="godaddy"></a>godaddy</h2><p>美国域名服务器，不需要备案</p><p><a href="https://www.godaddy.com/en-sg">官网链接</a></p><blockquote><p>官网被墙了，需要梯子才可访问。而且其官网本身会检测VPN，一般市场上的机场用的人多，都会被检测出来，通过自建的VPN可以访问</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;购买VPS&quot;&gt;&lt;a href=&quot;#购买VPS&quot; class=&quot;headerlink&quot; title=&quot;购买VPS&quot;&gt;&lt;/a&gt;购买VPS&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.vultr.com/&quot;&gt;vultr&lt;/a&gt;：截至2024</summary>
      
    
    
    
    <category term="网络" scheme="https://c89757.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="other" scheme="https://c89757.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB-FullTextIndex</title>
    <link href="https://c89757.github.io/2024/04/24/InnoDB-FullTextIndex/"/>
    <id>https://c89757.github.io/2024/04/24/InnoDB-FullTextIndex/</id>
    <published>2024-04-24T11:24:50.000Z</published>
    <updated>2024-04-24T16:02:56.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>InnoDB全文检索索引，是基于文本的列(CHAR、VARCHAR或TEXT列)上创建的，以加快对这些列中包含的数据的查询和DML操作。</p><p>InnoDB全文索引采用了倒排索引设计。倒排索引存储一个单词列表，对于每个单词，存储该单词出现在其中的文档列表。为了支持邻近搜索，每个字的位置信息也以字节偏移量的形式存储</p><p><code>MySql5.7.6</code>之前，全文检索只支持英文索引，不支持中文全文索引。</p><p><code>MySql5.7.6</code>之后，内置了<code>ngram</code>全文解析器，用来支持中文、日文、韩文分词</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>全文搜索使用MATCH() AGAINST()语法执行。MATCH()接受一个逗号分隔的列表，该列表指定要搜索的列。AGAINST接受一个要搜索的字符串和一个可选的修饰符，该修饰符指示要执行的搜索类型。</p></blockquote><p>全文检索支持三种搜索方式</p><ul><li><p>自然语言搜索</p><p>将搜索字符串解释为自然人类语言中的短语(自由文本中的短语)。</p><p>如果给出了<code>IN natural language MODE</code>修饰符，或者没有给出修饰符，全文搜索就是自然语言搜索。</p></li><li><p>boolean搜索</p><p>使用特殊查询语言的规则解释搜索字符串。</p><p>字符串包含要搜索的单词。例如某个单词必须在匹配行中出现或不存在</p></li><li><p>查询扩展搜索</p><p>是对自然语言搜索的修改。</p><p>搜索字符串用于执行自然语言搜索。然后将搜索返回的最相关行的单词添加到搜索字符串中，并再次进行搜索。该查询返回第二次搜索的行。</p></li></ul><h1 id="自然语言搜索"><a href="#自然语言搜索" class="headerlink" title="自然语言搜索"></a>自然语言搜索</h1><blockquote><p>默认情况下或使用IN NATURAL LANGUAGE MODE修饰符时，MATCH()函数针对文本集合执行字符串的自然语言搜索。集合是包含在FULLTEXT索引中的一个或多个列的集合。搜索字符串作为参数提供给AGAINST()。对于表中的每一行，MATCH()返回一个相关性值;也就是说，搜索字符串与MATCH()列表中指定的列中该行中的文本之间的相似性度量。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   title <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   body TEXT,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   FULLTEXT (title,body)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.08</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> articles (title,body) <span class="keyword">VALUES</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   (<span class="string">&#x27;MySQL Tutorial&#x27;</span>,<span class="string">&#x27;DBMS stands for DataBase ...&#x27;</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   (<span class="string">&#x27;How To Use MySQL Well&#x27;</span>,<span class="string">&#x27;After you went through a ...&#x27;</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   (<span class="string">&#x27;Optimizing MySQL&#x27;</span>,<span class="string">&#x27;In this tutorial, we show ...&#x27;</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   (<span class="string">&#x27;1001 MySQL Tricks&#x27;</span>,<span class="string">&#x27;1. Never run mysqld as root. 2. ...&#x27;</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   (<span class="string">&#x27;MySQL vs. YourSQL&#x27;</span>,<span class="string">&#x27;In the following database comparison ...&#x27;</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   (<span class="string">&#x27;MySQL Security&#x27;</span>,<span class="string">&#x27;When configured properly, MySQL ...&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">6</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">6</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="keyword">MATCH</span> (title,body)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> AGAINST (<span class="string">&#x27;database&#x27;</span> <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------+------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> title             <span class="operator">|</span> body                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------+------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> MySQL Tutorial    <span class="operator">|</span> DBMS stands <span class="keyword">for</span> DataBase ...             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> MySQL vs. YourSQL <span class="operator">|</span> <span class="keyword">In</span> the following database comparison ... <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------+------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>默认情况下，以不区分大小写的方式执行搜索。若要执行区分大小写的全文搜索，请对索引列使用二进制排序。例如，可以为使用的<code>latin1</code>字符集的列分配<code>latin1_bin</code>排序规则，使其对全文搜索区分大小写。</p><p>当在WHERE子句中使用MATCH()时，如前面所示的示例，只要满足以下条件，返回的行将自动按照最高相关性优先排序：</p><ul><li>必须没有显式的ORDER BY子句。</li><li>必须使用全文索引扫描而不是表扫描来执行搜索。</li><li>如果查询连接表，则全文索引扫描必须是连接中最左边的非常量表。</li></ul><p>要计算count值，你可以这么写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> articles </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span> (title,body)</span><br><span class="line">AGAINST (<span class="string">&#x27;database&#x27;</span> <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE);</span><br></pre></td></tr></table></figure><p>有时候这样写可能会更快</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">     <span class="built_in">COUNT</span>(IF(<span class="keyword">MATCH</span> (title,body) AGAINST (<span class="string">&#x27;database&#x27;</span> <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE), <span class="number">1</span>, <span class="keyword">NULL</span>))</span><br><span class="line">     <span class="keyword">AS</span> count</span><br><span class="line">     <span class="keyword">FROM</span> articles;</span><br></pre></td></tr></table></figure><blockquote><p>第一个查询做了一些额外的工作(根据相关性对结果排序)，但也可以使用基于WHERE子句的索引查找。如果搜索匹配的行很少，索引查找可能会使第一个查询更快。第二个查询执行全表扫描，如果搜索词出现在大多数行中，则可能比索引查找快。</p></blockquote><p>对于自然语言全文搜索，MATCH()函数中命名的列必须与表中某些<code>FULLTEXT</code>索引中包含的列相同。</p><p>对于前面的查询，MATCH()函数中指定的列(title和body)与文章表<code>FULLTEXT</code>索引定义中指定的列相同。</p><p>要分别搜索标题或正文，需要为每列创建单独的<code>FULLTEXT</code>索引。</p><p>使用索引的全文搜索只能在MATCH()子句中命名单个表中的列，因为索引不能跨多个表。</p><h1 id="全文索引表"><a href="#全文索引表" class="headerlink" title="全文索引表"></a>全文索引表</h1><p>创建InnoDB全文索引时，会创建一组索引表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table_id, name, space <span class="keyword">from</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES;</span><br></pre></td></tr></table></figure><p>辅助索引表名的前缀是<code>FTS</code>_，后缀是<code>index_#</code>。每个辅助索引表通过与被索引表的<code>table_id</code>匹配的辅助索引表名中的十六进制值与被索引表相关联。</p><h1 id="全文检索缓存"><a href="#全文检索缓存" class="headerlink" title="全文检索缓存"></a>全文检索缓存</h1><p>当文本被插入时，将对其进行标记，并将单个单词和相关数据插入全文索引中。</p><p>这个过程，即使对于文本比较小，也可能导致对索引表进行大量小的插入，从而使对这些表的并发访问成为争用点。</p><p>为了避免这个问题，InnoDB使用全文索引缓存来临时缓存索引表中最近插入的行。</p><p>插入时先保存到这个内存缓存结构，直到缓存满，然后将它们批量刷新到磁盘(到辅助索引表)</p><p>可以通过如下语句，查询最近插入的行的标记化数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_FT_INDEX_CACHE;</span><br></pre></td></tr></table></figure><p>缓存和批处理刷新行为避免了对辅助索引表的频繁更新，还避免了对同一个单词的多次插入，并最大限度地减少了重复条目。不是逐个刷新每个单词，而是将相同单词的插入合并并作为单个条目刷新到磁盘，从而提高了插入效率，同时使辅助索引表尽可能小。</p><blockquote><p>全文索引缓存，仅仅为最近插入的行 缓存标记化的数据，查询时，已经刷新到磁盘的数据不会被带回到全文检索缓存中。直接查询辅助索引表中的数据，并且在返回之前，将辅助索引表中的结果与全文索引缓存中的结果合并。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;InnoDB全文检索索引，是基于文本的列(CHAR、VARCHAR或TEXT列)上创建的，以加快对这些列中包含的数据的查询和DML操作。&lt;/p&gt;
&lt;p&gt;InnoDB全文索引采用了倒排索引设计。倒排索引存储一个单词列表，对于每个单词，存储该单词出现在</summary>
      
    
    
    
    <category term="MySql" scheme="https://c89757.github.io/categories/MySql/"/>
    
    
    <category term="MySql" scheme="https://c89757.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>XA事务与两阶段提交</title>
    <link href="https://c89757.github.io/2024/04/23/XA%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/"/>
    <id>https://c89757.github.io/2024/04/23/XA%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/</id>
    <published>2024-04-22T16:15:30.000Z</published>
    <updated>2024-04-23T16:22:42.575Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>MySQL分为server层和存储引擎层，而<strong>事务具体是在存储引擎层实现的</strong>。</p><p>在书写包含在一个事务中的语句时，不同语句可能会涉及不同存储引擎的表，这时如果我们想保持整个事务要么全部执行，要么全部不执行的话，本质上就需要保证各个存储引擎的事务全部提交，或者全部回滚。</p></blockquote><p>我们有一个大的事务，我们可以称其为<code>全局事务</code>，这个全局事务由若干的小的事务组成。要实现这个大的事务，就必须让它对应的若干个小的事务全部完成，或者全部回滚。我们也可以把这个大的全局事务称作<code>分布式事务</code>。</p><h1 id="XA规范"><a href="#XA规范" class="headerlink" title="XA规范"></a>XA规范</h1><p>XA规范提出了2个角色</p><ul><li>一个全局事务由多个小的事务组成，所以需要一个事务协调器（Transaction Coordinator）或资源管理器（Resource Manager）</li><li>管理一个小事务的角色被称为事务管理器（Transaction Manager）</li></ul><p>要提交一个全局事务，那么属于该全局事务的若干个小事务就应该全部提交，只要有任何一个小事务无法提交，那么整个全局事务就应该全部回滚。</p><p>XA规范中指出，要提交一个全局事务，必须分为2步</p><ul><li><p>Prepare阶段</p><p>当事务协调器准备提交一个全局事务时，会依次通知各个事务管理器，进行提交，如果事务管理器觉得没有问题，就把执行过程中所产生的redo日志都刷新到磁盘，然后应答事务协调器；如果事务协调器不能正确提交事务，则也需要通知事务协调器</p></li><li><p>Commit阶段</p><p>如果在Prepare阶段各个事务管理器给事务协调器的应答都是OK，没有问题，那么事务协调器就要真正通知各个事务管理器，去提交事务。</p><p>如果Prepare阶段有事务管理器给事务协调器的应答是，不能提交事务，于是事务协调器就通知各个事务管理器，进行事务回滚。</p><p>不过在事务协调器在统一提交和回滚之前，都需要在某个地方记录一下这个全局事务已提交，以及各个子事务的状态信息。</p></li></ul><p>XA规范把上述全局事务提交时所经历的两个阶段称作<strong>两阶段提交</strong>。</p><h1 id="MySql中的XA事务"><a href="#MySql中的XA事务" class="headerlink" title="MySql中的XA事务"></a>MySql中的XA事务</h1><p>MySQL中的XA事务分为<code>外部XA</code>和<code>内部XA</code></p><h2 id="外部XA"><a href="#外部XA" class="headerlink" title="外部XA"></a>外部XA</h2><p>在MySql的外部XA实现中，MySql服务器充当事务管理器，而连接服务器的客户端程序充当事务协调器。</p><p>想在MySQL中使用XA事务，需要一些特殊的语句：</p><ul><li><code>XA &#123;START|BEGIN&#125; xid</code> ：该语句用于开启一个<code>XA</code>事务，此时该<code>XA</code>事务处于<code>ACTIVE</code>状态。</li></ul><p>在一台MySql服务器上，每个XA事务都必须有一个唯一的id，被称作<code>xid</code>。这个<code>xid</code>是由发其<code>XA</code>事务的应用程序（客户端）自己指定的，只要我们自己保证它唯一就好了。</p><p>这个<code>xid</code>其实是由<code>gtrid</code>、<code>bqual</code>、<code>formatID</code>三个部分组成的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xid: gtrid [, bqual [, formatID ]]</span><br></pre></td></tr></table></figure><p>其中<code>gtrid</code>（global transaction id）是指全局事务id，是一个字符串，<code>bqual</code>是指分支限定符，<code>formatID</code>是指<code>gtrid</code>和<code>bqual</code>所使用的格式。<code>bqual</code>和<code>formatID</code>省略。</p><ul><li><p><code>XA END xid</code>：在使用<code>XA START xid</code>开启了一个XA事务后，客户端就可以接着发送属于这个XA事务的各条语句，等所有语句都发送完毕后，就可以接着发送<code>XA END xid</code>来告知服务器由<code>xid</code>标识的XA事务的所有语句都输入完了。此时该XA事务处于<code>IDLE</code>状态。</p></li><li><p><code>XA PREPARE xid</code>：对于处于<code>IDLE</code>状态的XA事务，应用程序就可以询问MySQL服务器是否准备好提交这个XA事务了，此时就可以给服务器发送<code>XA PREPARE xid</code>语句。当MySQL服务器收到此语句后，就需要做准备提交前的工作了，比如把该事务执行过程中所产生的redo日志刷新到磁盘等。此时XA事务处于<code>PREPARE</code>状态。</p></li><li><p><code>XA ROLLBACK xid</code>：应用程序通过发送此语句来让MySQL服务器回滚xid所标识的事务。此时XA事务处于<code>ABORT</code>状态。</p></li><li><p><code>XA RECOVER</code>：应用程序想看一下当前MySQL服务器上已经处于Prepare状态的XA事务有哪些，就可以发送该语句。</p></li></ul><p>现在各个公司由于表中数据太多，这些数据会被分散在不通服务器中存储。由应用程序员分别和不同的MySQL服务器打交道实在费劲，所以有一种称作<code>数据库中间件</code>的东西开始问世。即应用程序只将SQL语句发送给数据库中间件，中间件分析一下该SQL访问的数据都在哪些不同的服务器中存储着，并且计算出不通服务器应该执行哪些SQL语句。然后就可以对不同的服务器分别开启XA事务，并且让把不同服务器需要执行的语句分别发送到不同的服务器中。等应用程序员告知中间件准备提交事务时，中间件先给各个服务器发送<code>XA PREPARE</code>语句，如果各个服务器都返回OK的话，接着就给各个服务器发送<code>XA COMMIT</code>语句来提交XA事务，等各个服务器把提交成功的消息返回给中间件，中间件就可以通知应用程序事务提交成功了。</p><h2 id="内部XA"><a href="#内部XA" class="headerlink" title="内部XA"></a>内部XA</h2><p>对于一台服务器来说，即使客户端使用<code>BEGIN/START TRANSACTION</code>语句开启的普通事务，事务所包含的语句也有可能涉及多个存储引擎。此时MySQL内部采用XA规范来保证所有支持事务的存储引擎要么全部提交，要么全部回滚，这也被称作MySQL的<code>内部XA</code>。</p><p>在MySQL内部执行一个事务时，存储引擎会修改相应的数据，server层会记录语句对应的binlog。这是一个原子性的行为，要么都完成，要么都不完成</p><p>那我们需要保证：如果存储引擎提交了事务，server层的<code>binlog</code>日志必须也被写入到硬盘上；如果存储引擎回滚了事务，server层的<code>binlog</code>日志必须不能被写入到硬盘上。</p><p>那我们需要保证：<strong>如果存储引擎提交了事务，server层的binlog日志必须也被写入到硬盘上；如果存储引擎回滚了事务，server层的binlog日志必须不能被写入到硬盘上</strong>。</p><h2 id="有binlog参与的内部XA事务"><a href="#有binlog参与的内部XA事务" class="headerlink" title="有binlog参与的内部XA事务"></a>有binlog参与的内部XA事务</h2><p> 当客户端执行<code>COMMIT</code>语句或者在自动提交的情况下，MySQL内部开启一个XA事务，分两阶段来完成XA事务的提交：</p><ul><li><p>Prepare阶段：存储引擎将该事务执行过程中产生的redo日志刷盘，并且将本事务的状态设定为<code>PREPARE</code>。<code>binlog</code>啥也不干，下面看一下具体的代码</p><p>首先我们知道事务执行过程中需要写undo日志，这些undo日志被写到若干个页面中，这些页面也被称作<code>Undo页面</code>，这些页面会串成一个链表，称作<code>Undo页面</code>链表。在一个事务对应的Undo页面链表的首个页面中，记录了一些关于这个事务的一些属性。</p></li></ul><p><img src="/2024/04/23/XA%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/typora-user-images\XA事务与两阶段提交\image-20240423221552725.png" alt="image-20240423221552725"></p><p><code>Undo Log Segment Header</code>部分</p><p><img src="/2024/04/23/XA%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/typora-user-images\XA事务与两阶段提交\image-20240423221840133.png" alt="image-20240423221840133"></p><p>其中的<code>TRX_UNDO_STATE</code>字段就表明该事务目前处于什么状态。当处于Prepare阶段时，会将<code>TRX_UNDO_STATE</code>字段的值设置为<code>TRX_UNDO_PREPARED</code>（整数5），表明当前事务处在Prepare阶段。</p><p><code>Undo Log Header</code>部分：</p><p>包括了各种信息，其中有两个属性</p><p><code>TRX_UNDO_XID_EXISTS</code>：表示有没有xid信息</p><p><code>XID</code>信息：表示具体的xid是什么</p><p>当处于Prepare阶段时，调用<code>innobase_xa_prepare</code>函数会将<code>TRX_UNDO_XID_EXISTS</code>设置为TRUE，并将本次内部XA事务的<code>xid</code>（这个xid是mysql自己生成的）写入<code>XID信息</code>处。</p><ul><li>Commit阶段：先将事务执行过程中产生的<code>binlog</code>刷新到硬盘，再执行存储引擎的提交工作。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;MySQL分为server层和存储引擎层，而&lt;strong&gt;事务具体是在存储引擎层实现的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在书写包含在一个事务中的语句时，不同语句可能会涉及不同存储引擎的表，这时如果我们想保持整个事务要么全部执行，要么全部不执行的</summary>
      
    
    
    
    <category term="mysql" scheme="https://c89757.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="https://c89757.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySql的锁</title>
    <link href="https://c89757.github.io/2024/04/21/MySql%E7%9A%84%E9%94%81/"/>
    <id>https://c89757.github.io/2024/04/21/MySql%E7%9A%84%E9%94%81/</id>
    <published>2024-04-21T07:23:11.000Z</published>
    <updated>2024-04-22T16:09:47.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h1><blockquote><p>一致性读：事务利用<code>MVVC</code>进行读取操作称为一致性读（或者称为快照读），一致性读不会对表中任何记录加锁<br>锁定读：通过加锁的方式</p></blockquote><ul><li>共享锁（S锁）</li></ul><blockquote><p>多个事务可以同时拥有共享锁，但是会排斥独占锁</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ...... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure><p>如： 事务1拥有数据行的共享锁，此时事务2可以获取到该数据行的共享锁，但是如果事务2想要获取独占锁的话，会被阻塞，直到事务1释放共享锁后，才能获取到独占锁</p><ul><li>独占锁（X锁）</li></ul><blockquote><p>只有一个事务可以获取到独占锁，会排斥其他共享锁、独占锁</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ...... <span class="keyword">FOR</span> UPDATE</span><br></pre></td></tr></table></figure><p>如：事务1拥有数据行的独占锁后，此时事务2无论是想获取该数据行的共享锁还是独占锁都将被阻塞，直到事务1释放独占锁为止</p><h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><ul><li>表级S锁</li></ul><p>如果一个事务给表加了S（共享）锁，那么：</p><p>其他事务<strong>可以</strong>继续获得该表的<strong>S</strong>锁</p><p>其他事务<strong>可以</strong>继续获得表中数据行的<strong>S</strong>锁</p><p>其他事务<strong>不能</strong>获得继续获得该表的<strong>X</strong>锁</p><p>其他事务<strong>不能</strong>获得继续获得该表中数据行的<strong>X</strong>锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES `table_name` READ;</span><br></pre></td></tr></table></figure><ul><li>表级X锁</li></ul><p>如果一个事务给表加了X（独占）锁，那么：</p><p>其他事务<strong>不能</strong>继续获得该表的<strong>S</strong>锁</p><p>其他事务<strong>不能</strong>继续获得表中数据行的<strong>S</strong>锁</p><p>其他事务<strong>不能</strong>获得继续获得该表的<strong>X</strong>锁</p><p>其他事务<strong>不能</strong>获得继续获得该表中数据行的<strong>X</strong>锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES `table_name` WRITE;</span><br></pre></td></tr></table></figure><h1 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h1><p>在对表加表级独占锁时，如何知道表中的数据行是否已经被加了行锁呢？</p><ul><li>意向共享锁（Intention Shared Lock）：IS锁，当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁</li><li>意向独占锁（Intention Exclusive Lock）：IX锁，当事务准备在某条记录上加X锁时，需要现在表级别加一个IX锁</li></ul><blockquote><p>IS锁、IX锁是表级锁，他们的作用仅仅是为了在之后加表级别的S锁和X锁时，可以快速判断表中的记录是否被上锁</p></blockquote><h1 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h1><blockquote><p>MySQL使用元数据锁来管理对数据库对象的并发访问，并确保数据的一致性。元数据锁不仅适用于表，还适用于库、存储过程、函数、触发器等</p></blockquote><p><a href="https://dev.mysql.com/doc/refman/5.7/en/metadata-locking.html">官方文档解释</a></p><p>在对表执行<code>DDL</code>语句时，其实是通过<code>Metadata Lock（MDL）</code>来实现的。一般情况下，也不会使用<code>Innodb</code>引擎的表级锁。</p><p>比如：在对某个表执行<code>ALTER TABLE</code>等<code>DDL</code>语句时，其他事务对该表的<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>等语句时，会发生阻塞。</p><blockquote><p>不是所有的都会阻塞，某些情况下，<code>MySql</code>支持<code>online ddl</code>，提供了并发<code>DML</code>的支持，不会对其他事务的读写数据产生阻塞</p></blockquote><h1 id="AUTO-INC锁"><a href="#AUTO-INC锁" class="headerlink" title="AUTO_INC锁"></a>AUTO_INC锁</h1><p>我们可以给表的某个列加上<code>AUTO_INCREMENT</code>属性，让其自增</p><p>系统在给该列递增赋值时，有两种方式，由系统变量<code>innodb_autoinc_lock_mode</code>控制，他有三个可选值</p><ul><li>0：采用<code>AUTO_INC</code>锁，也就是在执行插入语句时，加一个表级别的<code>AUTO_INC</code>锁，然后为每条待插入记录的<code>AUTO_INCREMENT</code>列分配递增的值。在该语句执行结束之后（不是提交事务后），就会把<code>AUTO_INC</code>锁释放掉。</li><li>2：采用轻量级锁，在插入数据，生成<code>AUTO_INCREMENT</code>列的值时，获取这个轻量级锁，然后在生成本次插入语句需要的<code>AUTO_INCREMENT</code>值之后，就把这个锁释放掉，而不需要等到整个插入语句执行完成之后才释放锁</li><li>1：二者混用。当插入条数确定时，采用轻量级锁；当插入条数不确定时，采用轻量级锁采用<code>AUTO_INC</code>锁，如<code>INSERT INTO ... SELECT </code>、<code>REPLACE...SELECT</code>等语句。</li></ul><h1 id="INNODB中的行级锁"><a href="#INNODB中的行级锁" class="headerlink" title="INNODB中的行级锁"></a>INNODB中的行级锁</h1><p><code>INNDODB</code>中，有几种不同类型的行锁</p><ul><li>LOCK_REC_NOT_GAP</li></ul><p>就是最’’普通’的行锁。这种行锁有S锁和X锁的区分的</p><ul><li>LOCK_GAP</li></ul><p>间隙锁，顾名思义，会对数据行之间的间隙加锁</p><p>给一个数据行加上间隙锁之后，会锁住其前面的间隙，不允许其他事务在这个区间执行插入操作。给一条记录加gap锁，并不会影响其他事务对该条记录加行锁或者继续加gap锁</p><p>当我们给<code>Supremum</code>加上gap锁之后，表示从数据最大行 ~ +∞ 这区间，不允许插入数据</p><ul><li>LOCK_ORDINARY</li></ul><p>这种类型的锁，既可以锁住某条记录，也可以给它加gap锁，即可以阻止其他事务在该记录的前面的间隙插入新记录。</p><ul><li>LOCK_INSERT_INTENTION</li></ul><p>插入意向锁</p><p>一个事务在插入一条记录时，需要判断插入位置是否已被别的事务加了gap锁。如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交为止。在这个等待的过程中，也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在处于等待状态。</p><p>这种类型的锁命名为Insert Intention Lock。</p><ul><li>隐式锁</li></ul><p>一般情况下，执行<code>INSERT</code>语句是不需要在内存中生成锁结构的（如果当前插入的间隙已经被加了gap锁，那么本次insert操作会阻塞，并且当前事务会在该间隙上加入一个插入意向锁。）</p><p>如果当前插入的间隙没有加gap锁，那么当前事务不会为<code>INSERT</code>生成锁结构，但是如果有其他记录，想要获取这个数据，那该怎么办？</p><ul><li><p>情景1：对于聚簇索引记录来说，有一个<code>trx_id</code>隐藏列，该隐藏列记录着最后改动该记录的事务的事务id。</p><p>在当前事务中新插入一条聚簇索引记录后，该记录的<code>trx_id</code>隐藏列代表的就是当前事务的事务id。如果其他十五次是相对该记录添加S锁和X锁，首先会看一下该记录的<code>trx_id</code>隐藏列代表的事务是否是当前活跃事务。如果不是的话就可以正常读取。如果是的话，会帮当前事务创建一个X锁的锁结构，该锁结构的<code>is_waiting</code>属性为false；然后为自己也创建一个锁结构，该锁结构的<code>is_waiting</code>属性为true，之后自己进入等待状态。</p></li></ul><ul><li>情景2：对于二级聚簇索引来说，本身并没有<code>trx_id</code>隐藏列，但是在二级索引页面的<code>Page Header</code>部分有一个<code>PAGE_MAX_TRX_ID</code>属性，该属性代表对该页面做改动的最大的事务id。如果<code>PAGE_MAX_TRX_ID</code>属性值小于当前最小的活动事务id，那就说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后通过回表找到对应聚簇索引记录，然后再重复情景1的做法。</li></ul><h1 id="INNODB锁的内存结构"><a href="#INNODB锁的内存结构" class="headerlink" title="INNODB锁的内存结构"></a>INNODB锁的内存结构</h1><p>对一条记录加锁的本质就是在内存中创建一个锁结构与之关联。</p><p>如果符合以下条件，这些记录的锁就可以放到一个锁结构中：</p><ul><li>在同一个事务中进行加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样</li><li>等待状态的是一样的</li></ul><p>锁结构大致如下所示：</p><p><img src="/2024/04/21/MySql%E7%9A%84%E9%94%81/typora-user-images\MySql的锁\image-20240421234713237.png" alt="image-20240421234713237"></p><ul><li><p>锁所在的事务信息：无论是表级锁还是行级锁，一个锁属于一个事务，这里记载着该锁对应的事务信息</p><blockquote><p>锁所在的事务信息在内存结构中只有一个指针，所以不会占用多大内存空间。通过指针可以找到内存中关于该事务的更多信息</p></blockquote></li><li><p>索引信息：对于行级锁来说，需要记录以下加锁的记录属于哪个索引</p></li><li><p>表级/行锁信息：表级锁结构和行级锁结构在这个位置内容是不同的</p></li><li><p>type_mode：锁的类型</p></li></ul><h1 id="语句加锁分析"><a href="#语句加锁分析" class="headerlink" title="语句加锁分析"></a>语句加锁分析</h1><h2 id="普通的select"><a href="#普通的select" class="headerlink" title="普通的select"></a>普通的select</h2><ul><li><code>READ UNCOMMITTED</code>：不加锁，直接读取记录的最新版本；可能出现脏读、不可重复读和幻读现象</li><li><code>READ COMMITTED</code>：不加锁，在每次执行普通的select语句时，都会生成一个<code>ReadView</code>，这样避免了脏读现象，能避免脏读，但是不能避免不可重复读和幻读现象</li><li><code>REPEATABLE READ </code>：不加锁，只有在第一次执行select时，会生成<code>ReadView</code></li><li><code>SERIALIZABLE</code>：<ul><li><code>autocommit</code> = 0 时，普通的select语句会自动加上共享锁，也就是<code>select ... lock in share mode</code>。</li><li><code>autocommit</code> = 1 时，即启用自动提交，不会加锁，利用<code>MVVC</code>生成<code>ReadView</code>来读取记录。（启用自动提交后，意味着一个事务中只包含一条语句，而一条语句不会出现可重复读、幻读的现象）</li></ul></li></ul><h2 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h2><ul><li>SELECT … LOCK IN SHARE MODE</li><li>SELECT … FOR UPDATE</li><li>UPDATE …</li><li>DELETE …</li></ul><blockquote><p> <code>update</code> 和 <code>delete</code> 在执行过程中，需要首先定位到被改动的记录并给记录加锁，因此也能被认定为是一种锁定读</p></blockquote><ul><li><p>匹配模式（match mode）</p><p>在使用索引进行扫描时，查询优化器首先会生成若干个扫描区间。如果对于联合索引 [a，b]，有下面几种情况</p><ul><li>精确匹配：如果形成扫描区间匹配时只有一个值，是一个单点扫描区间。比如where a = 1，扫描区间就是[1,1]。或者where a = 1 and b = 1，也属于精确扫描</li><li>不精确匹配：如果形成的扫描区间有多个值，比如 where a = 1 and b &gt; 1，扫描区间是 [(1,1), (1, +∞)]，这种就不算是单点扫描区间，这种匹配模式就是不精确匹配</li></ul></li><li><p>唯一性搜索（unique search）</p><p>如果在扫描某个区间的记录前，就能事先确定该扫描区间内最多只包含一条记录的话，那么就把这种情况称作唯一性搜索</p><ul><li>匹配模式为精确匹配</li><li>使用的索引是主键或唯一二级索引</li><li>如果使用的索引是唯一二级索引，并且搜索条件不能为”索引列IS NULL”的形式（因为唯一二级索引来说，可以存储多个值为NULL 的记录）</li><li>如果索引中包含多个列，那么在生成扫描区间时，每一个列都得被用到、</li></ul><blockquote><p>也就是说，搜索条件能够确定结果只有唯一一条</p></blockquote></li></ul><p><strong><code>SELECT ... LOCK IN SHARE MODE</code>加锁过程</strong></p><p>隔离级别**不大于<code>READ COMMITED</code>**时，一般情况下，读取某个扫描区间中记录的过程如下：</p><ol><li><p>首先快速在B+树叶子节点中定位到该扫描区间中的第一条记录，把该记录作为当前记录</p></li><li><p>为当前记录加S型行锁</p></li><li><p>判断索引条件下推的条件是否成立</p><p>索引下推：（<code>index condition pushdown</code>,<code>ICP</code>）把一些搜索条件下推到存储引擎中判断，而不是返回到Server层再判断。<code>ICP</code>只适用于二级索引，不适用于聚簇索引。仅适用于select语句，不适用<code>update</code>、<code>delete</code></p></li><li><p>执行回表操作</p><p>如果扫描的是二级索引记录，则可能需要回表获取聚簇索引记录，并且给该聚簇索引记录加S型行锁</p></li><li><p>判断边界条件是否成立</p></li><li><p>server层判断条件是否成立</p></li></ol><blockquote><p>对于上述的查询过程来说，如果走的二级索引，会先将二级索引加行锁，并且回表后，还需要给聚簇索引记录加行锁</p></blockquote><p>在隔离级别不大于<code>READ COMMITED</code>时，在扫描区间时，先给记录加锁，如果记录不满足条件时，则释放锁，如果记录满足条件，则不会释放锁</p><p>隔离级别**不小于<code>REPETATABLE READ</code>**时，对一个select语句来说</p><p>如果扫描的是聚簇索引，则：</p><p>在对区间扫描时，加的是S型的<code>LOCK_ORDINARY</code>，也就是行锁+gap锁。</p><p>如果扫到的记录符合条件，则不会释放锁；如果扫到的记录不符合条件，也不会释放锁。</p><p>如果先扫描二级索引，再回表扫描聚簇索引，则：</p><p>在对二级索引的区间扫描时，先对<strong>二级索引记录</strong>加上<strong>S型</strong>的<code>LOCK_ORDINARY</code>，也就是<strong>行锁+gap锁</strong>，然后回表找到聚簇索引对应行，对该<strong>聚簇索引记录</strong>加一个<strong>S型行锁</strong>。</p><p>存储引擎将查询到的聚簇索引记录返回给Server层，Server层判断记录是否符合条件，如果<strong>符合</strong>，则<strong>不会</strong>释放加在该记录上的锁</p><p>如果Server层判断记录<strong>不符合</strong>条件，则丢弃这条结果数据，并且也<strong>不会</strong>释放加在该记录上的锁</p><blockquote><p>SELECT … FOR UPDATE语句加锁过程与上述的SELECT … LOCK IN SHARE MODE语句类似，只不过加的都是X锁 </p></blockquote><p>如果匹配模式是精确模式</p><ul><li>隔离级别不大于<code>READ_COMMITTED</code>时，不会为扫描区间后面的下一条记录加锁</li><li>隔离级别不小于<code>REPEATABLE_READ</code>时，则会为扫描区间后面的下一条记录加gap锁</li></ul><ul><li>当隔离级别不小于<code>REPEATABLE READ</code>时，如果匹配模式不是精确匹配，并且没有找到精确匹配的记录，则会为该扫描区间后面的下一条记录加<code>LOCK_ORDINARY</code>（行锁+gap锁）</li><li>无论是哪个隔离级别，只要是唯一型搜索，并且读到的记录没有标记为’已删除’（记录头信息中的<code>delete_flag</code> = 1），就为读取到的记录加行锁</li></ul><h1 id="查看事务加锁情况"><a href="#查看事务加锁情况" class="headerlink" title="查看事务加锁情况"></a>查看事务加锁情况</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.INNODB_TRX;</span><br></pre></td></tr></table></figure><ul><li><code>trx_tables_locked</code>：表级锁</li><li><code>trx_rwos_locked</code>：加了多少个行级锁（不包含隐式锁）</li><li><code>trx_lock_structs</code>：表示该事务生成了多少个内存中的锁结构</li></ul><blockquote><p>系统中发生了某个事务因为想要获取锁而被阻塞的情况时，会在这个表中记录</p><p>tips：已过时，在<code>MySql8.0</code>中已经被移除</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.INNODB_LOCKS;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINE INNODB STATUS;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;行级锁&quot;&gt;&lt;a href=&quot;#行级锁&quot; class=&quot;headerlink&quot; title=&quot;行级锁&quot;&gt;&lt;/a&gt;行级锁&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;一致性读：事务利用&lt;code&gt;MVVC&lt;/code&gt;进行读取操作称为一致性读（或者称为快照读），一致性读不</summary>
      
    
    
    
    <category term="MySql" scheme="https://c89757.github.io/categories/MySql/"/>
    
    
    <category term="MySql" scheme="https://c89757.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>MySql增加varchar长度</title>
    <link href="https://c89757.github.io/2024/04/17/MySql%E5%A2%9E%E5%8A%A0varchar%E9%95%BF%E5%BA%A6/"/>
    <id>https://c89757.github.io/2024/04/17/MySql%E5%A2%9E%E5%8A%A0varchar%E9%95%BF%E5%BA%A6/</id>
    <published>2024-04-17T11:29:10.000Z</published>
    <updated>2024-04-17T16:17:33.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近需要增加某个<code>varchar</code>字段的长度，由<code>varchar(50)</code>扩展为<code>varchar(100)</code>，但是表中数据很大，担心锁表，想到了<code>MySql</code>的<code>online-DDL</code>，于是测试了一下，发现了一些有趣的事情，记录一下。</p><br><h1 id="varchar"><a href="#varchar" class="headerlink" title="varchar"></a>varchar</h1><blockquote><p> 先从<code>varchar</code>字段的存储方式说起，人们通常拿<code>char</code>和<code>varchar</code>对比，此处也一起探讨下。</p><p><a href="#https://dev.mysql.com/doc/refman/5.7/en/char.html">官网文档对二者的说明</a></p></blockquote><p>​    <code>char</code>类型的字段长度固定，在建表时的申明就已经确定，长度范围在0 ~ 255，数据的真实长度不足时，会用空格填充。如果数据本身就带有空格，在检索时，会删除尾随的空格，除非开启<code>sql_mode</code>：<code>PAD_CHAR_TO_FULL_LENGTH S</code></p><p>​    <code>varchar</code>是可变长字段，长度范围在0 ~ 65535。在数据行中的格式中，一般还会有个可变长字段长度列表，来记录变长字段存储的真实长度。</p><p>（针对某些行格式来说，如compact，如果采用的是不定长的编码字符集的话，比如<code>gbk</code>表示一个字符要1~2字节，<code>mysql</code>的<code>utf8</code>表示一个字符要1~3字符，此时char类型的字段的长度 也会被加到可变长字段长度列表中）</p><br><h1 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h1><ul><li>compact</li></ul><p>如果表采用的是compact行格式，那每个数据行的格式如下</p><img src="/2024/04/17/MySql%E5%A2%9E%E5%8A%A0varchar%E9%95%BF%E5%BA%A6/image-20240417202411995.png" class><br><p>其中我们重点关注一下 <strong>变长字段长度列表</strong> 这个结构，需要注意的是，这个结构并不是在所有数据行都有，它只存储值不为空的列的长度。</p><blockquote><p>也就是说，如果一行数据中，没有变长字段，或者所有的变长字段都为空，就不需要有这个结构</p></blockquote><p>针对某一行的某一个<code>varchar</code>字段来说，如果他不为空的话，则<strong>在变长字段长度列表中</strong>，需要1~2个字节来存储其数据的长度，具体是一个字节还是两个字节，规则如下：</p><ul><li>如果变长字段允许的最大长度不超过255，则使用一个字节存储</li><li>如果变长字段允许的最大长度超过了255，并且实际的长度超过了127字节时，需要两个字节去存储其长度</li><li>列为溢出列（下面解释何为溢出列）</li></ul><blockquote><p>比如针对 <code>utf8mb4</code>编码的行来说，<code>varchar(30)</code>，最多可以存储的字节为：4 * 30 = 120字节，此时在变长字段长度列表中，只需要一个字节存储其长度即可。</p></blockquote><p><code>MySql</code>对数据行的大小都有一定限制，如果变长字段存储的值很长，超过一定长度怎么办？</p><p>针对这种很长、占用字节数很多的列，在记录真实数据处只会存储改列的一部分数据，而把剩余的数据存放在外部页中，然后用20字节指针指向外部页。这种列称为<code>溢出列</code></p><p>针对<code>compcat</code>行格式来说，如果一列数据特别多，则只会存储前<code>768</code>字节的数据，然后将剩余数据记录在其他页中，数据格式如下：</p><br><img src="/2024/04/17/MySql%E5%A2%9E%E5%8A%A0varchar%E9%95%BF%E5%BA%A6/image-20240417211255191.png" class><br><p>需要注意的是，此时变长列表中记录的长度，是内部存储部分的长度 + 20字节指针。这里就是 768 + 20</p><br><blockquote><p>所以不论数据多长，占用多少字节，都只需要两个字节存储其长度</p></blockquote><br><ul><li>dynamic</li></ul><p><code>dynamic</code>行格式是<code>compcat</code>的变种，具有相同的存储特性。</p><p>在处理溢出页上，<code>dynamic</code>不会在记录的真实数据处存储该溢出列真实数据的前768字节，而是把所有真实数据都存储到溢出页中，只在记录的真实数据处存储20字节大小的指针。</p><br><img src="/2024/04/17/MySql%E5%A2%9E%E5%8A%A0varchar%E9%95%BF%E5%BA%A6/image-20240417215418849.png" class><br><h1 id="online-ddl"><a href="#online-ddl" class="headerlink" title="online-ddl"></a>online-ddl</h1><blockquote><p><code>MySql</code> 在线<code>DDL</code>功能，提供了一些特性，如：</p><p>更少的磁盘空间和I/O开销，尽可能少地加锁</p></blockquote><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-operations.html#online-ddl-column-operations">官网地址</a></p><ul><li>Extending <code>VARCHAR</code> column size</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">*</span>tbl_name<span class="operator">*</span> CHANGE <span class="keyword">COLUMN</span> c1 c1 <span class="type">VARCHAR</span>(<span class="number">255</span>), ALGORITHM<span class="operator">=</span>INPLACE, LOCK<span class="operator">=</span><span class="keyword">NONE</span>;</span><br></pre></td></tr></table></figure><br><p>值的注意的是：就地<code>ALTER TABLE</code>只支持将<code>VARCHAR</code>列的大小从0增加到255字节，或者从256字节增加到更大的大小。</p><p>原因就是上面所说的行格式。255字节时，只需要更改字段限制就好了。</p><p>如果我们把<code>VARCHAR(50)</code>更改<code>VARCHAR(63)</code>，假设行编码为<code>utf8mb4</code>，原长度为 50 * 4 &lt; 255，所以变长字段列表中只需要一个字节记录。修改后允许的最大长度为63字符，即最大字节为 63 * 4 = 252 &lt; 255。也只需要一个字节去记录长度，所以此时扩展其大小速度很快。</p><p>如果我们将大小修改为<code>VARCHAR(100)</code>，修改后允许的最大长度为100，即最大字节为 100 * 4 = 400 &gt; 255，此处是就需要两个字节去记录长度，所以此时扩展其大小速度比较慢，因为还需要调整每行的长度。</p><br><p>执行<code>DDL</code>语句时，可以通过以下语句查看锁情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    r.trx_id waiting_trx_id,</span><br><span class="line">    r.trx_mysql_thread_id waiting_thread,</span><br><span class="line">    r.trx_query waiting_query,</span><br><span class="line">    b.trx_id blocking_trx_id,</span><br><span class="line">    b.trx_mysql_thread_id blocking_thread,</span><br><span class="line">    b.trx_query blocking_query</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    information_schema.innodb_lock_waits w</span><br><span class="line">        <span class="keyword">INNER</span> <span class="keyword">JOIN</span> information_schema.innodb_trx b <span class="keyword">ON</span></span><br><span class="line">            b.trx_id <span class="operator">=</span> w.blocking_trx_id</span><br><span class="line">        <span class="keyword">INNER</span> <span class="keyword">JOIN</span> information_schema.innodb_trx r <span class="keyword">ON</span></span><br><span class="line">            r.trx_id <span class="operator">=</span> w.requesting_trx_id;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近需要增加某个&lt;code&gt;varchar&lt;/code&gt;字段的长度，由&lt;code&gt;varchar(50)&lt;/code&gt;扩展为&lt;code&gt;va</summary>
      
    
    
    
    <category term="MySql" scheme="https://c89757.github.io/categories/MySql/"/>
    
    
    <category term="MySql" scheme="https://c89757.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>MySql的日志</title>
    <link href="https://c89757.github.io/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/"/>
    <id>https://c89757.github.io/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/</id>
    <published>2024-04-14T10:06:02.000Z</published>
    <updated>2024-04-21T07:23:27.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><blockquote><p>二进制日志，记录了数据库发生的变化。如新建了一个数据库或者表、表结构发生改变、表中的数据发生了变化时都会记录相应的<code>binlog</code>日志。</p></blockquote><p>主要作用</p><ul><li>用于复制</li></ul><p><code>MySql</code>主从复制就依赖<code>binlog</code>，主服务器将数据<strong>同步</strong>给各个从服务器</p><ul><li>用于恢复</li></ul><p>数据误删后可以通过<code>binlog</code>恢复</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>可以通过如下命令查看是否当前服务器是否开启了<code>binlog</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_bin&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>binlog</code>日志并不是仅写到一个文件中，而是写入一组文件中，这组文件的命名如下：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">basename.<span class="number">000001</span></span><br><span class="line">basename.<span class="number">000002</span></span><br><span class="line">basename.<span class="number">000003</span></span><br><span class="line">basename.<span class="number">000004</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>启动选项<code>log-bin[=base_name]</code>中的<code>base_name</code>就是这组<code>binlog</code>日志文件名称都包含的部分。</p><p>如果不配置<code>basename</code>，<code>MySQL</code>服务器会默认将<code>主机名-bin</code>作为<code>binlog</code>日志文件的<code>basename</code>。</p><p>除了这些真正存储的<code>binlog</code>日志文件以外，<code>MySql</code>服务器还会在相同的路径下生成一个关于<code>binlog</code>的索引文件。</p><p>文件名为<code>.index</code>结尾，同时他是他是一个文本文件，里面存储的是各个<code>binlog</code>文件的路径</p><h2 id="查看binlog"><a href="#查看binlog" class="headerlink" title="查看binlog"></a>查看binlog</h2><p><code>binlog</code>中记录数据库发生更改的各种事件（events），这些事件的种类非常多，我们熟悉的有：</p><ul><li>WRITE_ROWS_EVENT：插入记录。</li><li>UPDATE_ROWS_EVENT：更新记录。</li><li>DELETE_ROWS_EVENT：删除记录。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> BINLOG EVENTS</span><br><span class="line">   [<span class="keyword">IN</span> <span class="string">&#x27;log_name&#x27;</span>]</span><br><span class="line">   [<span class="keyword">FROM</span> pos]</span><br><span class="line">   [LIMIT [<span class="keyword">offset</span>,] row_count]</span><br></pre></td></tr></table></figure><ul><li><p><code>[IN &#39;log_name&#39;]</code>：<code>log_name</code>表示我们要查看哪个<code>binlog</code>日志文件的内容。</p></li><li><p><code>[FROM pos]</code>：<code>pos</code>表示我们要查看<code>binlog</code>文件的起始偏移量（通过指定这个值可以直接去查看某个偏移量处的事件）。</p></li><li><p><code>offset</code>表示我们要从哪个事件开始查看，<code>row_count</code>表示我们要查看多少个事件。</p></li></ul><p><strong>mysqlbinlog</strong></p><blockquote><p>由于<code>binlog</code>是二进制格式的，我们不能直接以文本的形式查看。使用<code>SHOW BINLOG EVENTS</code>又只能看到粗略的信息，如果我们想查看<code>binlog</code>日志文件的详细信息的话，就需要使用<code>MySQL</code>给我们提供的实用工具——<code>mysqlbinlog</code>。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog ./basename.000001</span><br></pre></td></tr></table></figure><h1 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h1><blockquote><p>事务已经提交，但是还没有刷到磁盘，但是如果此时服务宕机，可能会造成数据丢失。</p><p>比如：数据刚提交，或者只更改了buffer pool中的数据，但是还没有刷新到磁盘，服务宕机，内存中的数据就没了。</p><p><code>redolog</code>记录的就是，对数据的更改操作。如把某个页的地址偏移量为1000的数据更改为2。这样即使服务宕机，重启后，只需要按照<code>redolog</code>记录的步骤重新更新数据页即可。</p><p>为了让已经提交的事务对数据的更改能永久生效，即使服务器崩溃，也能通过<code>redolog</code>恢复</p><p><code>redolog</code>是顺序写入磁盘的。</p></blockquote><h2 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h2><p><code>redolog</code>本质上只是记录了一下事务对数据库进行了哪些修改。</p><p><code>MySql</code>针对不同的修改场景，定义了多种类型的redo日志，但大部分类型的redo日志都有以下这种通用格式</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240414192757001.png" alt="image-20240414192757001"></p><ul><li>type：这条redo日志的类型</li><li>space ID：表空间ID</li><li>page number：页号</li><li>data：这条redo日志的具体内容</li></ul><h2 id="简单的日志类型"><a href="#简单的日志类型" class="headerlink" title="简单的日志类型"></a>简单的日志类型</h2><p>有些极其简单的修改，只需要记录一些某个页面的某个偏移量处修改了几个字节、修改后的内容，这种极其简单的<code>redolog</code>称为物理日志，并且根据在页面中写入数据的多少划分为几种不同类型的<code>redo</code>日志类型.</p><ul><li><code>MLOG_1BYTE</code>（type字段对应的十进制数字为1）：表示在某个页面偏移量处写了1字节的redo日志类型</li><li><code>MLOG_2BYTE</code>（type字段对应的十进制数字为2）：表示在某个页面偏移量处写了2字节的redo日志类型</li><li><code>MLOG_4BYTE</code>（type字段对应的十进制数字为4）：表示在某个页面偏移量处写了4字节的redo日志类型</li><li><code>MLOG_8BYTE</code>（type字段对应的十进制数字为8）：表示在某个页面偏移量处写了8字节的redo日志类型</li><li><code>MLOG_WRITE_STRING</code>（type字段对应的十进制数字为30）：表示在某个页面偏移量处写入1个 <code>字节序列</code> 的redo日志类型</li></ul><p>对于<code>MLOG_ n BYTE</code>格式的日志，他们的通用日志格式如下：</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240415224554545.png" alt="image-20240415224554545"></p><p>对于``MLOG_WRITE_STRING`类型的日志来说，格式都差不多，只不过具体数据中包含的字节数量不同。格式如下：</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240415225620019.png" alt="image-20240415225620019"></p><p><code>MLOG_WRITE_STRING</code>类型的<code>redolog</code>因为不确定写入的具体数据占用多少字节，所以需要在日志结构中添加一个<code>len</code>字段。</p><h2 id="复杂的日志类型"><a href="#复杂的日志类型" class="headerlink" title="复杂的日志类型"></a>复杂的日志类型</h2><p>对于一个<code>INSERT</code>语句来说，他对B+树的影响如下</p><ol><li>表中有几个索引，一条<code>INSERT</code>语句就有可能更新多少棵<code>B+</code>树</li><li>针对一棵<code>B+</code>树来说，有可能只更新叶子节点，也有可能需要更新内节点页面，还可能新增内节点页面（比如新增后的页面不够了，需要页分类，此时就需要在内节点新增目录记录）</li></ol><p>其实需要更新的东西很多，比如Page Director中的槽信息，Page Header中的各种统计信息，数据会按照索引列的大小排成一个单向链表，所以还需要更新上一条记录的记录头中的指针，也就是<code>next record</code>属性</p><p>针对这种比较复杂的更改，需要记录的东西太多，我们又不能把整个页面记录下来，太浪费了，于是就有了新的<code>redolog</code>日志类型</p><ul><li><p><code>MLOG_REC_INSERT</code>（type字段对应的十进制数字为9）：表示在插入一条使用非紧凑行格式（redundant）的记录时，redo日志的类型</p></li><li><p><code>MLOG_COMP_REC_INSERT</code>（type字段对应的十进制数字为38）：表示在插入一条使用紧凑行格式（compact、dynamic、compressed）的记录时，redo日志的类型</p></li><li><p><code>MLOG_COMP_PAGE_CREATE</code>（type字段对应的十进制数字为58）：表示在创建一个存储紧凑行格式记录的页面时，redo日志的类型</p></li><li><p>……</p></li></ul><p><code>MLOG_COMP_REC_INSERT</code>类型的<code>redolog</code>格式如下：</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240415233226592.png" alt="image-20240415233226592"></p><h2 id="Mini-Transication"><a href="#Mini-Transication" class="headerlink" title="Mini-Transication"></a>Mini-Transication</h2><ul><li>以组的形式写入<code>redolog</code></li></ul><p>比如<code>INSERT</code>语句，再插入时，可能会产生很多条<code>redolog</code>；例如：再插入时，叶子节点空间不足，就需要页分裂，同时向父节点加一个目录项，如果此时父节点的页面空间也不足，就需要再次分裂。如果我们再插入的过程中，只记录了一部分的<code>redolog</code>，此时系统崩溃，待系统重启恢复后，按照<code>redolog</code>的记录去恢复，就会形成一条不正确的 <code>B+</code> 树。</p><p>所以<code>MySql</code>为了保证这个操作的原子性，记录<code>redolog</code>时，都是以组的形式来记录。在进行恢复时，对于一个组内的<code>redolog</code>，要么全部恢复，要么一条都不会恢复。</p><blockquote><p> 如何区分日志属于哪一组呢？</p><p><code>MySql</code>会在每个组的日志结尾处，插入一条特殊类型的<code>redolog</code>，叫做<code>MLOG_MUTIL_REC_END</code>，以这个日志结尾的就属于一组<code>redolog</code></p></blockquote><h2 id="redo-log-block"><a href="#redo-log-block" class="headerlink" title="redo log block"></a>redo log block</h2><p>一个<code>MTR</code>（<code>Mini-Transication</code>）生成的<code>redo</code>日志都放在了大小为512字节的页中，称为<code>block</code>。</p><p><code>redo block</code>的格式示意图：</p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240417000328320.png" alt="image-20240417000328320" style="zoom:80%;"><ul><li><code>LOG_BLOCK_HDR_NO</code>：每一个<code>block</code>都有一个大于0的唯一编号，该属性就表示该编号值</li><li><code>LOG_BLOCK_HDR_DATA_LEN</code>：表示<code>block</code>中已经使用了多少字节；初始值12（因为<code>log block body</code>从第12个字节处开始）。随着往<code>block</code>中写入的<code>redo</code>日志越来越多，该属性也跟着增长。</li><li><code>LOG_BLOCK_FIRST_REC_GROUP</code>：一个<code>redo</code>日志也可以称为一条<code>redo</code>日志记录（<code>redo log record</code>）。一个<code>MTR</code>会生成多条<code>redo</code>日志记录，这个<code>MTR</code>生成的这些<code>redo</code>日志记录被称为一个<code>redo</code>日志记录组（<code>redo log record group</code>）。<code>LOG_BLOCK_FIRST_REC_GROUP</code>就代表该<code>block</code>中第一个<code>MTR</code>生成的<code>redo</code>日志记录组的偏移量，其实也就是这个<code>block</code>中第一个<code>MTR</code>生成的第一条<code>redo</code>日志记录的偏移量。</li><li><code>LOG_BLOCK_CHECKPOINT_NO</code>：表示<code>checkpoint</code>的序列</li><li><code>LOG_BLOCK_CHECKSUM</code>：表示该<code>block</code>的校验值，用于正确性校验。</li></ul><h2 id="log-buffer"><a href="#log-buffer" class="headerlink" title="log buffer"></a>log buffer</h2><p>​    写入<code>redo</code>日志时，其实也是写在<code>redo log buffer</code>日志缓冲区的。</p><p>​    <code>MySql</code>服务器在启动时就向操作系统申请了一大片连续的内存空间，称为<code>redo log buffer</code>日志缓冲区。这片连续的内存空间被划分若干连续的<code>redo log block</code>。</p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240417232524707.png" alt="image-20240417232524707"><p>​    向<code>log buffer</code>中写入undo日志的过程中是顺序写入的，也就是先往前面的<code>block</code>中写，当该<code>block</code>的空闲空间用完之后再往下一个<code>block</code>中写。<code>MySql</code>维护了一个全局变量<code>buf_free</code>，记录偏移量，指明后续写入的<code>redo</code>日志应该写到<code>log buffer</code>中的哪个位置。</p><p>​    一个<code>MTR</code>执行过程中可能产生若干条<code>redo</code>日志，这些<code>redo</code>是一个不可分割的组，所以并不是每生成一条<code>redo</code>日志就该将其插入到<code>log buffer</code>中，而是将每个<code>MTR</code>运行过程中产生的日志暂存到一个地方；当该<code>MTR</code>结束时，再将过程中产生的一组<code>redo</code>日志全部复制到<code>log buffer</code>中。</p><h2 id="redo日志刷盘时机"><a href="#redo日志刷盘时机" class="headerlink" title="redo日志刷盘时机"></a>redo日志刷盘时机</h2><ul><li>log buffer 空间不足时</li></ul><p><code>log buffer</code>的大小是有限的，通过系统变量<code>innodb_log_buffer指定</code>，当写入<code>log buffer</code>的<code>redo</code>日志超过<code>log buffer</code>总容量的50%时，就需要把这些日志刷新到磁盘中</p><ul><li>事务提交时</li></ul><p>为了持久性，也为了保证系统崩溃后，能够恢复事务对页面的更改</p><ul><li>当某个脏页刷新到磁盘前，会保证先将该脏页对应的redo日志刷新磁盘中</li></ul><p>因为redo日志是顺序写入的，所以将某个脏页对应的redo日志从<code>redo log buffer</code>刷新到磁盘时，也会保证在其之前产生的redo日志也刷新到磁盘</p><ul><li>后台线程，定时刷新</li></ul><p>大约以每秒1次的频率将<code>log buffer</code>中的<code>redo</code>日志刷新到磁盘</p><ul><li>正常关闭服务器时</li></ul><h2 id="redo日志文件组"><a href="#redo日志文件组" class="headerlink" title="redo日志文件组"></a>redo日志文件组</h2><p>使用命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;datadir&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以查看redo日志的保存文件位置。</p><p>默认在数据目录下的<code>ib_logfile()</code>和<code>ib_logfile1()</code>两个文件中</p><p>下面是关于<code>redo log</code>的一些参数</p><ul><li><code>innodb_log_group_home_dir</code>：指定了<code>redo</code>日志文件所在的目录，默认就是当前的数据目录</li><li><code>innodb_log_file_size</code>：指定了每个<code>redo</code>日志文件的大小，在<code>MySql5.7</code>版本中的默认值就是48MB</li><li><code>innodb_log_files_in_group</code>：指定了redo日志文件的个数，默认值为2，最大值100</li></ul><p>redo日志是循环写入日志文件的，也就是先写入第一个文件，第一个文件满了，再写入第二个文件，以此类推，当最后一个文件写满了时，再写入第一个文件。</p><p>所以可能会有覆盖的风险。（如何解决：<a href="#checkpoint">checkpoint</a>)</p><h2 id="checkpointredo日志文件格式"><a href="#checkpointredo日志文件格式" class="headerlink" title="checkpointredo日志文件格式"></a>checkpointredo日志文件格式</h2><p><code>log buffer</code>本质上一片连续的内存空间，被划分为若干个<code>512</code>字节大小的<code>block</code>。将<code>log buffer</code>中的<code>redo</code>日志刷新到磁盘的本值就是把<code>block</code>镜像写入日志文件中，所以<code>redo</code>日志文件其实也是由若干个<code>512</code>字节大小的<code>block</code>组成。</p><p>在<code>redo</code><strong>日志文件组</strong>中，每个文件格式大小都一样，都是由下面两部分组成：</p><ul><li>前2048个字节（前4个block）用来存储一些管理信息</li><li>从第2048字节往后的字节用来存储<code>log buffer</code>中<code>block</code>镜像</li></ul><p>前4个<code>block</code>的结构如下：</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240418222559688.png" alt="image-20240418222559688"></p><p><strong>log file header</strong></p><ul><li><code>LOG_HEADER_FORMAT</code>：4字节，redo日志的版本，在<code>MySql5.7</code>中基本都为1</li><li><code>LOG_HEADER_PAD1</code>：4字节，用于字节填充，无实在意义</li><li><code>LOG_HEDAER_START_LSN</code>：8字节，标记本<code>redo</code>日志文件偏移量为2048字节处对应的<code>lsn</code>值</li><li><code>LOG_HEADER_CRETOR</code>：32字节 ，一个字节串，标记本<code>redo</code>日志文件的创建者是谁，正常运行时该值为<code>MySql</code>的版本号；在使用<code>mysqlbackup</code>命令创建<code>redo</code>日志文件时，该值为<code>ibbackup</code>和创建时间</li><li><code>LOG_BLOCK_CHECKSUM</code>：4字节，本<code>block</code>的校验值；所有的<code>block</code>都有该值，</li></ul><p><strong>checkpoint1</strong></p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240418223900310.png" alt="image-20240418223900310"><ul><li><code>LOG_CHECKPOINT_NO</code>：8字节，服务器执行checkpoint编号，每执行一次<code>checkpoint</code>，该值就加1</li><li><code>LOG_CHECKPOINT_LSN</code>：8字节，服务器在结束<code>checkpoint</code>时对应的<code>lsn</code>值；系统崩溃后恢复将从该值开始</li><li><code>LOG_CHECKPOINT_OFFSET</code>：8字节，上个属性中的<code>lsn</code>值在<code>redo</code>日志文件组中的偏移量</li><li><code>LOG_CHECKPOINT_LOG_BUF_SIZE</code>：8字节，服务器在执行<code>checkpoint</code>操作时对应的<code>log buffer</code>的大小</li><li><code>LOG_BLOCK_CHECKSUM</code>：4字节，本<code>block</code>的校验值；所有<code>block</code>都有该值</li></ul><p><code>checkpoint2</code>结构与<code>checkpoint1</code>一样</p><h2 id="log-sequence-number"><a href="#log-sequence-number" class="headerlink" title="log sequence number"></a>log sequence number</h2><p><code>INNODB</code>设计了一个为<code>lsn(log sequence number)</code>的全局变量，用来记录当前总共已经写入的<code>redo</code>日志量。</p><p><code>lsn</code>的值为<code>8704</code>，也就是一条<code>redo</code>日志也没写入时，<code>lsn</code>的值就是<code>8704</code></p><p>向<code>log buffer</code>中不断写入日志，其实是以<code>MTR</code>生成的一组<code>redo</code>日志为单位写入的，而且实际上是把日志写在了<code>log buffe body</code>处。但是在统计<code>lsn</code>的增长值时，是按照实际写入的日志量加上占用的<code>log buffer header</code>和<code>log buffer trailer</code>来计算的。</p><p>如下图：<code>buf_free</code>用来标记下一条redo日志应该写到<code>log buffer</code>中的哪个位置。</p><p><code>MTR1</code>写完以后，对于<code>MTR2</code>，一个页面装不下，跨页了，此时，<code>lsn</code>的偏移量应该加上第一个<code>block</code>的 <code>log block trailer</code>和第二个<code>block</code>的<code>log block header</code>。</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240418233324254.png" alt="image-20240418233324254"></p><blockquote><p>每一组由<code>MTR</code>生成的redo日志都有一个唯一的<code>lsn</code>值与其对应；<code>lsn</code>值越小，说明<code>redo</code>日志产生得越早。</p></blockquote><h2 id="flushed-to-disk-lsn"><a href="#flushed-to-disk-lsn" class="headerlink" title="flushed_to_disk_lsn"></a>flushed_to_disk_lsn</h2><p>全局变量<code>flushed_to_disk_lsn</code>，用来表示刷新到磁盘的redo日志的总量</p><blockquote><p><code>lsn</code>是用来记录redo日志在<code>log buffer</code>中的日志量</p></blockquote><p>在系统第一次启动时，<code>flushed_to_disk_lsn</code>的值与<code>lsn</code>的值是相同的，都是8704。</p><p>随着系统的运行，<code>flushed_to_disk_lsn</code>的值，会逐渐被<code>lsn</code>甩开。因为先写log buffer，再刷新磁盘，毕竟磁盘的刷新没那么快，也没那么及时</p><p>他们的关系如下图：</p><p><code>buf_next_to_write</code>表示下一段将要刷新到磁盘的偏移量</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240419000257852.png" alt="image-20240419000257852"></p><blockquote><p>个人理解：<code>flushed_to_disk_lsn</code>是全局累加的，记录系统总共刷新了多少日志量。</p><p>但是<code>buf_next_to_write</code>是一个指针，用于记录当前刷新到了哪里，随着log buffer清空，这个值也会被复位，指向log buffer开头</p></blockquote><p>如果<code>lsn</code>的值和<code>flushed_to_disk_lsn</code>的值相同，则表示所有的redo日志都刷新到了磁盘。</p><h2 id="flush链表中的lsn"><a href="#flush链表中的lsn" class="headerlink" title="flush链表中的lsn"></a>flush链表中的lsn</h2><blockquote><p>当第一次修改buffer pool中的某页面时，会把该页面对应的控制块加入到flush链表的头部。（之后再次修改时，由于已经存在flush链表中，所以不再插入了）。也就是说，flush链表中的脏页按照页面的第一次修改时间进行排序的，。</p></blockquote><p>在flush链表的控制块中，记录着两个关于页面何时修改的属性。</p><ul><li>oldest_modification：第一次修改<code>buffer pool</code>中某个缓冲页时，就将修改该页面的<code>MTR</code>开始时的<code>lsn</code>值写入这个属性</li><li>newest_modification：每修改一次页面，都会将 修改该页面的<code>MTR</code>结束时对应的<code>lsn</code>值写入这个属性。也就是说，该属性表示页面最近一次需修改后对应的<code>lsn</code>值</li></ul><h2 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h2><p>redo日志文件是有限的，循环写入时，可能新的内容会覆盖旧的内容</p><blockquote><p>redo日志只是为了在系统崩溃后恢复脏页用的，如果对应的脏页已经被刷盘了，那么即使现在系统崩溃后，重启后也没必要使用redo日志恢复该页面了。也就是说该段redo日志就没用的了。</p></blockquote><p>所以判断某个redo日志占用的磁盘空间是否可以被覆盖，就是看对应脏页是否已经被刷新到磁盘</p><p><code>MySql</code>维护一个全部变量<code>checkpoint_lsn</code>，用来表示当前系统中可以被覆盖的redo日志总量是多少。当某个<code>MTR</code>生成的redo日志，被刷新到磁盘中，那么就可以执行一个增加<code>checkpoint_lsn</code>操作，这个操作称为执行一个<code>checkpoint</code></p><p>执行一个<code>checkpoint</code>可以分为两个步骤</p><ol><li>计算当前系统中可以被覆盖的redo日志对应的<code>lsn</code>值最大是多少</li><li>将<code>checkpoint_lsn</code>与对应的<code>redo</code>日志文件组偏移量以及此次<code>checkpoint</code>的编号写到日志文件的管理信息（<code>checkpoint1</code>或者<code>checkpoint2</code>）中</li></ol><p><code>MySql</code>维护了一个<code>checkpoint_no</code>变量，用来统计目前系统执行了多少次<code>checkpoint</code>；每执行一次<code>checkpoint</code>，该变量的值就加1。</p><p>当<code>checkpoint_no</code>的值是偶数时，就写到<code>checkpoint1</code>中，是奇数时，就写到<code>checkpoint2</code>中</p><h2 id="查看系统中的各种lsn值"><a href="#查看系统中的各种lsn值" class="headerlink" title="查看系统中的各种lsn值"></a>查看系统中的各种lsn值</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> innodb engine status;</span><br></pre></td></tr></table></figure><blockquote><p>-–<br>LOG<br>-–<br>Log sequence number 78434369<br>Log flushed up to   78434369<br>Pages flushed up to 78434369<br>Last checkpoint at  78434360<br>0 pending log flushes, 0 pending chkp writes<br>98 log i/o’s done, 0.00 log i/o’s/second<br>-——————— </p></blockquote><ul><li>Log sequence number：表示系统中的<code>lsn</code>值，也就是当前系统已经写入的redo日志量，包括写入到log buffer中的redo日志</li><li>Log flushed up to：表示<code>flused_to_disk_lsn</code>值，也就是当前系统已经写入磁盘的redo日志量</li><li>Pages flushed up to：表示flush链表中最早被修改的那个页面对应的<code>old_nodification</code>属性值</li><li>Last checkpoint at：表示当前系统的<code>checkpoint_lsn</code>值</li></ul><h2 id="innodb-flush-log-at-trx-commit"><a href="#innodb-flush-log-at-trx-commit" class="headerlink" title="innodb_flush_log_at_trx_commit"></a>innodb_flush_log_at_trx_commit</h2><p>该系统变量<code>innodb_flush_log_at_trx_commit</code>的系统变量的值</p><ul><li>0：表示在事务提交时，不立即向磁盘同步redo日志，这个任务交给后台线程来处理。</li><li>1：表示在事务提交时需要将redo日志同步到磁盘。默认值就是1</li><li>2：当该系统变量的值为2时，表示在事务提交时，需要将redo日志写到操作系统的缓冲区中，但并不需要保证将日志真正地刷新磁盘。</li></ul><h1 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h1><blockquote><p>用于事务回滚后的数据恢复</p></blockquote><p>比如：</p><p>对于insert语句，我们把这条记录的主键值记下来，回滚时只需要把这条记录删掉即可</p><p>对于delete语句，我们把这条记录的内容都记下来，回滚时再把这些内容组成的记录插入到表里就好了</p><p>对于update语句，需要把更新前的旧值记下来，回滚时把这些列更新为旧值即可</p><p>select语句并不会修改任何记录，所以也不会产生<code>undolog</code></p><h2 id="事务id"><a href="#事务id" class="headerlink" title="事务id"></a>事务id</h2><ul><li><p>只读事务：<code>START TRANSCATION READ ONLY</code>开启只读事务，在只读事务中，不允许对普通的表进行增删改操作，但是可以对用户临时表进行增删改操作。（这里说的用户临时表是指 <code>create temporary table</code>创建的表，不是语句执行过程中的那个<code>using temporary</code>，那个是系统临时表）</p></li><li><p>读写事务：<code>START TRANSCATION READ WRITE</code>开启读写事务，<code>BEGIN</code>和<code>START TRANSCATION</code>语句开启的也是读写事务。在读写事务中可以对表进行增删改操作。</p></li></ul><p>如果某个事务，在执行过程中，对某个表执行了写操作，也就是增删改，那么<code>InnoDB</code>存储引擎就会给它分配一个第一无二的事务id。</p><ul><li>对于只读事务来说，只有第一次对用户临时表进行增删改时，才会对其分配一个事务id。如果没有更改，则不会分配</li><li>对于读写事务来说，只有它第一次对某个表执行增删改操作时，才会为这个事务分配一个事务id，否则不分配事务id</li></ul><h2 id="日志格式-1"><a href="#日志格式-1" class="headerlink" title="日志格式"></a>日志格式</h2><h2 id="insert操作对应的undo日志"><a href="#insert操作对应的undo日志" class="headerlink" title="insert操作对应的undo日志"></a>insert操作对应的undo日志</h2><blockquote><p>insert语句导致的结果就是插入了一条记录，回滚操作就是把这条记录删除就好了。所以我们只要把这条记录的主键信息记录上就好了</p></blockquote><p><code>MySql</code>类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo</code>日志，其完整结构如下</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420135406839.png" alt="image-20240420135406839"></p><ul><li><code>undo no</code>：在一个事务是从0开始递增的。事务没提交时，每生成一条undo日志，那么该条日志的undo no就加1</li><li><code>table id</code>：每个表都会分配一个唯一的<code>table id</code>，可以通过<code>infomation_schema</code>的<code>innodb_sys_tables</code>表来查看对应的<code>table id</code></li><li>如果记录中主键只包含一列，那么在类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo</code>日志中，只需要把该列占用的存储空间大小和真实值记录下来。如果记录中的逐渐包含多个列，那么每个列占用的存储空间大小和对应的真实值都需要记录下来。（真实值就是指 对应的主键id）</li></ul><blockquote><p>在向表中插入一条记录时，其实聚簇索引和二级索引都需要插入记录。不过在记录undo日志时，只需要根据聚簇索引记录一条undo日志就好了。</p></blockquote><p><strong>by the way</strong>：<code>innodb</code>行格式</p><p>聚簇索引的记录除了会记录完整的用户数据以外，还会记录几个隐藏列：</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420135942889.png" alt="image-20240420135942889"></p><blockquote><p>row_id就是隐藏id，不是必须的</p></blockquote><p>这个<code>roll_pointer</code>，其实本质就是一个指向记录对应的undo日志指针。</p><p>当我们在一次事务中，插入了两条记录后，假如分配的事务id为100，其对应的关系如下图</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420141005150.png" alt="image-20240420141005150"></p><h2 id="delete操作对应的undo日志"><a href="#delete操作对应的undo日志" class="headerlink" title="delete操作对应的undo日志"></a>delete操作对应的undo日志</h2><p>数据页中的数据会根据记录头中的<code>next_record</code>属性组成一个单向链表。</p><p>被删除的记录也会根据记录头中的<code>next_record</code>属性组成一个链表，不过这个链表中的记录占用的存储空间可以被重新利用，所以这个链表也被称为<strong>垃圾链表</strong></p><p>Page Header部分中有一个名为<code>PAGE FREE</code>的属性，它指向垃圾链表的头节点</p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420142227528.png" alt="image-20240420142227528" style="zoom:80%;"><p>数据行中的记录头信息中，有一个<code>delete_flag</code>标识，用来标记数据是否被删除。</p><p>假如现在数据状态如下：</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420143626870.png" alt="image-20240420143626870"></p><p>我们要把正常记录的最后一条记录删掉，这个删除过程需要经历两个过程</p><ul><li><p>阶段1：仅仅将该记录的<code>delete_flag</code>标识位设置为1。这个过程称为<strong>delete mark</strong></p><blockquote><p>其实也会修改<code>trx_id</code>、<code>roll_pointer</code>这些隐藏列的值</p></blockquote></li></ul><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420144120007.png" alt="image-20240420144120007"></p><ul><li><p>阶段2：当该删除语句提交事务后，会有专门的线程来真正地把记录删除掉（也就是将记录移到垃圾链表）。这个过程阶段称为<strong>purge</strong></p><blockquote><p>被删除的记录，以头插法加到垃圾链表的头节点</p></blockquote></li></ul><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420144551844.png" alt="image-20240420144551844"></p><p>在阶段2执行完成之后，这条记录就算是被真正删除了，占用的存储空间也就可以被重新利用了。</p><p>事务一旦提交，也就不需要考虑回滚的事了，所以只需要针对第一阶段<code>delete mark</code>进行回滚就好了</p><p><code>MySql</code>设计了一种名为<code>TRX_UNDO_DEL_MARK_REC</code>类型的undo日志</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420150428571.png" alt="image-20240420150428571"></p><ul><li><p>在对一条记录进行delete mark操作之前，需要把该记录的<code>trx_id</code>和<code>roll_pointer</code>隐藏列的旧值都记录到对应的undo日志中的 <code>trx_id</code> 和 <code>roll_pointer</code>属性中。</p><blockquote><p>这样可以通过undo日志的<code>roll pointer</code>属性找到上一次对该记录进行改动时产生的<code>undo</code>日志</p><p>比如：现在有两个事务，一个对其更新，一个对其删除，更新在前，删除在后，删除后如果要回滚，应该回滚到更新后的状态，这个东西其实就是版本链</p></blockquote></li><li><p>索引各列信息：如果某个列，加到了索引列中，就会把索引的相关信息记录到这里。</p><blockquote><p>&lt;pos，len,  value&gt;：pos表示该列在记录中的位置，len该列占用的存储空间大小，value表示该列实际值</p></blockquote></li></ul><h2 id="update操作对应的undo日志"><a href="#update操作对应的undo日志" class="headerlink" title="update操作对应的undo日志"></a>update操作对应的undo日志</h2><ul><li><p>不更新主键</p><ul><li>就地更新（in-place update)<ul><li>在更新时，对于被更新的列来说，如果更新前后 占用的存储空间一样大，那么就可以直接在原记录的基础上修改对应列的值（必须一样大，更新后存储空间变大或变小，都不能就地更新）</li></ul></li><li>先删除旧记录，再插入新记录<ul><li>如果更新前后占用的存储空间大小不一致，就需要先把这条旧记录删除，再根据更新后的值插入一条新记录</li><li>这里说的删除不是delete mark，而是真正的删除，也就是加入到垃圾链表。这里执行删除操作的也并不是delete语句中进行purge操作时使用的后台线程，而是用户线程执行的同步删除</li><li>如果新创建的记录占用的存储空间不超过旧记录占用的存储空间，那么可以直接重用旧记录的存储空间；否则需要在页面中新申请一块记录供新记录使用</li></ul></li></ul><p>针对这种不更新主键的情况（包括上面两种情况），<code>MySql</code>设计了一种类型为<code>TRX_UNDO_UPD_EXIST_REC</code>类型的undo日志</p></li></ul><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420154213392.png" alt="image-20240420154213392"></p><blockquote><p>如果update语句中更新的列包含了索引列，那么就会添加”索引列各列信息”这个部分，否则不会添加这个部分</p></blockquote><ul><li><p>更新主键</p><ul><li>在聚簇索引中，记录按照主键值的大小连成一个单向链表。如果更新了主键，那么这个主键在聚簇索引中的位置将要发生变化。</li></ul><p>对于这种更新主键的update语句，分两步进行处理</p></li></ul><ol><li>将旧记录执行<code>delete mark</code>操作</li><li>根据更新后各列的值，创建一条新记录，插入到聚簇索引中</li></ol><p>如果被更新的列包含了二级索引列。就需要更新二级索引的数据</p><ol><li>将旧记录执行<code>delete mark</code>操作</li><li>根据更新后各列的值，创建一条新的二级索引记录，插入到二级索引中</li></ol><h2 id="FIL-PAGE-UNDO-LOG"><a href="#FIL-PAGE-UNDO-LOG" class="headerlink" title="FIL_PAGE_UNDO_LOG"></a>FIL_PAGE_UNDO_LOG</h2><p>undo日志存放在类型为 <code>FIL_PAGE_UNDO_LOG</code>的页面中。这种页面的通用结构如下：</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420215420389.png" alt="image-20240420215420389"></p><h3 id="Undo-Page-Header"><a href="#Undo-Page-Header" class="headerlink" title="Undo Page Header"></a>Undo Page Header</h3><p>Undo Page Header是undo日志独有的，结构如下</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420215801433.png" alt="image-20240420215801433"></p><ul><li><p><code>TRX_UNDO_PAGE_TYPE</code>：本页面存放的undo日志类型</p><p>undo日志主要分为两个大类</p><ul><li><code>TRX_UNDO_INSERT</code>：一般由insert语句产生，更新语句更新主键时也会产生此类型的undo日志，<code>TRX_UNDO_INSERT_REC</code>的undo日志就属于这个大类。（这种类型的日志，在事务提交之后，可以直接删掉。下面这个类型的还需要为<code>MVVC</code>服务）</li><li><code>TRX_UNDO_UPDATE</code>：除了类型为<code>TRX_UNDO_INSERT_REC</code>的undo日志，其他类型的undo日志都属于这个大类。一般由DELETE、UPDATE语句产生的undo日志都属于这个大类。</li></ul><p><code>TRX_UNDO_PAGE_TYPE</code>属性的可选值就是上面两个，用来标记本页面用于存储哪个大类的undo日志。不同大类的undo日志不能混着存储。</p></li></ul><ul><li><code>TRX_UNDO_PAGE_START</code>：第一条undo日志在本页面中的起始偏移量。</li><li><code>TRX_UNDO_PAGE_FREE</code>：与上面的<code>TRX_UNDO_PAGE_START</code>对应，表示当前页面中存储的最后一条undo日志结束时的偏移量。</li><li><code>TRX_UNDO_PAGE_NODE</code>：代表一个链表节点结构。</li></ul><h2 id="undo页面链表"><a href="#undo页面链表" class="headerlink" title="undo页面链表"></a>undo页面链表</h2><p>一个事务可能包含多个语句，一个语句也可能对多个聚簇索引的记录进行改动。在对每条聚簇索引记录改动前，都需要记录1条或2条undo日志。</p><p>一个事务执行过程中可能产生很多undo日志。这些日志可能一个页面放不下，需要放到多个页面中，这些页面通过<code>TRX_UNDO_PAGE_NODE</code>属性连成一个链表 </p><p>一个事务执行过程中，可能会混合执行多种类型的语句，产生不同类型的undo日志。但是一个undo页面只能存储一个类型的undo日志。</p><p>所以一个事务的执行过程中，可能需要两个undo页面的链表。一条<code>insert undo</code>链表，另一条称为<code>unpdate undo</code>链表。</p><p>在对普通表和用户临时表的记录改动时所产生的undo日志要分别记录。所以一个事务最多有4个以undo页面为节点组成的链表。</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420230059192.png" alt="image-20240420230059192"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;binlog&quot;&gt;&lt;a href=&quot;#binlog&quot; class=&quot;headerlink&quot; title=&quot;binlog&quot;&gt;&lt;/a&gt;binlog&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;二进制日志，记录了数据库发生的变化。如新建了一个数据库或者表、表结构发生改变、表中</summary>
      
    
    
    
    <category term="MySql" scheme="https://c89757.github.io/categories/MySql/"/>
    
    
    <category term="MySql" scheme="https://c89757.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB-BufferPool</title>
    <link href="https://c89757.github.io/2024/04/14/MySql-BufferPool/"/>
    <id>https://c89757.github.io/2024/04/14/MySql-BufferPool/</id>
    <published>2024-04-14T06:55:16.000Z</published>
    <updated>2024-04-14T09:50:58.500Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>其实就是一片连续的内存缓冲区，用于缓解CPU和磁盘的速度矛盾。</p><p>数据从磁盘加载出来后，会放到<code>BufferPool</code>中缓存起来，下次需要读取相同的页面时，直接从内存中获取即可。</p></blockquote><h1 id="BufferPoll的组成"><a href="#BufferPoll的组成" class="headerlink" title="BufferPoll的组成"></a>BufferPoll的组成</h1><p><code>BufferPool</code>会将一片连续的内存划分为若干个页面，页面大小与<code>InnoDB</code>表空间大小一致，也就是默认<code>16KB</code>，</p><p>每一个缓冲页对应一个控制块，记录了页面的一些元数据，比如该页面所属的表空间号，页号，缓冲页的物理地址等。</p><p>控制块也在<code>BufferPool</code>的内存中，放在缓冲页的前面，如下图</p><br><img src="/2024/04/14/MySql-BufferPool/1.png" class><br><h2 id="Free链表"><a href="#Free链表" class="headerlink" title="Free链表"></a>Free链表</h2><blockquote><p>为了知道哪一个缓冲页是空闲可用的。</p></blockquote><p><code>MySql</code>会将所有空闲的缓冲页的对应的<strong>控制块 作为一个节点</strong>放到链表中串起来，这个链表就是<code>free链表</code>（或空闲链表）.</p><p>在<code>MySql</code>服务刚刚启动时，会向操作系统申请一片连续的内存空间用于<code>BufferPoll</code>，将他划分为控制块和缓冲页，此时所有的缓冲页都是空闲可用的，即所有缓冲页（的控制块）都处于<code>free链表</code>中。当有数据需要加载进<code>BufferPoll</code>中时，从free链表中获取一个空闲的缓冲页，并将数据所对应的表空间、页号等信息填入缓冲页的控制块中，最后将该缓冲页对应的控制块从<code>free链表</code>中移除。</p><h2 id="如何知道数据页是否在缓冲页中"><a href="#如何知道数据页是否在缓冲页中" class="headerlink" title="如何知道数据页是否在缓冲页中?"></a>如何知道数据页是否在缓冲页中?</h2><p>在访问某个页的数据时，如果数据页已经被加载进<code>BufferPool</code>了，就不会再从磁盘读取数据，那么如何知道数据页已经被加载了呢？</p><p>加载磁盘数据时，其实是通过表空间号 + 页号来定位一个唯一页面的。</p><p><code>MySql</code>会维护一个<code>hash</code>表，<code>hash</code>表的key就是 表空间号 + 页号，value就是缓冲页控制块的地址。</p><p>当需要访问某个页面时，根据key从hash表中查找，如果value不为空，则直接访问内存中的数据；</p><p>如果value为空，则从磁盘加载页数据后，从free链表中获取一个缓冲页，将其缓存起来。</p><h2 id="Flush链表"><a href="#Flush链表" class="headerlink" title="Flush链表"></a>Flush链表</h2><blockquote><p>解决缓存一致性的问题</p></blockquote><br><p>当某个要修改某行数据时，如果该页的数据已经被加载进<code>BufferPoll</code>了，那<code>MySql</code>只会先修改<code>buffer pool</code>中的数据，不会立马更新磁盘，那么该修改过的缓冲页就被称为<strong>脏页（Dirty Page）</strong>。</p><br><blockquote><p>如果要修改二级索引数据，并且二级索引数据页不在buffer pool中，<code>MySql</code>会将其修改保存到change buffer中，待下次查询出来时，将其结果合并。change buffer属于buffer pool中的一小部分，change buffer只支持二级索引！</p></blockquote><br><p><code>Mysql</code>会维护一个<code>flush链表</code>，来管理这些脏页，由后台线程定期将脏页中的数据刷到磁盘</p><p>跟free链表结构差不多，flush链表也会将 脏页对应的控制块作为节点</p><h1 id="LRU链表"><a href="#LRU链表" class="headerlink" title="LRU链表"></a>LRU链表</h1><blockquote><p>缓冲页的淘汰策略</p></blockquote><p>buffer pool的内存大小有限，总会有用完的一天，如果缓冲页全部被用完了怎么办呢？</p><p><code>MySql</code>基于变种的<code>LRU</code>算法。将已经使用了的缓冲页对应的控制块串起来，用特定算法去淘汰掉最近最少使用的缓冲页。</p><blockquote><p>free链表中的控制块一定不在<code>LRU</code>链表中，但是flush链表中的控制块一定在<code>LRU链表</code>中。</p></blockquote><br><ul><li><code>InnoDB</code>的<strong>预读</strong></li></ul><p>有点空间局部性和时间局部性的味道</p><p>线性预读：当顺序访问某个区的页面超过了<code>innodb_read_ahead_threshold</code>的值，就会触发异步读取下一个区中的全部页面到<code>Buffer Pool</code>中</p><p>随机预读：如果某个区的13个连续的页面都已经被加载到了<code>Buffer Pool</code>中，就会触发一次异步读取本区的其他所有页面到<code>Buffer Pool</code>中。随机预读默认关闭，需要通过<code>innodb_random_read_ahead</code>开启。</p><br><p>预读可能导致 许多无用页面被加载到<code>Buffer Pool</code>中，影响到缓冲页的淘汰</p><p><code>MySql</code>将<code>LRU链表</code>按照一定比例划分为两个区域</p><p>young区域：存储使用频率较高的缓冲页，这部分链表也称为热数据</p><p>old区域：存储使用频率不是很高的缓冲页，这部分链表也称为冷数据</p><ul><li><p>当磁盘上的某个数据页在初次加载到<code>Buffer Pool</code>中时，该缓冲区对应的磁盘块会放到old区域的头部。如果该页面不进行后续访问，会逐渐从old区逐出，而不会影响到young区域中使用较频繁的缓存页。</p></li><li><p>对于全表扫描来说，短时间内访问大量使用频率非常低的页面（一个页面很有很数据，每次获取数据都相当于访问一次页面）。如果访问old区某个缓冲页的时间点，相较于上次访问的时间间隔 小于<code>innodb_old_blocks_time</code>的值，则不会将该old区的数据移动到young区。</p></li><li><p>只有访问的缓冲页位于young区域的1/4的后面时，才会被移动到<code>LRU链表</code>头部。这样可以降低调整链表的频率，提高性能</p></li></ul><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-change-buffer.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-change-buffer.html</a></p><h1 id="innodb-buffer-pool-instances"><a href="#innodb-buffer-pool-instances" class="headerlink" title="innodb_buffer_pool_instances"></a>innodb_buffer_pool_instances</h1><p>在多线程环境下，访问Buffer Pool的各种链表都需要加锁，锁粒度较大，影响效率。于是可以将一个大的<code>Buffer Pool</code>拆成若干个小的<code>Buffer Pool</code>，每个<code>Buffer Pool</code>都是称为一个实例，他们是相互独立的——独立申请内存，独立管理各种链表。</p><p>可以通过修改系统参数 <code>innodb_buffer_pool_instances</code>的值来修改<code>Buffer Pool</code>实例的个数</p><h1 id="innodb-buffer-pool-chunk-size"><a href="#innodb-buffer-pool-chunk-size" class="headerlink" title="innodb_buffer_pool_chunk_size"></a>innodb_buffer_pool_chunk_size</h1><p><code>MySql</code>在申请<code>buffer pool</code>的内存时，是以一个chunk为单位向操作系统申请空间的，一个chunk就代表一片连续的内存空间。</p><p>一个<code>Buffer Pool</code>实例其实就是由若干个chunk组成的</p><p>我们可以通过修改参数<code>innodb_buffer_pool_chunk_size</code>来调整chunk的大小</p><p>tips</p><blockquote><p><code>innodb_buffer_pool_size</code>的值 必须是 <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code>的倍数（主要为了保证每个Buffer Pool实例中的chunk数量相同</p></blockquote><h1 id="查看Buffer-Pool信息"><a href="#查看Buffer-Pool信息" class="headerlink" title="查看Buffer Pool信息"></a>查看Buffer Pool信息</h1><p>可以通过语句<code>show innodb engine status</code>来查看<code>innodb</code>存储引擎运行过程中的一些状态信息，其中就有Buffer Pool的信息（也可以查看死锁等信息）</p><p>下面是部分信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----------------------</span></span><br><span class="line">BUFFER POOL <span class="keyword">AND</span> MEMORY</span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line">Total <span class="keyword">large</span> memory allocated <span class="number">8585216</span></span><br><span class="line">Dictionary memory allocated <span class="number">229735</span></span><br><span class="line">Buffer pool size   <span class="number">512</span></span><br><span class="line"><span class="keyword">Free</span> buffers       <span class="number">254</span></span><br><span class="line">Database pages     <span class="number">256</span></span><br><span class="line"><span class="keyword">Old</span> database pages <span class="number">0</span></span><br><span class="line">Modified db pages  <span class="number">0</span></span><br><span class="line">Pending <span class="keyword">reads</span>      <span class="number">0</span></span><br><span class="line">Pending writes: LRU <span class="number">0</span>, flush list <span class="number">0</span>, single page <span class="number">0</span></span><br><span class="line">Pages made young <span class="number">0</span>, <span class="keyword">not</span> young <span class="number">0</span></span><br><span class="line"><span class="number">0.00</span> youngs<span class="operator">/</span>s, <span class="number">0.00</span> non<span class="operator">-</span>youngs<span class="operator">/</span>s</span><br><span class="line">Pages read <span class="number">480</span>, created <span class="number">57</span>, written <span class="number">128</span></span><br><span class="line"><span class="number">0.00</span> <span class="keyword">reads</span><span class="operator">/</span>s, <span class="number">0.00</span> creates<span class="operator">/</span>s, <span class="number">0.76</span> writes<span class="operator">/</span>s</span><br><span class="line">Buffer pool hit rate <span class="number">1000</span> <span class="operator">/</span> <span class="number">1000</span>, young<span class="operator">-</span>making rate <span class="number">0</span> <span class="operator">/</span> <span class="number">1000</span> <span class="keyword">not</span> <span class="number">0</span> <span class="operator">/</span> <span class="number">1000</span></span><br><span class="line">Pages read ahead <span class="number">0.00</span><span class="operator">/</span>s, evicted <span class="keyword">without</span> access <span class="number">0.00</span><span class="operator">/</span>s, Random read ahead <span class="number">0.00</span><span class="operator">/</span>s</span><br><span class="line">LRU len: <span class="number">256</span>, unzip_LRU len: <span class="number">0</span></span><br><span class="line">I<span class="operator">/</span>O sum[<span class="number">34</span>]:cur[<span class="number">0</span>], unzip sum[<span class="number">0</span>]:cur[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li><p><code>Total memory allocated</code>：代表<code>Buffer Pool</code>向操作系统申请的连续内存空间大小，包括全部控制块、缓存页、以及碎片的大小。</p></li><li><p><code>Dictionary memory allocated</code>：为数据字典信息分配的内存空间大小，注意这个内存空间和<code>Buffer Pool</code>没啥关系，不包括在<code>Total memory allocated</code>中。</p></li><li><p><code>Buffer pool size</code>：代表该<code>Buffer Pool</code>可以容纳多少缓存<code>页</code>，注意，单位是<code>页</code>！</p></li><li><p><code>Free buffers</code>：代表当前<code>Buffer Pool</code>还有多少空闲缓存页，也就是<code>free链表</code>中还有多少个节点。</p></li><li><p><code>Database pages</code>：代表<code>LRU</code>链表中的页的数量，包含<code>young</code>和<code>old</code>两个区域的节点数量。</p></li><li><p><code>Old database pages</code>：代表<code>LRU</code>链表<code>old</code>区域的节点数量。</p></li><li><p><code>Modified db pages</code>：代表脏页数量，也就是<code>flush链表</code>中节点的数量。</p></li><li><p><code>Pending reads</code>：正在等待从磁盘上加载到<code>Buffer Pool</code>中的页面数量。</p><p>当准备从磁盘中加载某个页面时，会先为这个页面在<code>Buffer Pool</code>中分配一个缓存页以及它对应的控制块，然后把这个控制块添加到<code>LRU</code>的<code>old</code>区域的头部，但是这个时候真正的磁盘页并没有被加载进来，<code>Pending reads</code>的值会跟着加1。</p></li><li><p><code>Pending writes LRU</code>：即将从<code>LRU</code>链表中刷新到磁盘中的页面数量。</p></li><li><p><code>Pending writes flush list</code>：即将从<code>flush</code>链表中刷新到磁盘中的页面数量。</p></li><li><p><code>Pending writes single page</code>：即将以单个页面的形式刷新到磁盘中的页面数量。</p></li><li><p><code>Pages made young</code>：代表<code>LRU</code>链表中曾经从<code>old</code>区域移动到<code>young</code>区域头部的节点数量。</p><p>这里需要注意，一个节点每次只有从<code>old</code>区域移动到<code>young</code>区域头部时才会将<code>Pages made young</code>的值加1，也就是说如果该节点本来就在<code>young</code>区域，由于它符合在<code>young</code>区域1/4后边的要求，下一次访问这个页面时也会将它移动到<code>young</code>区域头部，但这个过程并不会导致<code>Pages made young</code>的值加1。</p></li><li><p><code>Page made not young</code>：在将<code>innodb_old_blocks_time</code>设置的值大于0时，首次访问或者后续访问某个处在<code>old</code>区域的节点时由于不符合时间间隔的限制而不能将其移动到<code>young</code>区域头部时，<code>Page made not young</code>的值会加1。</p><p>这里需要注意，对于处在<code>young</code>区域的节点，如果由于它在<code>young</code>区域的1/4处而导致它没有被移动到<code>young</code>区域头部，这样的访问并不会将<code>Page made not young</code>的值加1。</p></li><li><p><code>youngs/s</code>：代表每秒从<code>old</code>区域被移动到<code>young</code>区域头部的节点数量。</p></li><li><p><code>non-youngs/s</code>：代表每秒由于不满足时间限制而不能从<code>old</code>区域移动到<code>young</code>区域头部的节点数量。</p></li><li><p><code>Pages read</code>、<code>created</code>、<code>written</code>：代表读取，创建，写入了多少页。后边跟着读取、创建、写入的速率。</p></li><li><p><code>Buffer pool hit rate</code>：表示在过去某段时间，平均访问1000次页面，有多少次该页面已经被缓存到<code>Buffer Pool</code>了。</p></li><li><p><code>young-making rate</code>：表示在过去某段时间，平均访问1000次页面，有多少次访问使页面移动到<code>young</code>区域的头部了。</p><p>需要大家注意的一点是，这里统计的将页面移动到<code>young</code>区域的头部次数不仅仅包含从<code>old</code>区域移动到<code>young</code>区域头部的次数，还包括从<code>young</code>区域移动到<code>young</code>区域头部的次数（访问某个<code>young</code>区域的节点，只要该节点在<code>young</code>区域的1/4处往后，就会把它移动到<code>young</code>区域的头部）。</p></li><li><p><code>not (young-making rate)</code>：表示在过去某段时间，平均访问1000次页面，有多少次访问没有使页面移动到<code>young</code>区域的头部。</p><p>需要大家注意的一点是，这里统计的没有将页面移动到<code>young</code>区域的头部次数不仅仅包含因为设置了<code>innodb_old_blocks_time</code>系统变量而导致访问了<code>old</code>区域中的节点但没把它们移动到<code>young</code>区域的次数，还包含因为该节点在<code>young</code>区域的前1/4处而没有被移动到<code>young</code>区域头部的次数。</p></li><li><p><code>LRU len</code>：代表<code>LRU链表</code>中节点的数量。</p></li><li><p><code>unzip_LRU</code>：代表<code>unzip_LRU链表</code>中节点的数量（由于我们没有具体唠叨过这个链表，现在可以忽略它的值）。</p></li><li><p><code>I/O sum</code>：最近50s读取磁盘页的总数。</p></li><li><p><code>I/O cur</code>：现在正在读取的磁盘页数量。</p></li><li><p><code>I/O unzip sum</code>：最近50s解压的页面数量。</p></li><li><p><code>I/O unzip cur</code>：正在解压的页面数量。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;其实就是一片连续的内存缓冲区，用于缓解CPU和磁盘的速度矛盾。&lt;/p&gt;
&lt;p&gt;数据从磁盘加载出来后，会放到&lt;code&gt;BufferPool&lt;/code&gt;中缓存起来，下次需要读取相同的页面时，直接从内存中获取即可。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="MySql" scheme="https://c89757.github.io/categories/MySql/"/>
    
    
    <category term="MySql" scheme="https://c89757.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>程序OOM时soft-reference没有被回收?</title>
    <link href="https://c89757.github.io/2024/03/30/%E7%A8%8B%E5%BA%8FOOM%E6%97%B6soft-reference%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%9B%9E%E6%94%B6/"/>
    <id>https://c89757.github.io/2024/03/30/%E7%A8%8B%E5%BA%8FOOM%E6%97%B6soft-reference%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%9B%9E%E6%94%B6/</id>
    <published>2024-03-30T14:57:37.000Z</published>
    <updated>2024-03-30T16:36:21.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在编写一块缓存代码时，想到了软引用，但是不太清楚软引用究竟在什么时候会被回收，于是就写了一块测试代码</p><blockquote><p>JDK1.8 </p><p>-Xms60m -Xmx60m</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SoftReference&lt;<span class="keyword">byte</span>[]&gt; cache = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            func();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">            sniff();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        cache = <span class="keyword">new</span> SoftReference&lt;&gt;(bytes);</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] tmp = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">            list.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sniff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cache.get();</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;recycling data.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;object still live&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过不断往<code>list</code>填充 大小为<code>1M</code>的字节数组，为了让程序发生<code>OOM</code>，并且在捕获<code>OutOfMemoryError</code>时，来观测软引用的对象是否被回收了</p><p>（<code>cache.get() == null</code>就说明软引用关联的对象，在即将OOM时，被GC回收了）</p><p>但是程序运行结果如下：</p><blockquote><p>object still live</p></blockquote><p>说明在发生OOM时，GC并没有去回收这个软引用对象</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>什么叫软可达对象<em>softly reachable</em> </p><p>官网给出的原文如下：</p><blockquote><p>An object is <em>softly reachable</em> if it is not strongly reachable but can be reached by traversing a soft reference.</p></blockquote><p><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ref/package-summary.html#reachability">oracle官方文档链接</a></p><p>很重要的一点，<code>not strongly reachable</code>，不被强引用关联!</p><p>上述例子中，就是因为 <code>new byte[1024 * 1024]</code> 除了被软引用关联外，还被变量<code>bytes</code>的强引用关联，所以，即使到最后发生了<code>OOM</code>，<code>Garbage Collector</code>也不会去回收它。</p><p>将代码改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cache = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] tmp = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">            list.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不再使用变量去关联<code>new byte[1024 * 1024]</code>, 而是直接将他添加到引用对象中</p><p>程序运行结果：</p><blockquote><p>recycling data</p></blockquote><p>软引用对象被正常回收</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>在上述例子中，如果将代码改为如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static SoftReference&lt;byte[]&gt; cache = new SoftReference&lt;&gt;(new byte[0]);</span><br><span class="line"></span><br><span class="line">    public static List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            func();</span><br><span class="line">        &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">            sniff();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void func() &#123;</span><br><span class="line">        for(;;) &#123;</span><br><span class="line">            byte[] tmp = new byte[1024 * 1024];</span><br><span class="line">            list.add(tmp);</span><br><span class="line">            byte[] bytes = new byte[1024 * 1024];</span><br><span class="line">            cache = new SoftReference&lt;&gt;(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void sniff() &#123;</span><br><span class="line">        byte[] bytes = cache.get();</span><br><span class="line">        if (bytes == null) &#123;</span><br><span class="line">            System.out.println(&quot;recycling data.&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;object still live&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是将</p><p><code>byte[] bytes = new byte[1024 * 1024]; cache = new SoftReference&lt;&gt;(bytes);</code></p><p>这两行代码放入for循环里面，<code>list.add(tmp)</code>后面</p><p>程序运行结果：</p><blockquote><p>recycling data.</p></blockquote><p>又懵了呀！</p><p>按照我们上述的分析来说，这里也有一个强引用<code>bytes</code>关联这个数组，为什么发生<code>OOM</code>时软引用还能被回收呢？</p><br><p>因为这个例子有点特殊，事先说明一点，程序是运行到这一行发生的<code>OOM</code><br><code>byte[] bytes = new byte[1024 * 1024];</code></p><br><p>可以将代码加上几个打印点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] tmp = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        list.add(tmp);</span><br><span class="line">        System.out.println(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">        cache = <span class="keyword">new</span> SoftReference&lt;&gt;(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序是在输出<code>add</code>之后发生的<code>OOM</code>，但是并没有输出<code>after</code></p><p>值得注意的是，在循环中，<code>bytes</code>所指向的对象一直在变化。</p><p>如图：在执行完某一次循环的最后一行代码后，对象的指针如下</p><br><img src="/2024/03/30/%E7%A8%8B%E5%BA%8FOOM%E6%97%B6soft-reference%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%9B%9E%E6%94%B6/image-20240331000639577.png" class><br><p>紧接着继续循环，代码执行到<code>byte[] bytes = new byte[1024 * 1024];</code>时，对象的关系如下</p><br><img src="/2024/03/30/%E7%A8%8B%E5%BA%8FOOM%E6%97%B6soft-reference%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%9B%9E%E6%94%B6/image-20240331001043783.png" class><br><p>此时，软引用所指向的对象 并没有强引用的关联关系，如果此时发生内存紧张，那么软引用所引用的对象就会被回收。</p><blockquote><p>顺便一提，如果将那两行代码放在循环体的开始，程序运行结果又会不一样，究其原因还是当即将发生<code>OOM</code>时，软引用变量所持有的对象究竟有没有被强引用所关联。</p><p>在上述例子中，bytes变量所持有的对象的生命周期只在一个循环中，下次循环会被覆盖，原先的引用关系被断开。而<code>list.add(tmp)</code>，<code>tmp</code>所指向的对象一直被添加到static申明的变量中，生命周期也就和static变量一样</p></blockquote><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>感谢<code>stackOverFlow</code>上的这位老哥的答疑</p><p>原帖链接如下：（请忽略作者的垃圾英语水平）</p><p><a href="https://stackoverflow.com/questions/78247787/java-softreference-soft-references-were-not-collected-before-the-occurrence-of">https://stackoverflow.com/questions/78247787/java-softreference-soft-references-were-not-collected-before-the-occurrence-of</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近在编写一块缓存代码时，想到了软引用，但是不太清楚软引用究竟在什么时候会被回收，于是就写了一块测试代码&lt;/p&gt;
&lt;blockquote&gt;
</summary>
      
    
    
    
    <category term="java" scheme="https://c89757.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://c89757.github.io/tags/java/"/>
    
    <category term="GC" scheme="https://c89757.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>记-升级mariadb-java-client引发的问题</title>
    <link href="https://c89757.github.io/2024/03/11/%E8%AE%B0-%E5%8D%87%E7%BA%A7mariadb-java-client%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://c89757.github.io/2024/03/11/%E8%AE%B0-%E5%8D%87%E7%BA%A7mariadb-java-client%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2024-03-11T11:05:10.000Z</published>
    <updated>2024-03-11T11:39:04.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目中使用<code>flywaydb</code>作为数据库迁移工具</p><p>但是在执行一段<code>DDL</code>语句时，引发了报错</p><p>语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name MODIFY <span class="keyword">COLUMN</span> column_name data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>该字段之前默认<code>NULL</code>，现将其改为<code>NOT NULL</code></p><p>执行却报错：<code>Invalid use of null value;</code></p><h1 id="排错"><a href="#排错" class="headerlink" title="排错"></a>排错</h1><p>网上查了下，因为表中已经存在了<code>NULL</code>值，所以不允许将其修改为<code>NOT NULL</code>。</p><p>但是，将这段脚本直接放到<code>navicat</code>中却能执行成功。</p><p>到此开始怀疑是项目升级<code>mariadb-java-client</code>至<code>2.7.10</code>导致的。且这种语句执行结果的差异化，大多和<code>sql_mode</code>有关。</p><ol><li>查询<code>mysql</code>官网</li></ol><p><a href="https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html">https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html</a></p><p>没有明确找到针对词条语句有做差异化的<code>sql_mode</code>，推测是与严格模式有关——<code>STRICT_TRANS_TABLES</code>;</p><ol start="2"><li>在<code>navicat</code>中，查看<code>sql_mode</code></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@GLOBAL</span>.sql_mode;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@SESSION</span>.sql_mode;</span><br></pre></td></tr></table></figure><p>结果都为空</p><ol start="3"><li>设置session级别的<code>sql_mode</code></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION sql_mode <span class="operator">=</span> sys.list_add(@<span class="variable">@session</span>.sql_mode, <span class="string">&#x27;STRICT_TRANS_TABLES&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>设置完后，再次执行脚本，问题复现<code>Invalid use of null value</code>;</li></ol><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol><li>可以在<code>DDL</code>之前，通过<code>update</code>语句，将全部的NULL值修改为不为NULL</li></ol><ol start="2"><li>在执行<code>DDL</code>之前，判断是否开启了<code>STRICT_TRANS_TABLES</code>, 如果有开启，可以先将其移除，<code>DDL</code>执行之后再将其加回来</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION sql_mode <span class="operator">=</span> sys.list_drop(@<span class="variable">@session</span>.sql_mode, <span class="string">&#x27;STRICT_TRANS_TABLES&#x27;</span>);</span><br><span class="line">&#123;&#123;DDL&#125;&#125;;</span><br><span class="line"><span class="keyword">SET</span> SESSION sql_mode <span class="operator">=</span> sys.list_add(@<span class="variable">@session</span>.sql_mode, <span class="string">&#x27;STRICT_TRANS_TABLES&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>修改项目中数据库的<code>URL</code>连接串，添加参数<code>jdbcCompliantTruncation=false</code></li></ol><p>这个是通过源码发现的，当这个值为<code>true</code>时（默认为true)，<code>mariadb</code>连接<code>mysql</code>时，会添加上session级别的<code>STRICT_TRANS_TABLES</code>, 所以将他关掉即可。另外，开启这个值后，还影响一些其他功能，如：插入时，字段超长，将不会报错，而是截取</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;项目中使用&lt;code&gt;flywaydb&lt;/code&gt;作为数据库迁移工具&lt;/p&gt;
&lt;p&gt;但是在执行一段&lt;code&gt;DDL&lt;/code&gt;语句时，</summary>
      
    
    
    
    <category term="mysql" scheme="https://c89757.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="https://c89757.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql事务隔离级别与MVVC</title>
    <link href="https://c89757.github.io/2023/09/26/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVVC/"/>
    <id>https://c89757.github.io/2023/09/26/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVVC/</id>
    <published>2023-09-26T15:20:25.000Z</published>
    <updated>2024-04-20T17:46:01.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h1><p>事务并发执行时会遇到的一致性问题</p><ul><li>脏写</li></ul><p>一个事务修改了另一个未提交事务修改过的数据</p><ul><li>脏读</li></ul><p>一个事务读到了另一个未提交事务修改过的数据</p><blockquote><p>事务T1修改了数据项X的值，然后事务T2又读取了未提交事务T1针对数据项X修改后的值，之后T1中止，而T2提交，这就意味着T2读到了一个根本不存在的值。</p></blockquote><ul><li>不可重复读</li></ul><p>一个事务修改了另一个未提交事务读取的数据</p><blockquote><p>事务T1先读取了数据项X的值，然后T2又修改了未提交事务T1读取的数据项X的值，之后T2提交，然后T1再次读取数据项X的值时，会得到与第一次读取时不同的值。</p></blockquote><ul><li>幻读</li></ul><p>一个事务先根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写入了一些符合那些搜索条件的记录（可以是INSERT、DELETE、UPDATE操作），就意味着发生了幻读现象</p><blockquote><p>T1先读取符合搜索条件P的记录，然后T2写入了符合条件P的记录。之后T1再次读取符合搜索条件P的记录时，会发现两次读取的记录是不一样的。</p></blockquote><h1 id="SQL标准中的四种隔离级别"><a href="#SQL标准中的四种隔离级别" class="headerlink" title="SQL标准中的四种隔离级别"></a>SQL标准中的四种隔离级别</h1><p>上述一致性问题，会对事务的一致性产生不同程度的影响。按照可能导致一致性问题的严重性给这些现象排一下序：</p><p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p><p>sql标准中规定的并发事务执行过程中可以发生的现象</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITED</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>READ COMMITED</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>REPEATABLE READ</td><td>不可能</td><td>不可能</td><td>不可能</td></tr><tr><td>SERIALIZABLE</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><blockquote><p>脏写情况比较严重，任何隔离级别下都不允许该情况发生</p></blockquote><h1 id="MVVC原理"><a href="#MVVC原理" class="headerlink" title="MVVC原理"></a>MVVC原理</h1><p>​    对于InnoDB存储引擎的表来说，它的聚簇索引记录中都包含下面这两个必要的隐藏列（row_id并不是必要的；在创建表中有主键时，或许又不允许为NULL的UNIQUE键时，都不会包含row_id列）</p><ul><li>trx_id：一个事务每次对某条聚簇索引列记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列</li><li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中。这个隐藏列就相当于一个指针，可以通过它找到该记录修改前的信息</li></ul><p>​    每对记录做一次改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（insert操作对应的undo日志没有该属性，因为insert操作的记录并没有更早的版本），通过这个属性可以将这些undo日志串成一个链表。</p><br><img src="/2023/09/26/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVVC/image-20231010234000323.png" class><p>​    在每次更新记录后，都会将旧值放入到一条undo日志中（就算是该记录的一个旧版本）。随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，这个链表称为版本链。版本链的头节点就是当前记录的最新值。同时，每个版本中还包含生成该版本时对应的事务id。</p><p>利用版本链来控制并发事务访问相同记录时的行为，我们把这种机制称为多版本并发控制（Multi-Version Concurrency Control, MVVC）</p><h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2><p>对于使用READ UNCOMMITTED隔离级别的事务来说，可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了；</p><p>对于<code>SERIALIZABLE</code>隔离级别的事务来说，可以使用加锁的方式</p><p>对于<code>READ COMMITED</code>和<code>REPEATABLE READ</code>隔离级别的事务来说，都必须保证读到已经提交的事务修改过多记录。</p><p>核心问题就是需要判断版本链中的哪个版本是当前事务可见的。于是<code>MySql</code>提出了<code>ReadView</code>的概念</p><ul><li><code>m_ids</code>：在生成<code>ReadView</code>时，当前<strong>系统中活跃</strong>的读写事务的事务id列表</li><li><code>min_trx_id</code>：在生成<code>ReadView</code>时，当前<strong>系统中活跃</strong>的读写事务中最小的事务id（也就是<code>m_ids</code>中的最小值）</li><li><code>max_trx_id</code>：在生成<code>ReadView</code>时，系统应该分配给下一个事务的事务id值</li><li><code>creator_trx_id</code>：生成该<code>ReadView</code>的事务的事务id</li></ul><blockquote><p>只有在对表中的记录进行改动时（执行INSERT、UPDATE、DELETE语句这些语句时），才会为事务分配唯一的事务id，否则一个事务的事务id值都默认为0</p></blockquote><p>有了<code>ReadView</code>后，在访问某条记录时，只需要按照下面的步骤来判断记录的某个版本是否可见</p><ul><li>如果被访问版本的<code>trx_id</code>属性值与<code>ReadView</code>中的<code>creator_trx_id</code>值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问</li><li>如果被访问版本的<code>trx_id</code>属性值小于<code>ReadView</code>中的<code>min_trx_id</code>值，表明生成该版本的事务 在当前事务生成<code>ReadView</code>前已经提交，所以可以被访问</li><li>如果被访问版本的<code>trx_id</code>属性值大于<code>ReadView</code>中的<code>max_trx_id</code>值，表明生成该版本的事务 在当前事务生成<code>ReadView</code>后才生成，所以不可被访问</li><li>如果被访问版本的<code>trx_id</code>属性值在<code>ReadView</code>的<code>min_trx_id</code>和<code>max_trx_id</code>之间，则需要判断该<code>trx_id</code>是否在 <code>m_ids</code>列表中。如果在，说明生成该版本的事务还是活跃的，不可以被访问。如果不在，说明事务已经提交，该版本可以被访问</li></ul><p>如果某个版本的数据对当前事务不可见，那就顺着版本链找到下一个版本的数据1，（也就是记录头中的<code>rool_pointer</code>串成的undo日志链表）继续上面的过程判断可见性。</p><p>如果找完最后一个版本，也不能可见，说明该记录对当前事务完全不可见。</p><h2 id="READ-COMMITED"><a href="#READ-COMMITED" class="headerlink" title="READ COMMITED"></a>READ COMMITED</h2><blockquote><p>每次读取数据前都生成一个ReadView</p></blockquote><p>所以<code>READ COMMITED</code>y有不可重复读的问题，</p><blockquote><p>事务T1先读取了数据项X的值，然后T2又修改了未提交事务T1读取的数据项X的值，之后T2提交，然后T1再次读取数据项X的值时，会得到与第一次读取时不同的值。</p></blockquote><p>因为每次查询都会新生成一个ReadView，对于第二次查询生成的ReadView来说，由于事务T2已经提交了，所以他能读取到</p><h2 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h2><blockquote><p>只有第一次执行查询语句时，才会生成一个<code>ReadView</code></p></blockquote><p>所以它可以解决重复读的问题</p><p>事务T1先读取数据项X的值后，会生成一个<code>ReadView</code>，然后事务T2又修改了T1读取的数据项X的值，之后T2提交。</p><p>此时数据行记录的trx_id会变成T2提交的事务id，第二次查询时，发现生成的<code>ReadView</code>中，不满足可见性原则，（<code>ReadView</code>中的<code>max_trx_id</code>小于当前数据行中记录的<code>trx_id</code>）所以不会读到事务2修改后的值</p><p><code>REPEATABLE READ</code>级别下，可以很大程度上解决幻读问题，但是并不能完全解决幻读</p><p>比如：</p><table><thead><tr><th>时刻</th><th>事务T1</th><th>事务T2</th></tr></thead><tbody><tr><td>T1</td><td>BEGIN;<br>SELECT * FROM <code>student</code> where number &gt;= 20221101;<br></td><td></td></tr><tr><td>T2</td><td></td><td>BEGIN;<br>INSERT INTO <code>tmp</code>.<code>student</code> (<code>number</code>, <code>name</code>, <code>major</code>) <br>    VALUES (20221104, ‘赵六’, ‘测试-RR级别下可能发生幻读问题’);<br>COMMIT;</td></tr><tr><td>T3</td><td>UPDATE student set name = ‘赵六2’ where number = 20221104;<br></td><td></td></tr><tr><td>T4</td><td>SELECT * FROM <code>student</code> where number &gt;= 20221101;<br>COMMIT;</td><td></td></tr></tbody></table><p>在T4时刻，T1事务就会发生幻读现象。</p><p>原因是：<code>UPDATE</code>语句不是采用<code>MVVC</code>这种快照读，而是采用的当前读。</p><blockquote><p>当前读是读取的数据库最新的数据，当前读和快照读不同，因为要读取最新的数据而且要保证事务的隔离性，所以当前读是需要对数据进行加锁的</p></blockquote><p>也就是说，事务T1的update语句，会对事务2新增的记录进行加锁、修改字段值、并且将隐藏列<code>trx_id</code>修改为自己的事务id，所以T4时刻根据MVVC再去读取时，发现满足可见性，所以产生幻读现象</p><h2 id="二级索引与MVVC"><a href="#二级索引与MVVC" class="headerlink" title="二级索引与MVVC"></a>二级索引与MVVC</h2><p>只有聚簇索引才有<code>trx_id</code>和<code>roll_pointer</code>隐藏列。那么，如果某个查询语句是使用二级索引来查询的，该如何判断可见性呢？</p><ul><li><p>步骤一：二级索引页面的PAGE HEADER部分，有一个名为<code>PAGE_MAX_TRX_ID</code>的属性，每当对该页面中的记录执行增删改操作时，如果执行该操作的事务的事务id大于 <code>PAGE_MAX_TRX_ID</code>属性值，就会把就会把<code>PAGE_MAX_TRX_ID</code>属性设置为执行该操作的事务的事务id。</p><p>也就是说，<code>PAGE_MAX_TRX_ID</code>的值代表着修改该二级索引页面的最大事务id。</p><p>当select语句访问某个二级索引记录时，首先看一下对应<code>ReadView</code>中的<code>min_trx_id</code>是否大于该页面的<code>PAGE_MAX_TRX_ID</code>，如果大于，则表示该页面中的所有记录都对该<code>ReadView</code>可见；否则就需要执行步骤2，回表之后再判断可见性</p></li><li><p>步骤二：利用二级索引记录中的主键值进行回表操作，得到对应聚簇索引记录后再判断可见性</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一致性问题&quot;&gt;&lt;a href=&quot;#一致性问题&quot; class=&quot;headerlink&quot; title=&quot;一致性问题&quot;&gt;&lt;/a&gt;一致性问题&lt;/h1&gt;&lt;p&gt;事务并发执行时会遇到的一致性问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脏写&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个事务修改了另一个未</summary>
      
    
    
    
    <category term="mysql" scheme="https://c89757.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="https://c89757.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>jvm常见命令</title>
    <link href="https://c89757.github.io/2023/08/16/jvm%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>https://c89757.github.io/2023/08/16/jvm%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</id>
    <published>2023-08-16T12:55:41.000Z</published>
    <updated>2023-08-19T13:22:45.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jstat"><a href="#Jstat" class="headerlink" title="Jstat"></a>Jstat</h1><h2 id="JIT相关"><a href="#JIT相关" class="headerlink" title="JIT相关"></a>JIT相关</h2><ul><li>jstata  -compiler [pid]</li></ul><p>查看JIT编译器编译过的方法、耗时等</p><ul><li>jstat -printcompilation</li></ul><p>输出已经被JIT编译的方法</p><h2 id="垃圾回收相关"><a href="#垃圾回收相关" class="headerlink" title="垃圾回收相关"></a>垃圾回收相关</h2><ul><li>-gc</li></ul><blockquote><p> 显示与GC相关的对信息。包括Eden区、两个Survivor区、老年代、永久代等容量、已用空间</p></blockquote><p><code>jstat -gc [pid] 1000 10</code>: 每隔一秒（1000ms ）打印一次gc信息，总共打印10次</p><p><code>jstat -gc -t</code>: 会多一列Timestamp，表示Java进程启动的总时间；</p><p>我们可以比较Java进程启动的总时间以及总GC时间（GCT列），或者两次测量的间隔时间以及GC总时间的增量，得到GC时间占运行时间的比例</p><p>如果该比例超过20%，则说明目前堆压力较大；如果超过90%，则说明堆里几乎没有可用空间，随时都可能抛出OOM异常</p><ul><li>-gccapacoty</li></ul><blockquote><p>显示内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。</p></blockquote><ul><li>-gcutil</li></ul><blockquote><p>显示内容与-gc基本相同。但输出主要关注已使用空间占总空间的百分比</p></blockquote><ul><li>-gccause</li></ul><blockquote><p>与-gcutil功能一样，但会额外输出导致最后一次或当前正在发生的GC产生的原因</p></blockquote><ul><li>-gcnew</li></ul><blockquote><p>显示新生代GC情况</p></blockquote><ul><li>-gcnewcapacity</li></ul><blockquote><p>显示内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</p></blockquote><ul><li>-geold</li></ul><blockquote><p>显示老年代GC情况</p></blockquote><ul><li>-gcolccapacity</li></ul><blockquote><p>显示内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</p></blockquote><ul><li>-gcpermcapacity</li></ul><blockquote><p>显示永久代使用到的最大、最小空间</p></blockquote><p>jstat还可以用来判断是否出现内存泄漏</p><p>1、在长时间运行的Java程序中，我们可以运行jstat命令连续获取多行性能数据，并取这几行数据中OU列（即已占用的老年代内存）的最小值</p><p>2、然后我们每隔一段较长的时间重复一次上述操作，来获得多组OU最小值。如果这些值呈上升趋势，则说明该Java程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏</p><h1 id="Jinfo"><a href="#Jinfo" class="headerlink" title="Jinfo"></a>Jinfo</h1><p>查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数</p><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>PID必须要加上</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>no optition</td><td>输出全部的参数和系统属性</td></tr><tr><td>-flag name</td><td>输出对应名称的参数</td></tr><tr><td>-flag [+-name]</td><td>开启或关闭对应名称的参数，只有被编辑为manageable的参数才可以被动态修改</td></tr><tr><td>-flag name=value</td><td>设定对应名称的参数</td></tr><tr><td>-flags</td><td>输出全部的参数</td></tr><tr><td>-sysprops</td><td>输出系统属性</td></tr></tbody></table><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>jinfo甚至可以在运行时修改部分参数，并使之立即生效</p><p>但是，并非所有参数都支持动态修改，参数只有标记为manageable的flag可以被实时修改，其实，这个修改能力都是及其有限的</p><p>可以查看被标记为manageable的参数</p><p><code>java -XX:+PrintFlagsFinal -version |grep manageable</code></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>java -XX:+PrintFlagInitial</code></p><p>查看所有JVM参数启动的初始值</p><p><code>java -XX:+PrintFlagsFinal</code></p><p>查看所有JVM参数的最终只</p><p><code>java -XX+PrintCommandLineFlags</code></p><p>查看那些已经被用户或者JVM设置过的详细的XX参数的名称和值</p><h1 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h1><p>​    作用一方面是获取dump文件（堆转储快照文件，二进制文件），它还可以获取目标java进程的内存相关信息，包括Java堆各区域的使用情况、堆中对象的统计信息、类加载信息等。</p><p>​    由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要借助安全点机制，让所有线程留在不改变堆中数据的状态。也就是说，由jmap导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。</p><p>​    另外，如果某个线程长时间无法跑到安全点，jmap将一直等下去，与jstat则不同，垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中，则jstat只需直接读取即可。</p><p><a href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html"> 官方文档</a></p><ul><li><code>-dump</code></li></ul><p>生成Java堆转储快照：dump文件</p><p>-<code>dumplive</code>: 只保存堆中的存活对象</p><p>导出内存映像文件</p><blockquote><p>手动的方式</p></blockquote><p><code>jmap -dump:format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;</code></p><p><code>jmap -dump:live,format=b,file=&lt;filename.hprof&gt;&lt;pid&gt;</code></p><p>format作用：使jmap生成文件与.hprof格式匹配起来</p><blockquote><p>自动的方式</p></blockquote><p><code>-XX:+HeapDumpOnOutOfMemoryError</code></p><p><code>-XX:+HeapDumpPath=&lt;filename.hprof&gt;</code></p><ul><li><code>-heap</code></li></ul><p>输出整个堆空间的详细信息，包括GC的使用、堆配置信息，以及内存的使用信息等</p><ul><li><code>-histo</code></li></ul><p>输出堆中对象的统计信息，包括类、实例数量的合计容量</p><p><code>-histo:live</code>: 只统计堆中的存活对象（注意，此命令慎重使用，会引发FullGc）</p><ul><li><code>-permstat</code></li></ul><p>以ClassLoader为统计口径输出永久代的内存状态信息</p><p>仅linux/solaris平台有效</p><ul><li><code>-finalizerinfo</code></li></ul><p>显示在F-Queue中等待Finailzer线程执行finalize方法的对象</p><p>仅linux/solaris平台有效</p><ul><li><code>-F</code></li></ul><p>当虚拟机进程对-dump选项没有任何响应时，可使用此选项强制执行生成dump文件</p><p>仅linux/solaris平台有效</p><ul><li><code>-J &lt;flag&gt;</code></li></ul><p>传递参数给jmap启动的jvm</p><h1 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h1><p>​    Sun JDK提供的jhat命令与jmap命令搭配使用，用于分析jmap生成的heap dump文件（堆转储快照）。hgat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，用户可以在浏览器中查看分析结果</p><p>​    使用了jhat命令，就启动了一个http服务器，端口是7000，则<a href="http://localhost:7000/">http://localhost:7000</a></p><p>​    注意：jhat命令在JDK9后，已经被删除</p><p>基本使用语法：</p><p><code>jhat [option] [dumpfile]</code></p><h1 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h1><p>​    用于生成虚拟机指定进程当前时刻的线程快照（虚拟机堆栈跟踪）。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合</p><p>​    </p><ul><li><code>-F</code></li></ul><p>当正常输出的请求不被响应时，强制输出线程堆栈</p><ul><li><code>-l</code></li></ul><p>除堆栈外，显示关于锁的附加信息</p><ul><li>-m</li></ul><p>如果调用到本地方法的话，可以显示C/C++的堆栈</p><p>在thread dump中，要留意下面几种状态</p><ul><li><p>死锁，Deadlock (重点关注)</p></li><li><p>等待资源，Waiting on condition (重点关注)</p></li><li><p>等待获取监视器，Waiting on monitor entry (重点关注)</p></li><li><p>阻塞，Blocked （重点关注）</p></li><li><p>执行中，Runnable</p></li><li><p>暂停，Suspended</p></li><li><p>对象等待中，Object.wait() 或 TIMED_WAITING</p></li><li><p>停止， Parked</p></li></ul><h1 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h1><p>在JDK 1.7以后，新增了一个命令行工具jcmd</p><p>它是一个多功能的工具，可以用来实现前面除了jstat之外的所有命令的功能 。比如：用它来导出堆、内存使用、查看Java进程、导出线程信息、执行GC、JVM运行时间等。</p><h1 id="相关jvm参数"><a href="#相关jvm参数" class="headerlink" title="相关jvm参数"></a>相关jvm参数</h1><ul><li><code>-verbose:gc</code></li></ul><p>输出gc日志信息，默认输出到标准输出</p><ul><li><code>-XX:+PrintGc</code></li></ul><p>等同于<code>-verbose:gc</code>，表示打开简化的GC日志</p><ul><li><code>-XX:+PrintGCDetails</code></li></ul><p>在发生垃圾回收时打印内存回收详细的日志</p><ul><li><code>-XX:+PrintGCDateStamps</code></li></ul><p>输出GC发生时的时间戳</p><ul><li>-XX:+PrintHeapAtGc</li></ul><p>每一个GC前和GC后，都打印堆信息</p><ul><li><code>-Xlogg&lt;file&gt;</code> </li></ul><p>把GC日志写入到一个文件中去，而不是打印到标准输出中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Jstat&quot;&gt;&lt;a href=&quot;#Jstat&quot; class=&quot;headerlink&quot; title=&quot;Jstat&quot;&gt;&lt;/a&gt;Jstat&lt;/h1&gt;&lt;h2 id=&quot;JIT相关&quot;&gt;&lt;a href=&quot;#JIT相关&quot; class=&quot;headerlink&quot; title=&quot;JIT</summary>
      
    
    
    
    <category term="jvm" scheme="https://c89757.github.io/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://c89757.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>线上cpu飙升排查</title>
    <link href="https://c89757.github.io/2023/08/09/%E7%BA%BF%E4%B8%8Acpu%E9%A3%99%E5%8D%87%E6%8E%92%E6%9F%A5/"/>
    <id>https://c89757.github.io/2023/08/09/%E7%BA%BF%E4%B8%8Acpu%E9%A3%99%E5%8D%87%E6%8E%92%E6%9F%A5/</id>
    <published>2023-08-09T14:58:45.000Z</published>
    <updated>2023-08-17T12:58:48.379Z</updated>
    
    <content type="html"><![CDATA[<p>1、找出服务运行的进程号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure><p>2、利用top命令查看对应进程下，各个线程占用情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -H -p &#123;pid&#125;</span><br></pre></td></tr></table></figure><p>3、找到占用最高的线程，拿到线程其线程号，将其转为十六进制（因为java里面记录的线程号都是十六进制）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &#x27;%x\n&#x27; &#123;tid&#125;</span><br></pre></td></tr></table></figure><p>4、利用<code>jstack</code>抓取线程快照</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack -l &#123;pid&#125; |grep ‘&#123;十六进制tid&#125;&#x27;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、找出服务运行的进程号&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c</summary>
      
    
    
    
    <category term="jvm" scheme="https://c89757.github.io/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://c89757.github.io/tags/jvm/"/>
    
    <category term="questions" scheme="https://c89757.github.io/tags/questions/"/>
    
  </entry>
  
  <entry>
    <title>阻塞队列</title>
    <link href="https://c89757.github.io/2023/03/09/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>https://c89757.github.io/2023/03/09/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2023-03-09T15:21:33.000Z</published>
    <updated>2023-03-09T16:28:23.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK里的阻塞队列"><a href="#JDK里的阻塞队列" class="headerlink" title="JDK里的阻塞队列"></a>JDK里的阻塞队列</h1><ul><li>ArrayBlockingQueue</li></ul><p>数组构成的有界阻塞队列</p><ul><li>LinkedBlockingQueue</li></ul><p>链表构成的无界阻塞队列</p><p>tips: 使用无界阻塞队列的put或offer方法时，永远不会阻塞， 因为队列不可能满</p><ul><li>PriorityBlockingQueue</li></ul><p>一个支持优先级排序的无界阻塞队列</p><ul><li>DelayQueue</li></ul><p>一个使用优先级队列实现的无界阻塞队列</p><ul><li>SynchronousQueue</li></ul><p>一个不存储元素的阻塞队列</p><ul><li>LinkedTransferQueue</li></ul><p>由链表组成的无界阻塞队列</p><ul><li>LinkedBlockingDeque</li></ul><p>由链表结构组成的双向阻塞队列</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDK里的阻塞队列&quot;&gt;&lt;a href=&quot;#JDK里的阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;JDK里的阻塞队列&quot;&gt;&lt;/a&gt;JDK里的阻塞队列&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;ArrayBlockingQueue&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数组构</summary>
      
    
    
    
    <category term="java" scheme="https://c89757.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://c89757.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Mysql索引合并</title>
    <link href="https://c89757.github.io/2023/02/20/Mysql%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6/"/>
    <id>https://c89757.github.io/2023/02/20/Mysql%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6/</id>
    <published>2023-02-20T14:40:41.000Z</published>
    <updated>2023-02-20T15:08:50.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intersection索引合并"><a href="#Intersection索引合并" class="headerlink" title="Intersection索引合并"></a>Intersection索引合并</h1><p>例如以下查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> key3 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure><p>其中key1、key3加了普通索引，分别名为idx_key1，idx_key3</p><p>那么，有如下几种方案执行该查询</p><p>1、使用idx_key1索引执行该查询，此时对应的扫描区间就是 [‘a’, ‘a’]。对于获取的每条二级索引记录，都需要根据它的id值执行回表操作后获取到完整的用户记录，再判断key3 = ‘b’是否成立。其中，二级索引中，对于key1 = ‘a’的id列是按照主键值排序的</p><p>2、使用idx_key3索引执行 该查询，同样的，需要回表判断key1的条件是否成立</p><p>方案3：同时使用idx_key1和idx_key3进行查询。也就是在idx_key1中扫描key1值在[‘a’,’a’]区间中的二级索引记录，同时在idx_key3中扫描key3在[‘b’,’b’]区间中的二级索引记录，然后从两者的操作结果中找出id列值相同的值，进行回表（这样可以省下很多回表操作）</p><p>Intersection索引合并指的就是从不同索引中扫描的记录id取交集，只会为这些共同的id值进行回表操作。</p><blockquote><p>如果使用Intersection索引合并的方式进行查询，并且每个使用的索引都是二级索引的话，则要求从每个索引中获取到的二级索引记录都是按照主键值排序的</p></blockquote><h1 id="Union索引合并"><a href="#Union索引合并" class="headerlink" title="Union索引合并"></a>Union索引合并</h1><p>例如以下查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> key3 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure><p>其中key1、key3加了普通索引，分别名为idx_key1，idx_key3</p><p>上述查询，可以同时使用idx_key1和idx_key2来执行查询。也就是在idx_key1中扫描key1值位于[‘a’,’a’]区间中的二级索引记录，同时在idx_key3中扫描key3值位于[‘b’,’b’]区间中的二级索引记录，然后根据二级索引记录的id值在两者的结果中进行去重，再根据去重后的id值执行回表操作，这样重复的id值只需要回表一次</p><blockquote><p>如果使用Union索引合并的方式进行查询，并且每个使用的索引都是二级索引的话，则要求从每个索引中获取到的二级索引记录都是按照主键值排序的</p></blockquote><p>如果在使用某个二级索引执行查询时，从对应的扫描区间中读取出的二级索引记录不是按照主键值排序的，则不可以使用Union索引合并的方式执行查询。比如下面的查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> key3 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure><p>因为从idx_key1的扫描区间（’a’, +∞）中获取到的记录并不是按照主键值排序的（只有在key1列相同的时候，它相对应的主键是有序的）</p><h1 id="Sort-Union索引合并"><a href="#Sort-Union索引合并" class="headerlink" title="Sort-Union索引合并"></a>Sort-Union索引合并</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> key1 <span class="operator">&lt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> key3 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这个查询不能用union索引合并查询，但是我们可以像如下操作：</p><p>1、先根据key1 &lt; ‘a’条件从idx_key1二级索引中获取二级索引记录，并将获取到的二级索引记录的主键进行排序</p><p>2、再根据key3 &gt; ‘z’条件从idx_key3二级索引中获取二级索引记录，并将获取到的二级索引记录的主键进行排序</p><p>3、因此上述两个二级索引主键值都是排好序了，剩下的操作就是使用union索引合并</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Intersection索引合并&quot;&gt;&lt;a href=&quot;#Intersection索引合并&quot; class=&quot;headerlink&quot; title=&quot;Intersection索引合并&quot;&gt;&lt;/a&gt;Intersection索引合并&lt;/h1&gt;&lt;p&gt;例如以下查询&lt;/p&gt;
&lt;fi</summary>
      
    
    
    
    <category term="mysql" scheme="https://c89757.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="https://c89757.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>innodb数据页</title>
    <link href="https://c89757.github.io/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/"/>
    <id>https://c89757.github.io/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/</id>
    <published>2023-02-18T14:54:52.000Z</published>
    <updated>2023-02-19T16:04:56.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><br><p>innodb页目录结构大致如下</p><br><img src="/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/image-20230218234003851.png" class><br><p>先说说行格式，compact行格式结构如下</p><p>（其中，记录的真实数据，除了用户真实的数据以外，还有一些隐藏列，</p><p>row_id - 行id，唯一标识一条记录，没有定义主键时，会添加此隐藏列；</p><p>事务id -  事务ID</p><p>roll_pointer：回滚指针）</p><br><img src="/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/image-20230218233845956.png" class><br><p>记录头各属性及其解释如下</p><br><img src="/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/image-20230218233857866.png" class><br><p>表中记录大致如下</p><br><img src="/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/image-20230218235643636.png" class><br><br><h1 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h1><br><p>​    记录在页中是按照主键值由小到大的顺序串联成一个单项链表，如果要查找表中一条记录，最简单的方法就是遍历链表，但是当记录非常多时，是很耗费性能的，于是就有了page directory页目录。其实就是一个字典</p><br><p>1、将所有正常的记录（包括Infimum和Supremum记录，但是不包括已经移除到垃圾链表的记录）划分为几个组</p><p>2、每个组的最后一条记录（也就是组内最大的那条记录）相当于带头大哥，组内其余的记录相当于小弟，带头大哥记录的头信息中的n_owned属性表示该组内共有几条记录</p><p>3、将每个组中最后一条记录在页面中的地址偏移量（就是该记录的真实数据与页面中第0个字节之间的距离）单独提取出来，按顺序存储到靠近页尾部的地方，这个地方就是<code>Page Directory</code>.页目录中这些地址偏移量称为槽（Slot)，每个槽占用2字节，页目录就是由多个槽组成的</p><br><img src="/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/image-20230219000408171.png" class><br><br><ul><li>Infimum记录中的n_owned值为1，表示以Infimum记录为最后一个节点的这个组中只有一条记录，也就是Infimum记录自身</li><li>Supremum记录的n_owned值为3，表示以Supremum记录为最后一个节点的这个分组中有3条记录，即除了Supremum记录自身外，还有两条记录</li></ul><br><br><p>分组的依据：</p><p>对于Infimum记录所在的分组只能有1条记录，Supremum记录所在的分组拥有的记录条数只能在1<del>8之间，剩下分组中的条数范围只能是4</del>8之间。</p><br><h1 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h1><br><p>页面头部</p><p>存储数据页中的记录的各种状态信息</p><br><img src="/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/image-20230219224613055.png" class><br><br><h1 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h1><br><p>记录页面当前页号，以及上一页、下一页的页号（并不是所有类型的页都会记录上一页、下一页的页号）</p><br><img src="/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/image-20230219001321572.png" class><br><ul><li>每一个<code>页</code>都有一个单独的页号，就跟你的身份证号码一样，<code>InnoDB</code>通过页号来可以唯一定位一个<code>页</code>。</li><li>FIL_PAGE_TYPE</li></ul><br><img src="/2023/02/18/innodb%E6%95%B0%E6%8D%AE%E9%A1%B5/image-20230219001549129.png" class><ul><li>我们存放记录的数据页的类型其实是<code>FIL_PAGE_INDEX</code>，也就是所谓的<code>索引页</code></li></ul><br><h1 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h1><br><p>文件尾部，用于检验一个页是否完整（刷盘时，不可预知的情况可能导致刷盘只刷新了一部分)</p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;br&gt;

&lt;p&gt;innodb页目录结构大致如下&lt;/p&gt;
&lt;br&gt;

&lt;img src=&quot;/2023/02/18/innodb%E6%95%B0%</summary>
      
    
    
    
    <category term="mysql" scheme="https://c89757.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="https://c89757.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>G1 GC</title>
    <link href="https://c89757.github.io/2023/02/05/G1-GC/"/>
    <id>https://c89757.github.io/2023/02/05/G1-GC/</id>
    <published>2023-02-05T07:13:35.000Z</published>
    <updated>2024-03-11T11:46:21.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Grabage-First"><a href="#Grabage-First" class="headerlink" title="Grabage First"></a>Grabage First</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    G1是一款主要面向服务端的垃圾收集器，在JDK9时，取代了Parallel Scavenge + Parallel Old组合，成为了默认的垃圾收集器。    </p><p>​    在G1出现之前，垃圾收集的目标范围要么是整个新生代（Minor GC），要么是整个老年代（Major GC），再要么就是整个Java堆（Full GC）。而G1可以面向堆内存任何部分来组成回收集（Collection Set，简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。</p><p>​    G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要扮演新生代的Eden、Survivor、或者老年代 。</p><p>​    Humongous，专门存储大对象（超过了一个Region容量一半的对象，即达到1.5倍region）。每个Region的大小可以通过参数 <code>-XX:G1HeapRegionSize</code>设定。取值范围为1MB~32MB，且应为2的N次幂。而超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中。（G1的大多数行为把Humongous当作老年代的一部分看待）</p><p>​    G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了。</p><h2 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h2><p>一个Region中的对象可能被其他任意Region中的对象所引用，判断对象存活时，是否需要扫描整合java堆才能保证准确？</p><blockquote><p>比如新生代Region中的对象被老年代Region中的对象引用，回收新生代时不得不同时扫描老年代，这样的话会降低Minor GC的效率</p></blockquote><p>无论是G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描</p><br><p><strong>每个Region都有一个对应的Remembered  Set</strong></p><blockquote><p>G1内存占用比较高，需要维护记忆集、卡表等。至少要耗费大约相当于堆容量的10%~20%的额外内存来维持收集器工作</p></blockquote><br><p>美团技术团队：<a href="https://tech.meituan.com/2016/09/23/g1.html">https://tech.meituan.com/2016/09/23/g1.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Grabage-First&quot;&gt;&lt;a href=&quot;#Grabage-First&quot; class=&quot;headerlink&quot; title=&quot;Grabage First&quot;&gt;&lt;/a&gt;Grabage First&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; cla</summary>
      
    
    
    
    <category term="jvm" scheme="https://c89757.github.io/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://c89757.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>记-并发情况下mysql死锁问题</title>
    <link href="https://c89757.github.io/2023/01/28/%E8%AE%B0-%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E4%B8%8Bmysql%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <id>https://c89757.github.io/2023/01/28/%E8%AE%B0-%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E4%B8%8Bmysql%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</id>
    <published>2023-01-28T15:30:14.000Z</published>
    <updated>2023-01-28T15:59:34.017Z</updated>
    
    <content type="html"><![CDATA[<p>背景：业务中采用先删除后插入的逻辑，开启了事务。</p><p>表结构大概如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `table_test`  (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `key1` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `column1` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `column2` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  INDEX `idx_key1`(`key1`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB  <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先根据二级索引key1删除表中数据（相同的key1），再批量插入数据，在并发情况下，频繁出现死锁问题。</p><p>利用</p><blockquote><p>set GLOBAL innodb_status_output_locks = on;</p><p>show  engine innodb status;</p></blockquote><p>可以查看mysql最后一次发生死锁的情况</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">------------------------</span></span><br><span class="line"><span class="attr">LATEST</span> <span class="string">DETECTED DEADLOCK</span></span><br><span class="line"><span class="attr">------------------------</span></span><br><span class="line"><span class="meta">2023-01-28</span> <span class="string">23:25:46 0x14e90</span></span><br><span class="line"><span class="meta">***</span> <span class="string">(1) TRANSACTION:</span></span><br><span class="line"><span class="attr">TRANSACTION</span> <span class="string">62092, ACTIVE 0 sec starting index read</span></span><br><span class="line"><span class="attr">mysql</span> <span class="string">tables in use 1, locked 1</span></span><br><span class="line"><span class="attr">LOCK</span> <span class="string">WAIT 6 lock struct(s), heap size 1136, 6 row lock(s)</span></span><br><span class="line"><span class="attr">MySQL</span> <span class="string">thread id 239, OS thread handle 20368, query id 105887 localhost 127.0.0.1 root updating</span></span><br><span class="line"><span class="attr">delete</span> <span class="string">from table_test where key1 = &#x27;aaa&#x27;</span></span><br><span class="line"><span class="meta">***</span> <span class="string">(1) WAITING FOR THIS LOCK TO BE GRANTED:</span></span><br><span class="line"><span class="attr">RECORD</span> <span class="string">LOCKS space id 308 page no 3 n bits 152 index PRIMARY of table `db`.`table_test` trx id 62092 lock_mode X locks rec but not gap waiting</span></span><br><span class="line"><span class="attr">Record</span> <span class="string">lock, heap no 56 PHYSICAL RECORD: n_fields 6; compact format; info bits 32</span></span><br><span class="line"> <span class="attr">0</span>: <span class="string">len 4; hex 80001e9c; asc     ;;</span></span><br><span class="line"> <span class="attr">1</span>: <span class="string">len 6; hex 00000000f28e; asc       ;;</span></span><br><span class="line"> <span class="attr">2</span>: <span class="string">len 7; hex 79000001ff139a; asc y      ;;</span></span><br><span class="line"> <span class="attr">3</span>: <span class="string">len 3; hex 616161; asc aaa;;</span></span><br><span class="line"> <span class="attr">4</span>: <span class="string">len 1; hex 31; asc 1;;</span></span><br><span class="line"> <span class="attr">5</span>: <span class="string">len 1; hex 32; asc 2;;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">***</span> <span class="string">(2) TRANSACTION:</span></span><br><span class="line"><span class="attr">TRANSACTION</span> <span class="string">62094, ACTIVE 0 sec updating or deleting, thread declared inside InnoDB 0</span></span><br><span class="line"><span class="attr">mysql</span> <span class="string">tables in use 1, locked 1</span></span><br><span class="line"><span class="attr">5</span> <span class="string">lock struct(s), heap size 1136, 6 row lock(s), undo log entries 1</span></span><br><span class="line"><span class="attr">MySQL</span> <span class="string">thread id 242, OS thread handle 85648, query id 105894 localhost 127.0.0.1 root updating</span></span><br><span class="line"><span class="attr">delete</span> <span class="string">from table_test where key1 = &#x27;aaa&#x27;</span></span><br><span class="line"><span class="meta">***</span> <span class="string">(2) HOLDS THE LOCK(S):</span></span><br><span class="line"><span class="attr">RECORD</span> <span class="string">LOCKS space id 308 page no 3 n bits 152 index PRIMARY of table `db`.`table_test` trx id 62094 lock_mode X</span></span><br><span class="line"><span class="attr">Record</span> <span class="string">lock, heap no 56 PHYSICAL RECORD: n_fields 6; compact format; info bits 32</span></span><br><span class="line"> <span class="attr">0</span>: <span class="string">len 4; hex 80001e9c; asc     ;;</span></span><br><span class="line"> <span class="attr">1</span>: <span class="string">len 6; hex 00000000f28e; asc       ;;</span></span><br><span class="line"> <span class="attr">2</span>: <span class="string">len 7; hex 79000001ff139a; asc y      ;;</span></span><br><span class="line"> <span class="attr">3</span>: <span class="string">len 3; hex 616161; asc aaa;;</span></span><br><span class="line"> <span class="attr">4</span>: <span class="string">len 1; hex 31; asc 1;;</span></span><br><span class="line"> <span class="attr">5</span>: <span class="string">len 1; hex 32; asc 2;;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Record</span> <span class="string">lock, heap no 71 PHYSICAL RECORD: n_fields 6; compact format; info bits 32</span></span><br><span class="line"> <span class="attr">0</span>: <span class="string">len 4; hex 80001e9b; asc     ;;</span></span><br><span class="line"> <span class="attr">1</span>: <span class="string">len 6; hex 00000000f282; asc       ;;</span></span><br><span class="line"> <span class="attr">2</span>: <span class="string">len 7; hex 72000001ba2356; asc r    #V;;</span></span><br><span class="line"> <span class="attr">3</span>: <span class="string">len 3; hex 616161; asc aaa;;</span></span><br><span class="line"> <span class="attr">4</span>: <span class="string">len 1; hex 31; asc 1;;</span></span><br><span class="line"> <span class="attr">5</span>: <span class="string">len 1; hex 32; asc 2;;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Record</span> <span class="string">lock, heap no 80 PHYSICAL RECORD: n_fields 6; compact format; info bits 32</span></span><br><span class="line"> <span class="attr">0</span>: <span class="string">len 4; hex 80001e9a; asc     ;;</span></span><br><span class="line"> <span class="attr">1</span>: <span class="string">len 6; hex 00000000f288; asc       ;;</span></span><br><span class="line"> <span class="attr">2</span>: <span class="string">len 7; hex 75000001e919c8; asc u      ;;</span></span><br><span class="line"> <span class="attr">3</span>: <span class="string">len 3; hex 616161; asc aaa;;</span></span><br><span class="line"> <span class="attr">4</span>: <span class="string">len 1; hex 31; asc 1;;</span></span><br><span class="line"> <span class="attr">5</span>: <span class="string">len 1; hex 32; asc 2;;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">***</span> <span class="string">(2) WAITING FOR THIS LOCK TO BE GRANTED:</span></span><br><span class="line"><span class="attr">RECORD</span> <span class="string">LOCKS space id 308 page no 4 n bits 152 index idx_key1 of table `db`.`table_test` trx id 62094 lock_mode X locks rec but not gap waiting</span></span><br><span class="line"><span class="attr">Record</span> <span class="string">lock, heap no 39 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span></span><br><span class="line"> <span class="attr">0</span>: <span class="string">len 3; hex 616161; asc aaa;;</span></span><br><span class="line"> <span class="attr">1</span>: <span class="string">len 4; hex 80001e9c; asc     ;;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">***</span> <span class="string">WE ROLL BACK TRANSACTION (2)</span></span><br></pre></td></tr></table></figure><p>可以看到，两个事务，分别持有了聚簇索引的锁与二级索引key1上的锁，导致死锁。</p><p>解决方案：可以先根据key1查询出主键，再根据主键去操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;背景：业务中采用先删除后插入的逻辑，开启了事务。&lt;/p&gt;
&lt;p&gt;表结构大概如下：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;</summary>
      
    
    
    
    <category term="mysql" scheme="https://c89757.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="https://c89757.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>JUC</title>
    <link href="https://c89757.github.io/2022/12/04/JUC/"/>
    <id>https://c89757.github.io/2022/12/04/JUC/</id>
    <published>2022-12-04T14:47:30.000Z</published>
    <updated>2022-12-04T15:15:03.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冯诺依曼计算机"><a href="#冯诺依曼计算机" class="headerlink" title="冯诺依曼计算机"></a>冯诺依曼计算机</h1><h2 id="计算机五大核心组成部分"><a href="#计算机五大核心组成部分" class="headerlink" title="计算机五大核心组成部分"></a>计算机五大核心组成部分</h2><ol><li>控制器(Control)：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。</li><li>运算器(Datapath)：运算器的功能是对数据进行各种算术运算和逻辑运算，即对数据进行加工处理。</li><li>存储器(Memory)：存储器的功能是存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。</li><li>输入(Input system)：输入设备是计算机的重要组成部分，输入设备与输出设备合你为外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。常见的输入设备有键盘、鼠标器、光电输入机、磁带机、磁盘机、光盘机等。</li><li>输出(Output system)：输出设备与输入设备同样是计算机的重要组成部分，它把外算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来。</li><li>微机常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。</li></ol><p>下图——冯诺依曼计算机模型图</p><p>上面的模型是一个理论的抽象简化模型，它的具体应用就是现代计算机当中的硬件结构设计：</p><p>在上图硬件结构中，最核心的两部分：CPU、内存</p><p>CPU内部结构</p><ul><li>控制单元</li><li>运算单元</li><li>数据单元</li></ul><p><strong>控制单元</strong></p><p>控制单元是整个CPU的指挥控制中心，由指令寄存器IR（Instructio Register)、指令译码器ID（Instruction Decoder)和操作控制器OD(Operation Controller)等组成。</p><p><strong>CPU缓存结构</strong></p><p>现在CPU为了提升执行效率， 减少CPU与内存的交互（交互影响CPU效率），一般在CPU上集成了多级缓存架构，常见的三级缓存结构</p><p>L1 Cache，分为数据缓存和指令缓存，逻辑核独占</p><p>L2 Cache，物理核独占，逻辑核共享</p><p>L3 Cache，所有物理核共享</p><img src="/2022/12/04/JUC/image-20220315205009112.png" class><br><br><p>存储器存储空间大小：内存 &gt; L3 &gt; L2 &gt; L1 &gt; 寄存器</p><p>存储器速度快慢排序：寄存器 &gt; L1 &gt; L2 &gt; L3 &gt; 内存</p><p>还有一点值得注意的是：缓存是由最小的存储区块——缓存行（cacheline）组成，缓存行大小通常为64byte</p><br><p><strong>什么是缓存行？</strong></p><pre><code>比如你的L1缓存大小为512kb，而cacheline = 64byte，那么L1里有512 * 1024 / 64 个cacheline</code></pre><br><p><strong>CPU读取存储器数据过程：</strong></p><blockquote><p>1、CPU要取寄存器X的值，只需要一步：直接读取</p><p>2、CPU要取L1 Cache的某个值，需要 1 - 3步（或者更多）: 把cache行锁住，把某个数据拿来，解锁</p><p>3、CPU要读取L2 Cache的某个值，先要到L1 Cache里取，L1当中不存在，在L2里，L2开始加锁，加锁以后，把</p><p>L2里的数据复制到L1，在执行读L1的过程，上面的三步再解锁</p><p>4、CPU取L3 Cache的也是一样，只不过先由L3复制到L2，L2复制到L1，从L1到CPU</p><p>5、CPU取内存则最复杂：通知内存控制器占用总线带宽，通知内存加锁，发起内存读请求，等待回应，回应数据保存在L3（如果没有就到L2），再从L3/L2到L1，再从L1到CPU，之后解除总线锁定</p></blockquote><br><p><strong>CPU为何要有高速缓存？</strong></p><pre><code>CPU在摩尔定律的指导下以每18月翻一番的速度在发展，然而内存和硬盘的发展速度远远不及CPU，这就造成了高性能的内存和硬盘价格及其昂贵。然而CPU的高度运算需要高速的数据。为了解决这个问题。CPU厂商在CPU中内置了少量的高速缓存以解决I\O速度和CPU运算之间的不匹配问题</code></pre><br><pre><code>在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理**时间局部性（Temporal Localit）**：如果一个信息项正在被访问，那么在近期它很有可能还会被再次访问。比如循环、递归、方法的反复调用等**空间局部性（Spatial Locality）**：如果一个存储器的位置被引用，那么将来它附近的位置也会被引用。比如顺序执行的代码，连续创建的两个对象，数组等。</code></pre><br><p>空间局部性——&gt; 并不仅仅取主内存访问x = 0 ,会把x = 0 的附近的位置也拿到L3 Cache中</p><br><p><strong>带有高速缓存的CPU执行计算的流程</strong></p><ol><li>程序以及数据被加载到主内存</li><li>指令和数据被加载到CPU的高速缓存</li><li>CPU执行指令，把结果写到高速缓存</li><li>高速缓存中的数据写回主内存</li></ol><h2 id="操作系统内存管理"><a href="#操作系统内存管理" class="headerlink" title="操作系统内存管理"></a>操作系统内存管理</h2><br><p><strong>执行空间保护</strong></p><p>操作系统有用户空间和内核空间两个概念，目的也是为了做到程序运行安全隔离与稳定</p><br><p>以32位操作系统4G大小内存空间为例</p><br><br><pre><code>Linux为内核代码和数据结构预留了几个页框，这些页永远不会被转出到磁盘上。从0x00000000到0xc000000(PAGE_OFFSET)的线性地址可由用户代码和内核代码进行引用（即用户空间）。从0xc0000000（PAGE_OFFSET）到 0xFFFFFFFFF的线性地址只能由内核代码进行访问（即内核空间）。内核代码及其数据结构都必须位于这1GB的地址空间中，但是对于此地址空间而言，更大的消费者是物理地址的虚拟应用这意味着在4GB的内存空间中，只有3GB可以用于用户应用程序。进程与线程只能运行在用户方式（usermode）或内核方式（kernelmode）下。用户程序运行在用户方式下，而系统调用运行在内核方式下。这两种方式下所用的堆栈不一样：用户方式下用的是一般的堆栈（用户空间的堆栈），而内核方式下用的是固定大小的堆栈（内核空间的堆栈，一般为一个内存页的大小），即每个进程与线程其实有两个堆栈，分别运行在用户态与内核态</code></pre><br><p>CPU调度的基本单位线程，也可以划分为：</p><p>1、内核线程模型（KLT)</p><p>2、用户线程模型（ULT）</p><p><strong>内核线程模型</strong></p><br><pre><code>**内核线程（KLT）**：系统内核管理线程（KLT），内核保存线程的状态和上下文信息，线程阻塞不会引起进程阻塞。在多处理器系统上，多线程在多处理器上并行运行。线程的创建、调度和管理由内核完成，效率比ULT更慢，比进程操作快</code></pre><br><p><strong>用户线程模型</strong></p><br><pre><code>    **用户线程（ULT）**：用户程序实现，不依赖操作系统核心，应用提供创建、同步、调度和管理线程的函数来控制用户线程。不需要用户态/内核态切换，速度快。内核对ULT无感知，线程阻塞则进程（包括它的所有线程）阻塞。</code></pre><br><p><strong>虚拟机指令集架构</strong></p><p>虚拟机指令集架构主要分为两种：</p><p>1、栈指令集架构</p><p>2、寄存器指令集架构</p><br><p><strong>栈指令集架构：</strong></p><ol><li>设计和实现更简单，适用于资源受限的系统</li><li>避开了寄存器的分配难题，使用零地址指令方式分配</li><li>指令流中的指令大部分是零地址指令,其执行过程依赖与操作栈,指令集更小,编译器容易实现;</li><li>不需要硬件支持,可移植性更好,更好实现跨平台</li></ol><br><p><strong>寄存器指令架构</strong></p><ol><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li>指令集架构则完全依赖硬件，可移植性差</li><li>性能优秀和执行更高效</li><li>花费更少的指令去完成一项操作</li><li>大部分情况下,基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主,而基于栈式架构的指令集却是以零地址指令为主</li></ol><br><h1 id="JMM模型"><a href="#JMM模型" class="headerlink" title="JMM模型"></a>JMM模型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><pre><code>    Java内存模型（Java Memory Model简称JMM）是一种抽象的概念，并不真实存在，它描述的是一组规则或规范；通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式            JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java 内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行；首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。</code></pre></blockquote><br><p><strong>JMM不同于JVM内存区域模型</strong></p><pre><code>JMM与JVM内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，==JMM是围绕原子性、有序性、可见性展开==。JMM与JVM内存区域唯一相似点，都存在共享数据区域和私有数据区域，在JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲应该包括程序计数器、虚拟机栈以及本地方法栈</code></pre><br><p>线程、工作内存、主内存工作交互图（基于JMM规范）:</p><br><br><p><strong>主内存</strong>：主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量（也称局部变量），当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发生线程安全问题</p><p><strong>工作内存</strong>：主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意：由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题</p><br><p>根据JVM虚拟机规范，主内存与工作内存的数据存储类型以及操作方式，对于一个实例对象中的成员方法而言，如果方法中包含本地变量是基本数据类型（boolean,byte,short,char,int,long,float,double)，将直接存储在工作内存的栈帧结构中，但堂托本地变量是引用类型，那么该变量的引用会存储在工作内存的栈帧中，而对象实例将存储在主内存（共享数据区域，堆）中。但对于实例对象的成员变量，不管它是基本数据类型或者包装类型（Integer、Double等）还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中实例对象可以被多个线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存模型如下图所示</p><br><br><h2 id="Java内存模型与硬件内存架构的关系"><a href="#Java内存模型与硬件内存架构的关系" class="headerlink" title="Java内存模型与硬件内存架构的关系"></a>Java内存模型与硬件内存架构的关系</h2><pre><code>通过对前面的硬件内存架构、Java内存模型以及Java多线程的实现原理的了解，我们应该已经意识到，多线程的执行最终都会映射到硬件处理器上进行执行，但Java内存模型和硬件内存架构并不完全一致。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响。因为JMM只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。(注意对于Java内存区域划分也是同样的道理)</code></pre><br><p><strong>JMM存在的必要性</strong></p><pre><code>假设主内存中存在一个共享变量x，现在有A和B两条线程分别对该变量x=1进行操作， A/B线程各自的工作内存中存在共享变量副本x。假设现在A线程想要修改x的值为2，而B线程却想要读取x的值，那么B线程读取到的值是A线程更新后的值2还是更新前的值1呢？答案是，不确定，即B线程有可能读取到A线程更新前的值1，也有可能读取到A线程更新后的值 2，这是因为工作内存是每个线程私有的数据区域，而线程A变量x时，首先是将变量从主内存拷贝到A线程的工作内存中，然后对变量进行操作，操作完成后再将变量x写回主内，而对于B线程的也是类似的，这样就有可能造成主内存与工作内存间数据存在一致性问题，假如A线程修改完后正在将数据写回主内存，而B线程此时正在读取主内存，即将x=1拷贝到自己的工作内存中，这样B线程读取到的值就是x=1，但如果A线程已将x=2写回主内存后，B线程才开始读取的话，那么此时B线程读取到的就是x=2，但到底是哪种情况先发生呢？</code></pre><pre><code>以上关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成</code></pre><br><p><strong>数据同步八大原子操作</strong></p><ol><li>lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态</li><li>unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li>read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li><li>use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</li><li>assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量</li><li>store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作</li><li>write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</li></ol><br><pre><code>如果要把一个变量从主内存复制到工作内存中，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步到主内存中，就需要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行</code></pre><br><p><br><br></p><br><p>同步规则分析</p><ol><li>不允许一个线程无原因的（没有发生过任何assign操作）把数据从工作内存同步回主内存中</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign)的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用变量之前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作)</li></ol><br><h2 id="并发编程的可见性、原子性与有序性问题"><a href="#并发编程的可见性、原子性与有序性问题" class="headerlink" title="并发编程的可见性、原子性与有序性问题"></a>并发编程的可见性、原子性与有序性问题</h2><p><strong>原子性</strong>指的是一个操作是不可中断的，即使在多线程环境下，一个操作一旦开始就不会被其他线程影响</p><blockquote><p>在java中，对基本数据类型的变量的读取和赋值操作是原子性操作有点要注意的是，对于32位系统的来说，long类型数据和double类型数据(对于基本数据类型， byte,short,int,float,boolean,char读写是原子操作)，它们的读写并非原子性的，也就是说如果存在两条线程同时对long类型或者double类型的数据进行读写是存在相互干扰的，因为对于32位虚拟机来说，每次原子读写是32位的，而long和double则是64位的存储单元，这样会导致一个线程在写时，操作完前32位的原子操作后，轮到B线程读取时，恰好只读取到了后32位的数据，这样可能会读取到一个既非原值又不是线程修改值的变量，它可能是“半个变量”的数值，即64位数据被两个线程分成了两次读取。但也不必太担心，因为读取到“半个变量”的情况比较少见，至少在目前的商用的虚拟机中，几乎都把64位的数据的读写操作作为原子操作来执行，因此对于这个问题不必太在意，知道这么回事即可。</p></blockquote><br><p><strong>可见性</strong>：</p><pre><code>可见性指的是当一个线程修改了某个共享变量的值，其他线程能否马上得知这个修改的值。对于串行程序来说，可见性是不存在的，因为我们在任何一个操作中修改了某个变量的值，后续的操作中都能读取到这个变量值，并且是修改过的新值但在多线程环境中可就不一定了，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了共享变量x的值，还未写回到主内存时，另外一个线程B又对主内存中同一个共享变量x进行操作，但此时A线程工作内存中变量x对线程B来说并不可见，这种工作内存与主内存同步延迟线现象就造成了可见性问题。另外指令重排及编译器优化也可能导致可见性问题</code></pre><br><p><strong>有序性</strong>：</p><pre><code>有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样的理解并没有毛病，毕竟对于单线程而言确实如此。但对于多线程环境下，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排，重排后的指令与原指令的顺序未必一致</code></pre><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Thread threadA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">while</span> (!flag) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot;的当前线程flag的状态改变&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;ThreadA&quot;</span>);</span><br><span class="line">threadA.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">Thread threadB = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot;refresh data...&quot;</span>);</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot;refresh data success&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;ThreadB&quot;</span>);</span><br><span class="line">threadB.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// threadA嗅探不到threadB对共享变量的修改，因为这里是空的死循环，空循环的优先级特别高，几乎不会让出CPU资源；如果在循环里执行一点操作，如打印一句话什么的，那么threadA是有可能嗅探到值的变化的，只是什么时候会感知到，这个不确定，而volatile能保证立马感知到</span></span><br></pre></td></tr></table></figure><br><p><strong>voloatile禁止重排优化</strong></p><pre><code>volatile关键字另一个作用就是禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象，voloatile禁止重排的关键在于内存屏障（Memory Barrier)</code></pre><br><p>硬件层的内存屏障</p><p>Intel硬件提供了一系列的内存屏障，主要有：</p><ol><li>Ifence,是一种Load Barrier读屏障</li><li>sfence，是一种Store Barrier写屏障</li><li>mfence，是一种全能型的屏障，具备lfence和sfence的能力</li><li>Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁，它后面可以跟ADD,ADC,AND,BTC等指令</li></ol><br><p>不同硬件实现内存屏障的方式不同，Java内存模型屏蔽了这种底层硬件平台的差异，由JVM来为不同的平台生成相应的机器码.JVM中提供了四类内存屏障指令：</p><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad</td><td>Load1；LoadLoad；Load2</td><td>保证Load1的读取操作在Load2及后续读取操作之前执行</td></tr><tr><td>StoreStore</td><td>Store1；StoreStore；Store2</td><td>在store2及其后的写操作执行前，保证store1的写操作</td></tr><tr><td>LoadStore</td><td>Load1；LoadStore；Store2</td><td>在Store2及其后的写操作执行前，保证load1的读操作已执行</td></tr><tr><td>StoreLoad</td><td>Stroe1；StoreLoad；Load2</td><td>保证Store1的写操作已刷新到主内存之后，Load2及其后</td></tr></tbody></table><br><blockquote><p>内存屏障，又叫内存栅栏，是一个CPU指令，它的作用有两个，==一个是保证特定操作的执行顺序，二是保证某些变量的内存可见性==（利用该特性实现volatile的内存可见性）</p></blockquote><br><p>由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用：是强制刷出各种CPU的缓存数据，因此任何CPU上的线程读取到这些数据的最新版本;总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化</p><br><h2 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h2><br><pre><code>前面提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型下图是JMM针对编译器制定的volatile重排序规则表</code></pre><br><table><thead><tr><th>第一个操作</th><th>第二个操作：普通读写</th><th>第二个操作：volatile读</th><th>第二个操作：volatile写</th></tr></thead><tbody><tr><td>普通读写</td><td>可以重排</td><td>可以重排</td><td>不可以重排</td></tr><tr><td>volatile读</td><td>不可以重排</td><td>不可以重排</td><td>不可以重排</td></tr><tr><td>volatile写</td><td>可以重排</td><td>不可以重排</td><td>不可以重排</td></tr></tbody></table><br><ol><li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后</li><li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前</li><li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序</li></ol><br><pre><code>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略</code></pre><ul><li><p>在每个volatile写操作的<strong>前面</strong>插入一个StoreStore屏障</p></li><li><p>在每个volatile写操作的<strong>后面</strong>插入一个StoreLoad屏障</p></li><li><p>在每个volatile读操作的<strong>后面</strong>插入一个LoadLoad屏障</p></li><li><p>在每个volatile读操作的<strong>后面</strong>插入一个LoadStore屏障</p></li></ul><p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p><p>下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图</p><br><h2 id="缓存一致性协议MESI"><a href="#缓存一致性协议MESI" class="headerlink" title="缓存一致性协议MESI"></a>缓存一致性协议MESI</h2><pre><code>多个CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致，不让系统数据混乱，就引出了个一致性的协议MESI</code></pre><br><p><strong>MESI协议缓存状态</strong></p><p>MESI是指4种状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是：</p><br><table><thead><tr><th>状态</th><th>描述</th><th>监听任务</th></tr></thead><tbody><tr><td>M修改（Modified）</td><td>该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中</td><td>缓存行必须时刻监听所有试图读该缓存行写回主存 并将状态变为S(共享）</td></tr><tr><td>E独享、互斥 （Exclusive）</td><td>该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中</td><td>缓存行也必须监听其它缓存读主存中变成S（共享）状态</td></tr><tr><td>S共享 （Shared）</td><td>该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中</td><td>缓存行也必须监听其它缓存使该缓存成无效（Invalid）</td></tr><tr><td>I 无效 （Invalid）</td><td>该Cache line无效</td><td>无</td></tr></tbody></table><br><p>==注意==：对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的，而S状态可能是非一致的。如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其他缓存不会广播他们作废掉该缓存行的通知，同样由于该缓存并没有保存该缓存行的copy数量，因此（即使有这样的通知）也没有办法确定自己是否已经独享了该缓存行。</p><pre><code>如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务</code></pre><br><p><strong>缓存行伪共享</strong></p><p>Cpu缓存系统中是以缓存行（cache line）为单位存储的。目前主流的CPU Cache的Cache Line大小都是64bytes.在多线程情况下，如果需要修改“共享在同一个缓存行的变量”，就会无意中影响彼此的性能，这就是伪共享</p><p>例如：现在有2个long型变量a,b ,</p><p>如果有t1在访问a, t2在访问b, 而a与b刚好在同一个cache line中，此时t1先修改a,将导致b被刷新</p><p>Java8中新增了一个注解：@sun.misc.Contended.加上这个注解的类会自动补齐缓存行，需要注意的是此注解默认是无效的，需要在jvm启动时设置-XX:RestrictContended才会生效</p><br><h2 id="MESI优化和他们引入的问题"><a href="#MESI优化和他们引入的问题" class="headerlink" title="MESI优化和他们引入的问题"></a><strong>MESI优化和他们引入的问题</strong></h2><br><pre><code>缓存的一致性消息传递是要时间的，这就使其切换时会产生延迟。当一个缓存被切换状态时，其他缓存收到消息完成各自的切换并且发出回应消息，这么一长串的时间中CPU都会等待所有缓存响应完成。可能出现的的阻塞都会导致各种各样的性能问题和稳定性问题</code></pre><br><p><strong>切换状态阻塞解决——CPU存储缓存（Store Bufferes）</strong></p><pre><code>比如你需要修改本地缓存的一条消息，那么你必须将I（无效）状态通知到其他拥有该缓存数据的CPU缓存中，并且等待确认，等待确认的过程会阻塞处理器，这会降低处理器性能。因为这个等待远远比上一个指令的执行时间长的多</code></pre><br><p><strong>Store Bufferes</strong></p><pre><code>为了避免这种CPU运算能力的浪费，Store Bufferes（存储缓存）被引入使用。处理器把它想要写入到主存的值，先写到存储缓存，然后继续去处理其他事情。当所有失效确认（Invalidate Acknowledge)都接收到时，数据才会最终被提交</code></pre><p>这样做有两个风险</p><br><p><strong>Store Bufferes的风险</strong></p><p>第一：就是处理器会尝试从存储缓存（Store buffer)中读取值，但它还没有进行提交。这个的解决方案称为Store Foewarding，它使得加载的时候，如果存储缓存中存在，则进行返回。</p><p>第二：保存什么时候会完成，这个并没有任何保证</p><br><p><strong>硬件内存模型</strong></p><p>执行失效也不是一个简单的操作，它需要处理器去处理。另外，存储缓存（Store Buffers）并不是无穷大的，所以处理器有时需要等待失效确认的返回。这两个操作都会使得性能大幅降低。为了应付这种情况，引入了失效队列。他们的约定如下：</p><ul><li> 对于所有的收到的Invalidate请求，Invalidate Acknowlege消息必须立刻发送</li><li> Invalidate并不真正执行，而是被放在一个特殊的队列中，在方便的时候才会去执行</li><li> 处理器不会发送任何消息给所处理的缓存条目，直到它处理Invalidate。即便是这样处理器已经不知道什么时候优化是允许的，而什么时候并不允许，干脆处理器将这个任务丢给了写代码的人。这就是内存屏障</li><li> 写屏障 Store Memory Barrier(a.k.a. ST, SMB, smp_wmb)是一条告诉处理器在执行这之后的指令之前，先执行所有已经在存储缓存（store buffer）中的保存的指令。</li><li> 读屏障Load Memory Barrier (a.k.a. LD, RMB, smp_rmb)是一条告诉处理器在执行任何的加载前，先执行所有已经在失效队列中的失效操作的指令。</li></ul><br><h1 id="Synchronized详解"><a href="#Synchronized详解" class="headerlink" title="Synchronized详解"></a>Synchronized详解</h1><br><h2 id="设计同步器的意义"><a href="#设计同步器的意义" class="headerlink" title="设计同步器的意义"></a>设计同步器的意义</h2><p>多线程编程中，有可能会出现多个线程同时访问同一个共享，可变资源的情况下，这个资源我么称之为临界资源；这种资源可能是：对象、变量、文件等</p><p>共享：资源可以由多个线程同时访问</p><p>可变：资源可以在其生命周期内被修改</p><p>由于线程执行的过程是不可控的，所以需要采用同步机制来协同对对象可变状态的访问</p><br><p>如何解决线程并发安全问题？</p><p>实际上，所有的并发模式在执行线程安全问题时，采用的方案都是序列化访问临界资源。即在同一时刻，只能有一个线程访问临界资源，也称作同步互斥访问</p><p>Java中，提供了两种方式来实现同步互斥访问：synchronized和lock同步器的本质就是加锁目的：序列化访问临界资源，即同一时刻只能有一个线程访问临界资源（同步互斥访问）不过有一点需要区别的是：当多个线程执行一个方法时，该方法内部的局部变量并不是临界资源，因为这些局部变量是在每个线程的私有栈中，因此不具有共享性，不会导致线程安全问题</p><br><h2 id="Synchronized原理详解"><a href="#Synchronized原理详解" class="headerlink" title="Synchronized原理详解"></a>Synchronized原理详解</h2><pre><code>synchronized内置锁是一种对象锁（锁的是对象而非引用），作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的</code></pre><br><p>加锁的方式：</p><p>同步实例方法，锁的是当前实例对象</p><p>同步类方法，锁的是当前类对象（class)</p><p>同步代码块，锁的是括号里面的对象</p><br><h2 id="Synchronized底层原理"><a href="#Synchronized底层原理" class="headerlink" title="Synchronized底层原理"></a>Synchronized底层原理</h2><pre><code>synchronized是基于JVM内置锁实现，通过内部对象Monitor(监视器锁）实现，基于进入与退出Monitor对象实现方法与代码块同步，监视器锁的实现依赖底层操作系统的Mutex lock(互斥锁）实现，它是一个重量级锁，性能较低。当然，JVM内置锁在1.5之后版本做了重大的优化，如锁粗化(Lock Coarsening),锁消除（Lock Elimination）,轻量级锁（Lightweight Locking)、偏向锁（Biased Locking)、适应性自旋（Adaptive Spinning)等技术来减少锁操作的开销，内置锁的并发性能已经基本与Lock持平。Synchronized关键字被编译成字节码后会被翻译成 monitorenter 和monitorexit 两条指令分别在同步块逻辑代码的起始位置与结束位置</code></pre><br><br><p>每个对象都有一个自己的Monitor（监视器锁）</p><br><p><strong>Monitor监视器锁</strong></p><pre><code>任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的Monitorenter和Monitorexit指令来实现。</code></pre><p><strong>monitorenter</strong>：每个对象都是一个监视器锁（Monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p><ul><li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者</li><li>如果该线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1</li><li>如果其他线程占有该monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权</li></ul><br><p><strong>monitorexit</strong>：<br>执行monitorexit的线程必须是object ref对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor,步再是这个monitor的所有者，其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权</p><br><p>Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p><br><p>看一个同步方法，例如：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>javap解析后</p><br><img src="/2022/12/04/JUC/typora-user-images\JMM并发编程\image-20220316144412780.png" alt="image-20220316144412780" style="zoom:150%;"><br><pre><code>从编译的结果来看，方法的同步 并没有 通过指令 monitorenter 和 monitorexit 来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED 标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个 monitor对象。两种不同方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间的来回切换，对性能有较大性能</code></pre><br><p><strong>什么是monitor？</strong></p><pre><code>可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的java对象是天生的Monitor，每一个Java对象都有称为Monitor的潜质，因为在java的设计中，每一个Java对象自打娘胎里出来就带了把看不见的锁，它叫做内置锁或者Monitor锁；也就是通常说的Synchronized的对象锁，MarkWord锁标识位为**10**，其中指针指向的是Monitor对象的起始位置；在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor()&#123;</span><br><span class="line">_header = <span class="literal">NULL</span>;</span><br><span class="line">_count = <span class="number">0</span>; <span class="comment">// 记录个数</span></span><br><span class="line">_waiters = <span class="number">0</span>,</span><br><span class="line">_recursions = <span class="number">0</span>;</span><br><span class="line">_object = <span class="literal">NULL</span>;</span><br><span class="line">_owner = <span class="literal">NULL</span>;</span><br><span class="line">_WaitSet = <span class="literal">NULL</span>; <span class="comment">// 处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">_WaitSetLock = <span class="number">0</span> ;</span><br><span class="line">_Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">_succ = <span class="literal">NULL</span> ;</span><br><span class="line">_cxq = <span class="literal">NULL</span> ;</span><br><span class="line">FreeNext = <span class="literal">NULL</span> ;</span><br><span class="line">_EntryList = <span class="literal">NULL</span> ; <span class="comment">// 处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">_SpinFreq = <span class="number">0</span> ;</span><br><span class="line">_SpinClock = <span class="number">0</span> ;</span><br><span class="line">OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code> ObjectMonitor中有两个队列，\_WaitSet 和 \_EntryList，用来保存ObjectWaiter对象列表（每个等待锁的线程都会被封装成ObjectWaiter对象）_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时</code></pre><ol><li>首先会进入_EntryList集合，当线程获取到对象的Monitor后，进入_Owner区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1</li><li>若线程调用wait方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入WaitSet集合中等待被唤醒</li><li>若当前线程执行完毕，也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁）；同时，Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向),synchronized锁便是通过这种方式获取锁的， 也是为什么java中任意对象可以作为锁的原因，同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用。</li></ol><p>监视器Monitor有两种同步方式：互斥与协作</p><p>多线程环境下线程之间如果需要共享数据，需要解决互斥访问数据的问题，监视器可以确保监视器上的数据在同一时刻只会有一个线程在访问。那么有个问题来了，我们知道synchronized加锁加在对象上，对象是如何记录锁状态的呢？答案是==锁状态是被记录在每个对象的对象头==（Mark Word）中，下面我们一起认识一下对象的内存布局</p><br><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><pre><code>HotSpot虚拟机中，对象在内存中存储的布局分为三块区域：对象头（Header)、示例数据（Instance Data）和对齐填充（Padding）</code></pre><br><br><p><strong>对象头</strong>：比如Hash码，对象GC存活年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度（数组对象）等。Java对象头一般占有2个机器码（ 在32位虚拟机中，1个机器码等于4字节，也就是32bit，在64位虚拟机中，1个机器码是8个字节，也就是64bit ）； 但是如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确定数组的大小，所以用一块来记录数组的长度</p><p><strong>实例数据：</strong>存放类的属性数据信息，包括父类的属性信息</p><p><strong>对齐填充：</strong>由于虚拟机要求对象起始地址必须是8字节的整数倍，填充数据不是必须存在的，仅仅是为了字节对齐</p><br><pre><code>HotSpot虚拟机的对象头包括两部分信息，第一部分是&quot;Mark Word&quot;，用于存储对象自身的运行时数据，如哈希码（HashCode），GC分代年龄、锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等等，它是实现轻量级锁和偏向锁的关键。这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别位32个和64个Bits，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。在32位的HotSpot虚拟机 中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示：</code></pre><br><p><strong>32位虚拟机</strong></p><br><br><p><strong>64位虚拟机</strong></p><br><p>现在的虚拟机基本上是64位的，而64位的对象头有点浪费空间，JVM默认会开启指针压缩，所以基本上也是按32位的形式记录对象头的。</p><p>手动设置: -XX:+UseCompressedOops</p><p>哪些信息会被压缩？</p><ol><li>对象的全局静态变量(即类属性)</li><li>对象头信息：64位平台下，原生对象头大小为16字节，压缩后为12字节</li><li>对象的引用类型：64位平台下，引用类型本身大小为8字节，压缩后为4字节</li><li>对象数组类型：64位平台下，数组类型本身大小为24字节，压缩后16字节</li></ol><br><p><strong>对象头分析工具</strong></p><br><p>分析工具JOL，它是OpenJDK开源工具包，maven坐标如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 打印markword</span></span><br><span class="line">System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>打印出来的对象内存信息如下：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line"><span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)  # 此处是Mark Word</span><br><span class="line"><span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"><span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)</span><br><span class="line"><span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure><br><p>第一行为Mark Word    00000001 00000000 00000000 00000000</p><p>会发现与上面的图对比，发现是轻量级锁状态，原因：</p><p><strong>大端模式和小端模式：</strong></p><p>所谓的【大端模式】，是指数据的【低位】保存在内存的【高地址】中，而数据的高位，保存在内存的低地址中；</p><p>所谓的【小端模式】，是指数据的【低位】保存在内存的【低地址】中，而数据的高位保存在内存的高地址中。（大部分的操作系统都是小端，而通讯协议是大端）</p><br><p>因为是小端模式，所以真正的bit位是——&gt;00000000  00000000 00000000  00000001，是无锁状态</p><br><p>然是无锁状态，前25位表示hashcode值，为什么hashcode是0？</p><blockquote><p>因为这个hashcode是jvm内置函数，类似于懒加载，此时还没有计算</p></blockquote><br><p>此时将代码修改为如下：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"><span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>打印的Mark Word为  00011000 11110111 00000010 00000010</p><p>即    00000010 00000010 11110111 00011000</p><p>发现对象头从无锁——&gt;轻量级锁</p><br><p>为什么不是偏向锁？</p><blockquote><p>因为JVM会延迟去启动偏向锁，JVM启动时依赖大量的hashMap class对象等，这些对象里面也存在大量的同步快，JVM启动时内部也会去启动十几个线程，这些线程内部也会存在竞争，JVM为了避免造成 偏向锁 到 轻量级锁 到重量级锁 这种锁升级过程，减少锁升级的开销，所以把偏向锁推迟启动</p></blockquote><br><p>把代码睡眠几秒钟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"><span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line"><span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line"><span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"><span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)</span><br><span class="line"><span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line"><span class="number">0</span>     <span class="number">4</span>        (object header)                           a8 f7 <span class="number">06</span> <span class="number">03</span> (<span class="number">10101000</span> <span class="number">11110111</span> <span class="number">00000110</span> <span class="number">00000011</span>) (<span class="number">50788264</span>)</span><br><span class="line"><span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line"><span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)</span><br><span class="line"><span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><p>第一次打印的：00000101 00000000 00000000 00000000  就已经是偏向锁状态了，但是偏向锁的前23bit位会记录线程ID，此处并没有，这种 称之为匿名偏向，可偏向状态</p><br><p>如果一直处于偏向状态，无法重偏向的话，那么MarkWord会一直记录最后一个偏向线程的状态</p><br><h2 id="锁的膨胀升级过程"><a href="#锁的膨胀升级过程" class="headerlink" title="锁的膨胀升级过程"></a>锁的膨胀升级过程</h2><br><pre><code>锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级到重量级锁，但是锁的升级是单向的，也就是只能从低到高升级，不会出现锁的降级。从JDK1.6中默认是开启偏向锁和轻量级的，可以通过-XX:-UseBiasedLocking来禁用偏向锁</code></pre><br><p><strong>偏向锁</strong>：</p><pre><code>偏向锁是Java6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁（会涉及到一些CAS操作，耗时）的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提高了程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</code></pre><p>默认开启偏向锁</p><p>开启偏向锁：-XX:+UseBiasedLocking  -XX:BiasedLockingStartupDelay=0</p><p>关闭偏向锁：-XX:-UseBiasedLocking</p><br><p><strong>轻量级锁：</strong></p><pre><code>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时，Mark Word的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</code></pre><br><p><strong>自旋锁：</strong></p><pre><code>    轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程就可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环（这也是称为自旋的原因），一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。后没办法也就只能升级为重量级锁</code></pre><br><p><strong>锁消除：</strong></p><pre><code>    消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间。锁消除的依据是逃逸分析的数据支持锁消除，前提是Java必须运行在server模式，（server模式会比client模式作更多的优化），同时必须开启逃逸分析</code></pre><p>-XX:+DoEscapeAnalysis 开启逃逸分析</p><p>-XX:+EliminateLocks  表示开启锁消除</p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ol><li>同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li><li>将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</li><li>分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中</li></ol><br><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><pre><code>Java并发编程核心在于java.concurrent.util包，而juc当中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取、共享获取等，而这个行为的抽象就是基于AbstractQueuedSychronizer简称AQS，AQS定义了一套多线程访问共享资源的同步器框架，是一个依赖状态（state）的同步器。</code></pre><br><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><pre><code>ReentrantLock是一种基于AQS框架的应用实现，是JDK中的一种线程并发访问的同步手段，它的功能类似于synchronized，是一种互斥锁，可以保证线程安全，而且它具有比sychronized更多的特性，比如它支持手动加锁与解锁，支持加锁的公平性</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>); <span class="comment">// false为非公平锁；true为公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>ReentrantLock如何实现sychronized不具备的公平与非公平性呢？</p><p>在ReentranLock内部定义了一个Sync的内部类，该类继承AbstractQueuedSynchronized，对该抽象类的部分方法做了实现；并且还定义了两个子类</p><p>1、FairSync公平锁的实现</p><p>2、NonfairSync非公平锁的实现</p><p>这两个类都继承自Sync，也就是间接继承了AbstractQueuedSynchronized，所以这一个ReentrantLock同时具备公平与非公平特性</p><p>上面设涉及的主要设计模式：模板模式-子类根据需要做具体业务实现</p><br><p>ReentrantLock默认是非公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>AQS具备特性</strong></p><p>阻塞等待队列共享/独占公平/非公平可重入</p><p>允许中断</p><p>除了Lock外，Java.concurrent.util当中同步器的实现Lock,Barrier,BlockingQueue等，都是基于AQS框架实现，一般通过定义内部类Sync继承AQS</p><p>将同步器所有调用都映射到Sync对应的方法</p><ul><li><p>ASQ内部维护属性volatile int state(32位)</p><p>  state表示资源的可用状态</p></li><li><p>State三种访问方式</p><p>  getState()、setState()、compareAndSetState()</p></li><li><p>AQS定义两种资源共享方式</p><p>  Exclusive-独占，只有一个线程能执行，如ReentrantLock</p><p>  Share-共享，多个线程可以同时执行，如Semaphore/CountDownLatch</p></li><li><p>AQS定义两种队列</p></li></ul><p>同步等待队列</p><p>条件等待队列</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源，只有用到condition才需要去实现它</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true,失败则返回false</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false</li><li>tryAcquireShare：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true,否则返回false</li></ul><br><p>AQS类中的内部类Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记结点为独占模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 在同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 后继结点的线程处于等待状态，而当前的结点如果释放了同步状态或者被取消，将会通知后继结点，使后继节点的线程得以运行</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 节点在等待队列中，节点的线程等待在Condition上，当其他线程对Condition调用了signal()方法后，</span></span><br><span class="line"><span class="comment">// 该节点会从等待等待中转移到同步队列中，加入到同步状态的获取中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">// 表示下一次共享式同步状态获取将会被无条件地传播下去</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 标记当前代结点的信号量状态（1，0，-1，-2，-3）</span></span><br><span class="line"><span class="comment">* 使用CAS更改状态，volatile保证线程可见性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>acquire方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">// arg = 1</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">//  这里如果线程是中断被唤醒的，会返回true，就会走下面的自我中断</span></span><br><span class="line">selfInterrupt();  <span class="comment">// 自我中断 为什么要自我中断呢？因为上面的acquireQueued（）方法返回true代表线程因为中断而唤醒的，但是我们不能直接杀死这个线程；在java以前的版本中，有个Thread.stop方法（现在已经过时）</span></span><br><span class="line"><span class="comment">// 当我们不需要这个线程继续工作时，进行调用，但是这个线程可能正工作一半，这样立即停止可能会出问题，所以就引出来了中断信号，我们可以在后面的代码中，去判断线程是否被中断，来采取措施，例如下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>我们可以自己在代码里进行判断中断信号，而进行优雅的线程退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"><span class="keyword">if</span>(Thread.interrupted())&#123;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">// 线程如果是被中断唤醒的话，不走下面的业务逻辑代码( 如果是中断唤醒，selfInterrupt()方法会打上中断标记)</span></span><br><span class="line"><span class="comment">// ps:Thread.interrupted()调用会擦除中断信号，所以需要在selfInterrupt()方法里重新打上标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 业务逻辑代码</span></span><br><span class="line">&#125;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>tryAcquire 方法</strong>：尝试获取资源；如果此时hasQueuedPredecessors()中已经有线程等待，则返回false;上一步就会走 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)方法。</p><p>addWaiter(Node.EXCLUSIVE) EXCLUSIVE表示独占模式</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123; <span class="comment">// acquires = 1</span></span><br><span class="line"><span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line"><span class="keyword">int</span> c = getState(); <span class="comment">// state状态，没被占用时状态为0</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 判断同步队列中是否有人等待</span></span><br><span class="line">compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//CAS 将state 修改为1</span></span><br><span class="line">setExclusiveOwnerThread(current); <span class="comment">// 设置当前线程为锁的拥有者</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前是锁的拥有者是自己</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"><span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line"><span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">setState(nextc);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>addWaiter方法</strong></p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode); <span class="comment">// new 一个Node节点，将模式设为独占模式，里面的thread属性设置为当前线程</span></span><br><span class="line"><span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">Node pred = tail; <span class="comment">// tail标记同步队列尾部节点</span></span><br><span class="line"><span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">node.prev = pred;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">pred.next = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enq(node); <span class="comment">// 自旋</span></span><br><span class="line"><span class="keyword">return</span> node; <span class="comment">//返回当前节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>enp(node)方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">Node t = tail;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 作者思想是，先初始化队列，头节点和尾节点指向一个 空Node,以免后续出现空指针，方便后续操作</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">tail = head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果尾部节点不为空，</span></span><br><span class="line">node.prev = t;   <span class="comment">// 将当前节点的前节点指向 尾部t所指向的节点（也就是最后一个节点）；（当前节点要变成尾节点）</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;  <span class="comment">// 然后cas将tail尾部指针 指向当前节点</span></span><br><span class="line">t.next = node;  <span class="comment">// 将之前旧的尾节点（变化之后现在是倒数第二个节点）的next属性指向当前node</span></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>**acquireQueued(addWaiter(Node.EXCLUSIVE), arg)**方法，尝试加入队列，addWaiter(Node.EXCLUSIVE)方法返回的是当前节点，</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 这一步获取当前的节点的前驱节点</span></span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 如果前驱节点是head,不会立马加入队列，会让你再次尝试去获取资源，避免阻塞影响性能</span></span><br><span class="line"><span class="comment">// 获取资源成功后</span></span><br><span class="line">setHead(node);   <span class="comment">// head = node;node.thread = null;node.prev = null; 将head头节点指向当前节点，并将当前节点变为空</span></span><br><span class="line">p.next = <span class="keyword">null</span>; <span class="comment">//  原先的头节点 指向断掉，下次GC回收 具体参考下图</span></span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> interrupted;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不能获取资源，阻塞等待唤醒</span></span><br><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">parkAndCheckInterrupt())</span><br><span class="line">interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>shouldParkAfterFailedAcquire()方法</strong></p><p>1、第一次循环时会去修改前驱节点的waitStatus= -1， 返回false;</p><p>2、第二次循环，前驱节点已经修改为-1，返回true时，才会走上面的parkAndCheckInterrupt()方法</p><blockquote><p> if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</p></blockquote><br><p>waitStatus控制的是下一个节点</p><p>用前驱节点记录有什么好处？</p><blockquote><p> 当前节点唤醒获取资源后，head指针指向当前Node节点（此时Node节点里thread记录的线程为空）waitState也是0，不需要判断waitState状态,每次都会去修改waitState状态为-1，保证可以唤醒，因为waitState信号量可能为会变（-3）</p></blockquote><br><p>waitState节点的生命状态：信号量</p><blockquote><p>SIGNAL = -1 //可被唤醒</p><p>CANCELLED = 1 // 代表出现异常，中断引起的，需要废弃结束</p><p>CONDITION = -2 // 条件等待</p><p>PROPAGATE = -3 // 传播</p><p>0 — 初始状态Init状态</p></blockquote><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">// 判断前驱节点的waitStatus； waitStatus初始状态都是0</span></span><br><span class="line"><span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">// Node.SIGNAL = -1</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">node.prev = pred = pred.prev;</span><br><span class="line">&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">pred.next = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class="comment">// waitStatus=0；所以会走这里，将前驱节点的waitStatus状态改为SIGNAL -1；-1代表可被唤醒</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>waitStatus=0 –&gt; -1 , head节点为什么改到-1，因为持有锁的线程T0在释放锁的时候，会判断head节点的waitStatus是否 !=0 ,如果不等于0，会将head节点的waitStatus改成0；要想唤醒正在排队的第一个线程T1，T1被唤醒后再走acquireQueued（）方法中的循环，再去判断前驱节点是否是头节点，再去拿锁（如果是非公平锁，抢锁是可能失败的）</p><p>if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</p><pre><code>     parkAndCheckInterrupt())            interrupted = true;</code></pre><p>的parkAndCheckInterrupt（）方法</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LockSupport.park(<span class="keyword">this</span>) <span class="comment">// 调用LockSupport的park方法阻塞线程</span></span><br><span class="line"><span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 线程是否被中断，如果线程走到这里是因为中断唤醒的，会返回true,也就是返回线程里的中断信号； 注意： Thread.interrupted()调用会擦除中断信号，所以需要在外面acquires方法里调用selfInterrupt()重新打上中断信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>LockSupport.park阻塞线程(会进入waiting等待状态)。唤醒有两种方式，一种是ReentrantLock里的unlock方法里面，会调用LockSupport.unpark方法唤醒</p><p>另一种就是线程被中断唤醒</p><br><p>Reentrantlock还有一个lockInterruptibly（）方法，跟lock一样能起到同样的效果，只是会抛出编译性异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) <span class="comment">// 一样的尝试获取资源</span></span><br><span class="line">doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>doAcquireInterruptibly(arg)方法</p><p>跟lock里面的逻辑几乎一模一样。只是再parkAndCheckInterrupt()方法里如果是被中断唤醒的，会抛出异常;</p><p>最后走finally的时候呢，failed为true，会走cancelAcquire(node)方法，会在此方法里面将Node节点</p><p>waitStatus改成CANCELLED（也就是1）</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">setHead(node);</span><br><span class="line">p.next = <span class="keyword">null</span>;</span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">parkAndCheckInterrupt())</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><br><br></p><h2 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a><strong>阻塞队列BlockingQueue</strong></h2><pre><code>blockQueue的特性是任意时刻只有一个线程可以进行take或者put操作，并且BlockQueue提供了超时return null的机制，在许多生产场景里都可以看到这个这个工具的身影线程通信的一个工具，在任意时刻，不管并发有多高，在单JVM上，同一时间永远都只有都只有一个线程能够对队列进行入队或者出队操作</code></pre><br><p><strong>队列类型</strong></p><p>1、无限队列（unbounded queue）- 几乎可以无限增长</p><p>2、有限队列（bounded queue）- 定义了最大容量</p><br><p><strong>队列数据结构</strong></p><p>队列实质就是一种存储数据的结构，通常用链表或者数组实现</p><p>一般而言队列具备FIFO先进先出的特性，当然也有双端队列（Deque）优先级队列</p><p>主要操作：入队（EnQueue）与出队（Dequeue)</p><br><br><p>常见的四种阻塞队列</p><ul><li>ArrayBlockingQueue 由数组支持的有界队列</li><li>LinkedBlockingQueue由链接节点支持的可选有界队列</li><li>PriorityBlockingQueue由优先级堆支持的无界优先级队列</li><li>DelayQueue由优先级堆支持的，基于时间的调度队列</li></ul><br><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a><strong>ArrayBlockingQueue</strong></h2><br><p>new ArrayBlockingQueue&lt;&gt;(10);</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"><span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">lock = <span class="keyword">new</span> ReentrantLock(fair); <span class="comment">// 创建一把锁</span></span><br><span class="line">notEmpty = lock.newCondition(); <span class="comment">// 条件对象</span></span><br><span class="line">notFull =  lock.newCondition(); <span class="comment">// 条件对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">checkNotNull(e);</span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">lock.lockInterruptibly();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (count == items.length) <span class="comment">// 队列满了</span></span><br><span class="line">notFull.await();       <span class="comment">// 释放锁</span></span><br><span class="line">enqueue(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>notFull.await()方法</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Thread.interrupted())  <span class="comment">// 线程被中断,直接抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">Node node = addConditionWaiter(); <span class="comment">// 加入条件等待队列</span></span><br><span class="line"><span class="keyword">int</span> savedState = fullyRelease(node); <span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">interruptMode = REINTERRUPT;</span><br><span class="line"><span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">unlinkCancelledWaiters();</span><br><span class="line"><span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><p>addConditionWaiter()方法</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node t = lastWaiter;</span><br><span class="line"><span class="comment">// If lastWaiter is cancelled, clean out.  判断是不是无效的队列</span></span><br><span class="line"><span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">unlinkCancelledWaiters();</span><br><span class="line">t = lastWaiter;</span><br><span class="line">&#125;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">firstWaiter = node;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">t.nextWaiter = node;</span><br><span class="line">lastWaiter = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>fullyRelease(node)方法</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> savedState = getState();  <span class="comment">// 获取锁的信号量</span></span><br><span class="line"><span class="keyword">if</span> (release(savedState)) &#123;<span class="comment">// 释放锁</span></span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> savedState;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)</span><br><span class="line">node.waitStatus = Node.CANCELLED;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><pre><code>从字面意思是信号量的意思，它的作用是控制访问特定资源的线程数目，底层依赖AQS的状态state</code></pre><br><h3 id="怎么使用Semaphore"><a href="#怎么使用Semaphore" class="headerlink" title="怎么使用Semaphore"></a>怎么使用Semaphore</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">// state会初始化为5，相当于总的容量池子</span></span><br><span class="line">....</span><br><span class="line">semaphore.acquire(<span class="number">1</span>); <span class="comment">// 从总的池子里拿出一个凭据 state - 1</span></span><br><span class="line">....</span><br><span class="line">semaphore.release(<span class="number">1</span>); <span class="comment">// 将凭据还回总的池子 state  + 1</span></span><br><span class="line"></span><br><span class="line">semaphore.acquire(<span class="number">1</span>);  支持中断式的，如果线程被中断，会抛出异常；semaphore.acquireUninterruptibly()就不会</span><br><span class="line">如果获取信号量之后的逻辑代码执行时间过长，导致其他线程长时间阻塞，消耗资源</span><br><span class="line"></span><br><span class="line">semaphore.tryAcquire(<span class="number">500</span>,TimeUnit.SECONDS);  <span class="comment">// 尝试获取资源并且允许的最大等待时间</span></span><br><span class="line"><span class="keyword">if</span> (semaphore.tryAcquire(<span class="number">500</span>, TimeUnit.MILLISECONDS)) &#123;<span class="comment">// 尝试去获取信号量 ，最长等待500ms</span></span><br><span class="line">System.out.println(Thread.currentThread().getContextClassLoader() + <span class="string">&quot; acquire() at time : &quot;</span> + System.currentTimeMillis());</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">semaphore.release();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 或者返回托底数据</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;获取资源超时&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>源码剖析</strong></p><br><p>Semaphore类中结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>调用new Semaphore(2)时；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">sync = <span class="keyword">new</span> NonfairSync(permits); <span class="comment">// 默认非公平锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  boolean fair 为 true时为公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终会将AQS中的state设置为2</p><br><p>前景：假设两个信号量都被人取完，此时state = 0</p><br><p>再然后我们调用**semaphore.acquire()**时 （ps:以下基于公平锁）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>); <span class="comment">// 默认传1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(); <span class="comment">// 线程如果中断，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)  <span class="comment">// 尝试获取信号量</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg); <span class="comment">// 如果tryAcquireShared返回-1， 会走到下面的2、doAcquireSharedInterruptibly(int arg)方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>1、tryAcquireShared(arg)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123; <span class="comment">// acquires = 1</span></span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors()) <span class="comment">// 判断CLH队列中是否有元素</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 如果已经有人在排队了，直接返回false</span></span><br><span class="line">        <span class="keyword">int</span> available = getState(); <span class="comment">// 获取AQS中的state</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> || <span class="comment">// 基于上面的场景的话，这里为true,返回-1</span></span><br><span class="line">            compareAndSetState(available, remaining)) <span class="comment">// CAS操作修改state的值，修改失败会自旋</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>2、doAcquireSharedInterruptibly(int arg)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="comment">// 加入CLH队列，共享模式的节点</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>; <span class="comment">// failed初始值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123; <span class="comment">// 如果当前节点的前驱节点是头节点</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg); <span class="comment">// 会再次尝试下获取资源</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 如果获取到资源了</span></span><br><span class="line">                        setHeadAndPropagate(node, r); <span class="comment">// 设置头节点，即下面的 setHeadAndPropagate方法</span></span><br><span class="line">                        p.next = <span class="keyword">null</span>;  <span class="comment">// 原先p指向的头节点的指针，可以断开GC了</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 如果当前节点的前驱节点 不是头节点，那么会去修改前驱节点的waitState = -1</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                        parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><p>那么此时有两种情况</p><p>第一，当前节点加入队列时，是头节点，并且获取资源成功</p><p>第二，当前节点加入队列时，前面已经有人入队了，或者获取资源失败，那么会尝试阻塞自己</p><p>我们先看第二种情况，节点入队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">parkAndCheckInterrupt())</span><br></pre></td></tr></table></figure><ul><li>shouldParkAfterFailedAcquire()方法</li></ul><p>总的来说，此方法是为了修改前驱节点的waitStatus为SIGNAL， 如果前驱节点的waitStatus已经是Signal,返回true;</p><p>值得注意的是，如果要加入队列，那么上面的doAcquireSharedInterruptibly方法的自旋会走两遍，第一遍循环执行完此方法后，修改前驱节点状态，第二次循环才返回true,然后才会走parkAndCheckInterrupt()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">// ！！！调用 LockSupport.park方法将自己阻塞在这里</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123; <span class="comment">// pred 当前节点的前驱节点，node为当前节点</span></span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">// 获取前驱节点的waitStatus （节点创建时waitStatus默认都为0）</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class="comment">// cas去修改前驱节点的waitStatus为SINGAL，即-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么接下来我们看第一种情况，线程发现自己的前驱节点就是头节点，并且尝试获取资源成功了（比如此时有线程归还了信号量，AQS中state由0 ——&gt; 1）</p><p>那么就会走下面的setHeadAndPropagate方法</p><blockquote><p>final Node p = node.predecessor();<br>if (p == head) {<br>int r = tryAcquireShared(arg);<br>if (r &gt;= 0) {<br>    setHeadAndPropagate(node, r);<br>     p.next = null;<br>     failed = false;<br>     return;<br>}<br>}</p></blockquote><ul><li> setHeadAndPropagate方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123; <span class="comment">// node为当前节点，propagate &gt; 1;此处场景下为1</span></span><br><span class="line">    Node h = head; <span class="comment">// h指向旧的头节点</span></span><br><span class="line">    setHead(node); <span class="comment">// 设置当前节点为新的头节点</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> || <span class="comment">// propagate=  1 &gt; 0 ,走下面的逻辑</span></span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next; <span class="comment">// 获取当前节点的下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared()) <span class="comment">// 如果此时后面有新的节点加进来了，走doReleaseShared</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head; <span class="comment">// 获取头节点（此种情况下，头节点就是当前节点，因为上面已经修改过了)</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus; <span class="comment">// 获取头节点waitStatus</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">// 如果waitStatus状态是SIGNAL即-1</span></span><br><span class="line">                <span class="comment">// (注意！！新加进来的节点都会去修改前节点的waitStatus为SIGNAL，即上面说的第二种情况的shouldParkAfterFailedAcquire方法)</span></span><br><span class="line">                <span class="comment">// 所以这里的情况ws == Node.SIGNAL为真</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>)) <span class="comment">// CAS去修改h指向的头节点的waitStatus为0</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h); <span class="comment">// 如果修改成功了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)  <span class="comment">// 在某一个线程执行上面方法时，可能会有别的线程加进来，导致头节点变更</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;  <span class="comment">// node 即为上面h所指向的头节点</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus; <span class="comment">// 此时waitStatus被CAS修改为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next; <span class="comment">// 获取当前节点的下一节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) <span class="comment">// 如果下一节点不为空，唤醒它</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">// ！！！如果下一节点阻塞在这里，会被唤醒接着进行自旋</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li> <strong>semaphore.release()</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>); <span class="comment">// 默认释放1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">// arg = 1</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123; <span class="comment">// 成功释放返回true</span></span><br><span class="line">        doReleaseShared(); <span class="comment">// 走下面的doReleaseShared()方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> tryReleaseShared(arg)方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState(); <span class="comment">// 获取AQS中的state</span></span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// CAS将信号量还回去</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>doReleaseShared()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">就是上面semaphore.acquire()里面setHeadAndPropagate设置头节点所调用的方法</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeeDoctorTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeeDoctorTask</span><span class="params">(CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;开始看医生&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            log.info(<span class="string">&quot;看医生结束，准备离开病房&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (countDownLatch != <span class="keyword">null</span>)&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SeeDoctorTask(countDownLatch));</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SeeDoctorTask(countDownLatch));</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    log.info(<span class="string">&quot;等待countDownLatch归0&quot;</span>);</span><br><span class="line">    countDownLatch.await(); <span class="comment">// 主线程会阻塞等待，直到上面线程执行完</span></span><br><span class="line">    log.info(<span class="string">&quot;结束.....&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier-栅栏"><a href="#CyclicBarrier-栅栏" class="headerlink" title="CyclicBarrier 栅栏"></a>CyclicBarrier 栅栏</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrierRunner</span><span class="params">(CyclicBarrier cyclicBarrier, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;index - &quot;</span> + index);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e)  &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> BrokenBarrierException, InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">10</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;所有线程执行完毕....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CyclicBarrierRunner(cyclicBarrier,i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ===========上面十个线程冲破栅栏后，会打印&lt;所有线程执行完毕&gt;===========</span></span><br><span class="line">        cyclicBarrier.await(); <span class="comment">// 主线程也算一个</span></span><br><span class="line">        <span class="comment">// ====  如果没有下面的九个线程，那么会一直阻塞，cyclicBarrier可以反复使用==== </span></span><br><span class="line">        System.out.println(<span class="string">&quot;全部到达栅栏&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CyclicBarrierRunner(cyclicBarrier,i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Atomic-amp-Unsafe魔法类详解"><a href="#Atomic-amp-Unsafe魔法类详解" class="headerlink" title="Atomic&amp;Unsafe魔法类详解"></a>Atomic&amp;Unsafe魔法类详解</h2><ul><li><strong>原子操作</strong></li></ul><p>原子（atom)本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation)意为“不可被中断的一个或一系列操作”。</p><p>相关术语</p><table><thead><tr><th>术语名称</th><th>英文</th><th>解释</th></tr></thead><tbody><tr><td>缓存行</td><td>Cache line</td><td>缓存的最小操作单位</td></tr><tr><td>比较并交换</td><td>Compare and Swap</td><td>CAS操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较是否发生变化，如果没有发生变化，才交换成新值，发生</td></tr><tr><td>CPU流水线</td><td>CPU   pipeline</td><td>CPU流水线的工作方式就象工业生产上的装配流水线，在CPU中由5<del>6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5</del>6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期 完成一条指令，因此提高CPU的运算速度。</td></tr><tr><td>内存顺序冲突</td><td>Memory order violation</td><td>内存顺序冲突一般是由假共享引起，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效</td></tr></tbody></table><p><strong>处理器如何实现原子操作</strong></p><p>32位处理器使用<strong>基于对缓存加锁或总线加锁</strong>的方式来实现多处理器之间的原子操作。</p><p><strong>处理器自动保证基本内存操作的原子性</strong></p><p>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。奔腾6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p><p><strong>使用总线锁保证原子性</strong></p><p>第一个机制是通过总线锁保证原子性。如果多个处理器同时对共享变量进行读改写（i++就是经典的读改写操作）操作，那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致</p><p>例子：如果i=1,我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2。如下图</p><p>原因是有可能多个处理器同时从各自的缓存行中读取变量i,分别进行加1操作，然后分别写入系统内存当中。那么想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存</p><p>处理器使用总线锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求要求将被阻塞住,那么该处理器可以独占使用共享内存</p><p><strong>使用缓存锁保证原子性</strong></p><pre><code>第二个机制就是通过缓存锁定保证原子性。在同一时刻我们只需保证对某个内存地址的操作是原子性的即可，但总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，最近的处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。频繁使用的内存会缓存在处理器的L1,L2和L3高速缓存里，那么原子操作就可以直接在处理器内存缓存中进行，并不需要声明总线锁。在奔腾6和最近的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。所谓“缓存锁定”就是如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效，在上述例子中，当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。但是有两种情况下处理器不会使用缓存锁定。第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行，则处理器会调用总线锁定。第二种情况是：有些处理器不支持缓存锁定。</code></pre><p>以上两个机制我们可以通过Inter处理器提供了很多Lock前缀的指令来实现。比如位测试和修改指令BTS，BTR，BTC，交换指令XADD，CMPXCHG和其他一些操作数和逻辑指令，比如ADD(加），OR(或）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问他</p><p><strong>Java当中如何实现原子操作</strong></p><p>在Java中可以通过锁和循环CAS的方式来实现原子操作</p><p>JVM中的CAS操作正式利用了上文中提到的处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环CAS操作直到操作成功为止。</p><h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><pre><code>在Atomic包里一共有12个类，四种原子更新方式，分别是原子更新基本类型，原子更新数组，原子更新数组，原子更新引用和原子更新字段。Atomic包里的类基本都是使用Unsafe实现的包装类</code></pre><p>基本类：AtomicInteger，AtomicLong，AtomicBoolean;</p><p>引用类型：AtomicReferernce、AtomicReference的ABA实例、AtomicStampedRerence、AtomicMarkableReference；</p><p>数组类型：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p><p>属性原子修改器（Updater）：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater</p><p>atomic底层实现是基于Unsafe提供的三大cas-api完成；而Unsafe基于硬件原语-CMPXCHG实现原子操作cas</p><ul><li>compareAndSwapObject</li><li>compareAndSwapInt</li><li>compareAndSwapLong</li></ul><p>AtomicInteger的getAndIncrement()方法分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2); <span class="comment">// 读取AtomicInteger里的value值（AtomicInteger有个value属性）</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="comment">// var1 -- AtomicInteger</span></span><br><span class="line">    <span class="comment">// var2 -- valueOffset  value属性在对象内存当中的偏移量</span></span><br><span class="line">    <span class="comment">// var3 -- oldValue</span></span><br><span class="line">    <span class="comment">// var5 + var4 -- oldValue + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CAS的ABA问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestABA</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">countDownLatch.countDown();</span><br><span class="line"><span class="keyword">int</span> a = atomicInteger.get();</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot;操作前的数值&quot;</span>+a);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> res = atomicInteger.compareAndSet(a, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (res)&#123;</span><br><span class="line">log.info(Thread.currentThread().getName()+ <span class="string">&quot; cas操作后的数值 &quot;</span>+atomicInteger.get());</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">log.info(<span class="string">&quot;修改失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">countDownLatch.countDown();</span><br><span class="line">atomicInteger.incrementAndGet();</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot; increase后的值 &quot;</span>+ atomicInteger.get());</span><br><span class="line"><span class="keyword">int</span> j = atomicInteger.decrementAndGet();</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot; decrease后的值 &quot;</span>+ atomicInteger.get());</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">countDownLatch.await();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么解决ABA问题？</p><p>加上版本号 。A（0）- B（1）- A（2）</p><p>如果关注过程，就可以用AtomicStampedReference，AtomicStampedReference接口有一个版本号参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABASloution</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference =</span><br><span class="line"><span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">int</span> stamp = atomicStampedReference.getStamp(); <span class="comment">// 获取当前标识</span></span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot; stamp = &quot;</span> + stamp + <span class="string">&quot; 初始值 = &quot;</span> + atomicStampedReference.getReference() );</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> b = atomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">2</span>,stamp,++stamp);</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot; stamp = &quot;</span> + stamp + <span class="string">&quot; cas操作结果: &quot;</span> + b);</span><br><span class="line"></span><br><span class="line">&#125;,<span class="string">&quot;t0&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread( () -&gt; &#123;</span><br><span class="line"><span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">atomicStampedReference.compareAndSet(<span class="number">1</span>,<span class="number">2</span>,stamp,++stamp);</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot; stamp = &quot;</span> + atomicStampedReference.getStamp() +</span><br><span class="line"><span class="string">&quot; increment 值: &quot;</span> + atomicStampedReference.getReference());</span><br><span class="line">stamp = atomicStampedReference.getStamp();</span><br><span class="line">atomicStampedReference.compareAndSet(<span class="number">2</span>,<span class="number">1</span>,stamp,++stamp);</span><br><span class="line">log.info(Thread.currentThread().getName() + <span class="string">&quot; stamp = &quot;</span> + atomicStampedReference.getStamp() +</span><br><span class="line"><span class="string">&quot; decrease 值: &quot;</span> + atomicStampedReference.getReference());</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">System.in.read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unsafe应用解析"><a href="#Unsafe应用解析" class="headerlink" title="Unsafe应用解析"></a>Unsafe应用解析</h3><pre><code>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。Unsafe类为一单例实现，提供静态方法getUnsafge获取Unsaefe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，否则抛出SecurityException异常</code></pre><p><strong>如何获取Unsafe实例？</strong></p><p>1、从getUnsafe方法的使用限制条件出发，通过Java命令 -Xbootclasspath/a 把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得该类A被 引导类加载器加载，从而通过Unsafe.getUnsafe方法安全的获取Unsafe实例</p><blockquote><p>java ­Xbootclasspath/a:${path}         // 其中path为调用Unsafe相关方法的类所在jar包路径</p></blockquote><p>2、通过反射获取单例对象theUnsafe</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">reflectGetUnsafe</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Class&lt;Unsafe&gt; unsafeClass = Unsafe.class;</span><br><span class="line">Field theUnsafe = unsafeClass.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span> (Unsafe)theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Unsafe功能介绍</strong></p><pre><code>unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类</code></pre><br><br><h4 id="1、内存操作"><a href="#1、内存操作" class="headerlink" title="1、内存操作"></a>1、内存操作</h4><p>这部分主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法</p><ul><li>分配内存, 相当于C++的malloc函数 public native long allocateMemory(long bytes);</li><li>扩充内存 public native long reallocateMemory(long address, long bytes);</li><li>释放内存 public native void freeMemory(long address);</li><li>在给定的内存块中设置值 public native void setMemory(Object o, long offset, long bytes, byte value);</li><li>内存拷贝 public native void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);</li><li>获取给定地址值，忽略修饰限定符的访问限制。与此类似操作还有: getInt，getDouble，getLong，getChar等 public native Object getObject(Object o, long offset);</li><li>为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有:putInt,putDouble，putLong，putChar等 public native void putObject(Object o, long offset, Object x); public native byte getByte(long address);</li><li>为给定地址设置byte类型的值（当且仅当该内存地址为allocateMemory分配 时，此方法结果才是确定的） public native void putByte(long address, byte x);</li></ul><br><p>通常我们在Java中创建的对象都处于堆内内存（heap)中，堆内内存是由JVM所掌控的Java进程内存，并且他遵循JVM的内存管理机制，JVM采用垃圾回收机制统一管理堆内存。与之相对的是堆外内存，存在于JVM管控之外的内存区域，Java中对堆外内存的操作，依赖于Unsafe提供的操作堆外内存的native方法</p><br><p><strong>使用堆外内存的原因</strong></p><ol><li>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在GC时减少回收停顿对于应用的影响</li><li>提升程序I/O操作的性能。通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存</li></ol><br><p><strong>典型应用</strong></p><pre><code>DirectByteBuffer是Java用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在Netty,MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外，使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。DirectByteBuffer构造函数、创建DirectBuffer的时候，通过Unsafe.allocateMemory分配内存、Unsafe.setMemory进行内存初始化，而后构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，分配的堆外内存一起被释放</code></pre><img src="/2022/12/04/JUC/typora-user-images\JMM并发编程\image-20220316164537308.png" alt="image-20220316164537308" style="zoom:150%;"><br><h4 id="2、线程调度"><a href="#2、线程调度" class="headerlink" title="2、线程调度"></a><strong>2、线程调度</strong></h4><p>包括线程挂起、恢复、锁机制等方法</p><p>// 取消阻塞线程</p><p>public native void unpark(Object thread);</p><p>// 阻塞线程</p><p>public native void park(boolean isAbsolute,long time);</p><p>//获得对象锁（可重入）</p><p>@Deprecated</p><p>public native void monitorEnter(Object o);</p><p>//释放对象锁</p><p>@Deprecated</p><p>public native void monitorExit(Object o);</p><p>//尝试获取对象锁</p><p>@Deprecated</p><p>public native boolean tryMonitorEnter(Object o);</p><p>方法park，unpark即可实现线程的挂起与恢复，将一个线程进行挂起是通过park方法实现的，调用park方法后，线程将一直阻塞直到超时或者中断等条件出现；</p><p>unpark可以终止一个挂起的线程，使其恢复正常</p><br><h4 id="3、内存屏障"><a href="#3、内存屏障" class="headerlink" title="3、内存屏障"></a>3、内存屏障</h4><p>在Java 8中引入，用于定义内存屏障（也叫内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才开始执行此点之后的操作），避免代码重排序</p><br><p>// 内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</p><p>public native void loadFence();</p><br><p>// 内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</p><p>public native void storeFence();</p><br><p>//内存屏障，禁止load，store操作重排序</p><p>public  void fullFence();</p><br><p><strong>典型应用</strong></p><pre><code>在Java8中引入了一种锁的新机制——StampedLock，它可以看成是读写锁的一个改进版本。StampedLock提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程”饥饿“现象由于StampedLock提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存load到线程工作内存时，会存在数据不一致问题，所以当使用StampedLock的乐观读锁时，需要遵从如下图用例中使用的模式来确保数据的一致性</code></pre><br><p>如上图用例所示计算坐标点Point对象，包含点移动方法move及计算此点到原点的距离的方法distanceFromOrigin。在方法distanceFromOrigin中，首先，通过 tryOptimisticRead方法获取乐观读标记；然后从主内存中加载点的坐标值 (x,y)；而后通过</p><p>StampedLock的validate方法校验锁状态，判断坐标点(x,y)从主内存加载到线程工作内存过程中，主内存的值是否已被其他线程通过move方法修改，如果validate返回值为true，证明(x, y)的值未被修改，可参与后续计算；否则，需加悲观读锁，再次从主内存加载(x,y)</p><p>的  新值，然后再进行距离计算。其中，校验锁状态这步操作至关重要，需要判断锁状态是否发生改变，从而判断之前copy到线程工作内存中的值是否与主内存的值存在不一致。</p><br><h2 id="Collections之Map-amp-List-amp-Set"><a href="#Collections之Map-amp-List-amp-Set" class="headerlink" title="Collections之Map&amp;List&amp;Set"></a>Collections之Map&amp;List&amp;Set</h2><br><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>数据结构</p><p>数组+链表（红黑树JDK&gt;=8)</p><p><strong>源码分析</strong></p><p>重要成员变量</p><ul><li>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // hash表默认初始容量</li><li>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // hash表</li><li>static final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认的加载因子</li><li>static final int TREEIFY_THRESHOLD = 8; // 链表转红黑树阈值</li><li>static final int UNTREEIFY_THRESHOLD = 6; // 红黑树转链表阈值</li><li>static final int MIN_TREEIFY_CAPACITY = 64; // 链表转红黑树时hash表最小容量阈值，达不到优先扩容</li></ul><p>HashMap时线程不安全的，不安全的具体原因就是在高并发场景下，扩容可能产生死锁（jdk1.7存在）以及get操作可能带来的数据丢失</p><br><h4 id="Jdk7——扩容死锁分析"><a href="#Jdk7——扩容死锁分析" class="headerlink" title="Jdk7——扩容死锁分析"></a><strong>Jdk7——扩容死锁分析</strong></h4><p>死锁问题核心在于下面代码，多线程扩容导致形成的链表环</p><br><p>key,hashCode通过位运算 获取数组下标，会产生hash碰撞，采用头插法 插入链表</p><br><p>针对以下代码分析源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Object, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">hashMap.put(<span class="string">&quot;2021&quot;</span>, <span class="string">&quot;colin&quot;</span>);</span><br></pre></td></tr></table></figure><br><ul><li> new HashMap&lt;&gt;(11)时</li></ul><p>构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123; <span class="comment">// 此处initialCapacity= 11 ,loadFactor =  DEFAULT_LOAD_FACTOR = 0.75f</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) <span class="comment">// 如果初始值大小大于最大容量，将他赋值为最大值</span></span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor; <span class="comment">// 加载因子赋值</span></span><br><span class="line">    threshold = initialCapacity; <span class="comment">//  threshold = 11</span></span><br><span class="line">    init(); <span class="comment">// 空方法，什么都没有，java.util.LinkedHashMap对此方法进行了重写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li> hashMap.put方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123; <span class="comment">// 如果数组为空，则进行初始化</span></span><br><span class="line">        inflateTable(threshold); <span class="comment">// threshold = 11（构造函数里赋值）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key); <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length); <span class="comment">// 计算索引</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">// 遍历数组索引处所在的链表</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; <span class="comment">// 如果当前节点的key等于put的key,将其替换</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);  <span class="comment">// 加入节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1.1 inflateTable(threshold) 初始化数组 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123; <span class="comment">// toSize = 11</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize); <span class="comment">// 计算出toSize的最小2次幂(即&gt;=size，并且使2的指数倍)。计算出来的就是hashMap数组的容量</span></span><br><span class="line"></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>); <span class="comment">// threshold阈值 = 当前容量 * 加载因子 / MAXIMUM_CAPACITY + 1 取最小的</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity]; <span class="comment">//</span></span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1.1.1 roundUpToPowerOf2方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123; <span class="comment">// number == 11</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line"></span><br><span class="line">        ? MAXIMUM_CAPACITY</span><br><span class="line"></span><br><span class="line">        : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1.1.1.1 highestOneBit方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// i = 11 &lt;&lt; 1 = 26</span></span><br><span class="line">i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">i |= (i &gt;&gt; <span class="number">16</span>);  <span class="comment">// 以上操作都是把二进制的低位变成1</span></span><br><span class="line"><span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i |= (i &gt;&gt; 1)</p><p>i = 0001 1010 向右移1位 变成 0000 1101，然后二者进行或运算</p><p>0001 1010</p><pre><code>     或运算               ——&gt; 0001 1111</code></pre><p>0000 1101</p><p>后面的同理，目的是把低位全变成1，最后的 i就等于 0001 1111，即31 然后 return i - (i &gt;&gt;&gt; 1)</p><p>i &gt;&gt;&gt; 1 , 无符号右移1位，忽略符号位，空位都以0补齐。变成 0000 1111，即等于7，最后return 31 -15 = 16</p><ul><li>1.2 indexFor 计算索引</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123; <span class="comment">// hash, table.length</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要length -1，因为table.length是2的指数次幂，所以length的二进制只会是2的整数倍，如0000 1000，0010 0000 这样子的</p><p>而hash值是随机的，所以，如果不减1，那么进行与运算的结果就只有两种，一个就是lenth本身，一个是0；那么元素放置在数组的位置就只有两个了，还会越界</p><p>length 减去1，那么length低位全变成1，与hash进行与运算得到的结果只会是0-length-1范围里面</p><ul><li>1.3 addEntry节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123; <span class="comment">// hash - 计算出来的hash值  bucketIndex -- 计算出来的索引</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;  <span class="comment">// 如果当前大小 大于等于 阈值  并且 当前数组索引处不为空，则进行扩容</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);   <span class="comment">// 扩容为当前数组长度的两倍，因为长度需要是2的指数次幂 </span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1.3.1 resize扩容方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123; <span class="comment">// newCapacity = 2 * table.length</span></span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity)); <span class="comment">// 将旧数据转移到新hashTable</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1.3.1.1 transfer——转移数据</li></ul><p>多线程情况下会产生环形链表，死锁</p><p><a href="https://www.processon.com/diagraming/5eda27f7e0b34d4139010c23">https://www.processon.com/diagraming/5eda27f7e0b34d4139010c23</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;<span class="comment">// 外层循环是数组</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;    <span class="comment">// 内层循环的是数组节点的上链表 </span></span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">// 重新计算hash</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么加载因子loadfactor是0.75？</strong></p><p>HashMap类上面的源码注释已经给出了答案；</p><p>一般来说，默认负载系数（0.75）在时间和空间成本之间 提供了一个很好的折中方案。较高的值会减少空间开销，但会增加查找成本，反映在HashMap类，包括get和put。这个应采用映射中的预期条目数及其加载系数 在设置其初始容量时应予以考虑，以尽量减少再灰化操作的数量。如果初始容量更大大于最大条目数除以负载系数，再灰化作业将永远不会发生。</p><p>基于牛顿二项式，算出来折中考虑</p><p>HashMap8的扩容方法，完全绕开了rehash重新计算hash的方法，采用高低位指针</p><h4 id="JDK8中的HashMap"><a href="#JDK8中的HashMap" class="headerlink" title="JDK8中的HashMap"></a>JDK8中的HashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造，只是赋予了默认了加载因子0.75f</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hash（）计算hash值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">// 刚开始put时，成员属性table为null</span></span><br><span class="line">        n = (tab = resize()).length; <span class="comment">// resize()方法初始化hashMap， n = 16</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// i = (n - 1) &amp; hash 计算索引，n=table.length，长度-1跟jdk7一样保证索引落在0-15以内</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// new 一个 Node节点，并放在数组索引处</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 如果索引处已经有元素了，添加到链表上</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 如果key相等。p为数组索引处第一个节点</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// TreeNode是Node的子类</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">// 如果p下一个节点为null (p为数组索引处第一个节点)</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 【尾插法】插入链表</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// TREEIFY_THRESHOLD = 8. 如果长度大于8</span></span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">// 转红黑树或者扩容</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 如果key相同，break</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 将旧值替换并返回</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>resize()初始化，下面只贴出初始化会走的逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K, V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">// oldCap = 0</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold; <span class="comment">// oldThr = 0</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ....<span class="comment">// 初始化不会走这里</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)  <span class="comment">// false</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">// 默认初始容量16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">// 默认加载因子0.75 * 16 = 12</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123; <span class="comment">// false</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">// threshold = 12</span></span><br><span class="line">    Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node[newCap]; <span class="comment">// new Node[16]</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123; <span class="comment">// false</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab; <span class="comment">// 返回初始化的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>treeifyBin()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) <span class="comment">// 如果table.length &lt; MIN_TREEIFY_CAPACITY = 64,则进行扩容</span></span><br><span class="line">        resize(); <span class="comment">// 扩容方法（也就是初始化时调的方法）我们下面回过头看扩容的逻辑</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">// 否则将链表转为红黑树</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>resize()扩容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; next;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    next = e.next;</span><br><span class="line">                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            loTail.next = e;</span><br><span class="line">                        loTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                            hiHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            hiTail.next = e;</span><br><span class="line">                        hiTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTab[j] = loHead;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTab[j + oldCap] = hiHead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CountcurrentHashMap"><a href="#CountcurrentHashMap" class="headerlink" title="CountcurrentHashMap"></a>CountcurrentHashMap</h3><ul><li>数据结构</li></ul><p>ConcurrentHashMap的数据结构与HashMap基本类似，区别在于：</p><p>1、内部在数据写入时加入了同步机制（分段锁）保证线程安全，读操作是无锁操作；</p><p>2、扩容时老数据的转移是并发执行的，这样扩容的效率更高。</p><ul><li>并发安全控制</li></ul><p>Java7ConcurrentHashMap基于ReentrantLock实现分段锁</p><blockquote><p>Java8中ConcurrentHashMap基于分段锁+CAS保证线程安全，分段锁基于synchronized关键字实现</p></blockquote><ul><li>源码分析</li></ul><p><strong>重要成员变量</strong></p><ul><li><p>LOAD_FACTOR：负载因子，默认0.75，当table使用率达到75%时，为了减少table的hash碰撞，table长度将扩容一倍。</p></li><li><p>TREEIFY_THRESHOLD:  默认为8，当链表长度大于8时，将链表转变成红黑树</p></li><li><p>UNTREEIFY_THRESHOLD：默认为6，红黑树转变为链表的阈值</p></li><li><p>MIN_TRANSFER_STRIDE：默认为16，table扩容时，每个线程最少迁移table的槽位个数</p></li><li><p>MOVED：值为-1，当Node.hash为MOVED时，代表着table正在扩容</p></li><li><p>THEEBINl：值为-2,代表此元素后接红黑树</p></li><li><p>nextTable：table迁移过程临时变量，在迁移过程中将元素全部迁移到nextTable上。</p></li><li><p>sizeCtl：用来标志table初始化和扩容的，不同的取值代表着不同的含义</p></li></ul><p>0：table还没有初始化</p><p>-1：table正在初始化</p><p>小于-1：实际值为 resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT + 2，表明table正在扩容</p><p>大于0：初始化完成后，代表table最大存放元素的个数，默认为0.75*n （代码中写法为：sc = n - (n &gt;&gt;&gt; 2);sizeCtl = sc）</p><ul><li><p>transferIndex：table容量从n扩到2n时，是从索引n-1的元素开始迁移，transferIndex代表当前已经迁移的元素下标</p></li><li><p>ForwardingNode：一个特殊的Node节点，其hashCode=MOVED，代表着此时table正在做扩容操作。扩容期间，若table某个元素为null，那么该元素设置为ForwardingNode，当下个线程向这个元素插入数据时，检查hashcode=MOVED，就会帮着扩容</p></li></ul><p>ConcurrentHashMap由三部分构成，table+链表+红黑树，其中table是一个数组，既然是数组，必须要在使用时确定数组的大小，当table存放的元素过多时，就需要扩容，以减少碰撞发生次数</p><p><strong>源码分析</strong></p><ul><li>无参构造</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有参构造</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"><span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">MAXIMUM_CAPACITY :</span><br><span class="line">tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>put方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>putVal方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode()); <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;  <span class="comment">// 循环时为了考虑并发情况，如：多个线程去初始化时只能有一个初始化</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable(); <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">// 如果此时正在扩容。ps:扩容的时候会将链表首节点包装成ForwardingNode，并用nextTable指向原table</span></span><br><span class="line">            tab = helpTransfer(tab, f); <span class="comment">// 帮忙迁移扩容</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> initTable初始化方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123; <span class="comment">// cas去修改sizeCtl的值为-1，多个线程去修改的话，会出现失败情况，失败的继续走循环</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;  <span class="comment">// 为什么还要判断一次？因为失败的第二次循环去修改时，也会可能成功</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY; <span class="comment">// SC在有参构造时会赋值，不然默认为0；DEFAULT_CAPACITY = 16</span></span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// 即0.75*n， 代表table最大存放元素的个数，</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>helpTransfer帮助扩容方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length); <span class="comment">// 根据length得到一个标识符号</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123; <span class="comment">// 说明还在扩容</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                <span class="comment">// 达到最大的帮助线程 || 判断扩容转移下标是否在调整（扩容结束）</span></span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// cas修改sizectl + 1, 表示增加了一个线程帮助其扩容</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>transfer扩容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range 每个线程最小迁移16个槽位 </span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p><strong>CopyOnWrite机制</strong></p><p>核心思想：读写分离，空间换时间，避免为保证并发安全而导致的激烈的锁竞争</p><ul><li>CopyOnWrite适用于读多写少的情况，最大程度的提高读的效率</li><li>CopyOnWrite是最终一致性，在写的过程中，原有读的数据是不会发生更新的，只有新的读才能读到最新数据</li><li>如何使其他线程能过够及时读到新的数据，需要使用volatile修饰</li><li>写的时候不能并发写，需要对写操作进行加锁</li></ul><p><strong>源码分析</strong></p><p>add（）方法，写时复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">// 复制一个array副本,并且长度为原先的加1</span></span><br><span class="line">        newElements[len] = e; <span class="comment">// 往副本里写入新元素</span></span><br><span class="line">        setArray(newElements); <span class="comment">// 副本替换原本，成为新的原本</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> get(getArray(), index); <span class="comment">// 无锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line"><span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Executor线程池原理"><a href="#Executor线程池原理" class="headerlink" title="Executor线程池原理"></a>Executor线程池原理</h1><p>线程是调度CPU资源的最小单位，线程模型分为KLT模型与ULT模型，JVM使用的KLT模型，Java线程与OS线程保持1：1的映射关系，也就是说有一个Java线程也会在操作系统里有一个对应的线程，Java线程有多种生命状态，被定义在java.lang.Thread.State</p><ul><li>NEW：新建</li><li>RUNNABLE：运行</li><li>BLOCKED：阻塞</li><li>WAITING：等待</li><li>TIMED_WAITING：超时等待</li><li>TERMINATED：终结</li></ul><p><strong>协程</strong></p><pre><code>协程（纤程，用户级线程），目的是为了追求最大力度的发挥硬件性能和提升软件的速度，协程基本原理是：在某个点挂起当前的任务，并且保存栈信息，去执行另一个任务；等完成或达到某个条件时，再还原原来的栈信息并继续执行（整个过程线程不需要上下文切换）</code></pre><p>Java原生不支持协程，在纯java代码里需要使用协程的话需要引入第三方包，如：quasar</p><p><strong>线程池</strong></p><p>线程是稀缺资源，如果被无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此Java中提供线程池对线程进行统一分配、调优和监控线程池</p><p>在web开发中，服务器需要接收并处理请求，所以会为一个请求来分配一个线程来进行处理。如果每次请求都创建一个线程的话实现起来非常简便，但是存在一个问题，如果并发请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的资源要比处理实际的用户的时间和资源更多</p><p>线程池的目的就是执行完一个任务，线程并不被销毁，而是可以继续执行其他的任务。</p><p>什么时候使用线程池?</p><ol><li>单个任务处理时间比较长</li><li>需要处理的任务数量很大</li></ol><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>Executor接口是线程池框架中最基础的部分，定义了一个用于执行Runnable的execute方法</p><p>Executor有一个重要子接口ExecutorService，其中定义了线程池的具体行为</p><p>1、execute（Runnable command）：履行Runnable类型的任务</p><p>2、submit（task）：可以来提交Callable或Runnable任务，并返回代表此任务的Future对象</p><p>3、shutdown（）：在完成已提交的任务后封闭办事，不再接管新任务</p><p>4、shutdownNow（）：停止所有正在履行的任务并封闭办事</p><p>5、isTerminated（）：测试是否所有任务都履行完毕了</p><p>6、isShutdown（）：测试是否该ExecutorService已被关闭</p><h2 id="线程池的五种状态"><a href="#线程池的五种状态" class="headerlink" title="线程池的五种状态"></a>线程池的五种状态</h2><ul><li><p>private static final int COUNT_BITS = Integer.SIZE - 3; // 29</p></li><li><p>private static final int CAPACITY  = (1 &lt;&lt; COUNT_BITS) - 1; // 1 &lt;&lt; 29 - 1 = 2 ^ 29 - 1 即 0000 1111 … 1111</p></li></ul><p>// 位图，高三位记录线程池状态，后29位记录线程数量</p><ul><li><p>private static final int RUNNING  = -1 &lt;&lt; COUNT_BITS; // 101 0 0000 …. 0000</p></li><li><p>private static final int SHUTDOWN  = 0 &lt;&lt; COUNT_BITS; // 000 0 0000 …. 0000</p></li><li><p>private static final int STOP    = 1 &lt;&lt; COUNT_BITS; // 001 0 0000 …. 0000</p></li><li><p>private static final int TIDYING  = 2 &lt;&lt; COUNT_BITS; // 010 0 0000 …. 0000</p></li><li><p>private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; // 011 0 0000 …. 0000</p></li></ul><p><strong>RUNNING</strong></p><p>状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务处理</p><p>状态切换：线程池的初始化状态是RUNNING。换句话说，线程池一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0；</p><p><strong>SHUTDOWN</strong></p><p>状态说明：线程池处在SHUTDOWN状态时，不接受新任务，但能处理已添加的任务。</p><p>状态切换：调用线程池的shutdown（）接口时，线程池由RUNNING ——&gt; SHUTDOWN</p><p><strong>STOP</strong></p><p>状态说明：线程池处在STOP状态时，不接受新任务，不处理已添加的任务，并且会中断正在处理的任务</p><p>状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN) ——&gt; STOP</p><p><strong>TIDYING</strong></p><p>tidying 英 [ˈtaɪdiɪŋ]  美 [ˈtaɪdiɪŋ] v.使整洁;使整齐 ;使有条理;整理</p><p>状态说明：当所有的任务已终止，ctl记录的“任务数量”为0，线程池会变为tidying状态。当线程池变为tidying状态时，会执行钩子函数terminated()。</p><blockquote><p>terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现</p></blockquote><p>状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由SHUTDOWN ——&gt; TIDYING。当线程池在STOP状态下，线程池中执行任务为空时，就会由STOP ——&gt; TIDYING</p><p><strong>TERMINATED</strong></p><p>状态说明：线程池彻底终止，就变成TERMINATED状态</p><p>状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由TIDYING ——&gt; TERMINATED</p><p>进入TERMINATED的条件如下：</p><ul><li>线程池不是RUNNING状态</li><li>线程池状态不是TIDYING状态或TERMINATED</li><li>如果线程池状态是SHUTDOWN并且workerQuere为空</li><li>workerCount为0</li><li>设置TIDYING状态成功</li></ul><p>构造函数（全参），入参如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maximumPoolSize, <span class="comment">// 最大线程数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> keepAliveTime, <span class="comment">// 最大允许线程不干活的时间</span></span><br><span class="line"></span><br><span class="line">TimeUnit unit, <span class="comment">// 时间单位</span></span><br><span class="line"></span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue, <span class="comment">// 存放未来得及执行的任务</span></span><br><span class="line"></span><br><span class="line">ThreadFactory threadFactory, <span class="comment">// 创建线程的工厂</span></span><br><span class="line"></span><br><span class="line">RejectedExecutionHandler handler <span class="comment">// 拒绝策略</span></span><br></pre></td></tr></table></figure><ul><li>corePoolSize</li></ul><p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；继续提交的任务将被保存在阻 塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程</p><ul><li>maxinumPoolSize</li></ul><p>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maxinumPoolSize</p><ul><li>keepAliveTime</li></ul><p>线程池维护线程所允许的空闲时间，当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime</p><ul><li>unit</li></ul><p>指定keepAliveTime的时间单位</p><ul><li>workQueue</li></ul><p>用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列：</p><p>1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务</p><p>2、LinkedBlockingQueue：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue</p><p>3、SychronousQueue：一个不存储元素的阻塞队列，每个插入操作一直处于阻塞队列，吞吐量通常要高于LinkedBlockingQueue</p><p>4、priorityBlockingQueue：具有优先级的无界阻塞队列；</p><ul><li>threadFactory</li></ul><p>它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory()来创建新线程</p><p>使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称</p><ul><li>handler</li></ul><p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种拒绝策略</p><ul><li>AbortPolicy：默认的策略，直接抛出异常；</li><li>CallerRunsPolicy：用调用者所在的线程自己来执行任务</li><li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务</li><li>DiscardPolicy：直接丢弃任务；</li></ul><p>上面的四种策略都是ThreadPoolExecutor的内部类,也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务</p><img src="/2022/12/04/JUC/image-20220316173838924.png" class>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;冯诺依曼计算机&quot;&gt;&lt;a href=&quot;#冯诺依曼计算机&quot; class=&quot;headerlink&quot; title=&quot;冯诺依曼计算机&quot;&gt;&lt;/a&gt;冯诺依曼计算机&lt;/h1&gt;&lt;h2 id=&quot;计算机五大核心组成部分&quot;&gt;&lt;a href=&quot;#计算机五大核心组成部分&quot; class=&quot;he</summary>
      
    
    
    
    <category term="JUC" scheme="https://c89757.github.io/categories/JUC/"/>
    
    
    <category term="JUC" scheme="https://c89757.github.io/tags/JUC/"/>
    
    <category term="多线程" scheme="https://c89757.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
