<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://c89757.github.io/atom.xml" rel="self"/>
  
  <link href="https://c89757.github.io/"/>
  <updated>2025-12-18T17:14:06.127Z</updated>
  <id>https://c89757.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次堆外内存泄漏</title>
    <link href="https://c89757.github.io/2025/08/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://c89757.github.io/2025/08/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2025-08-25T14:10:07.000Z</published>
    <updated>2025-12-18T17:14:06.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近项目由JDK8升级到了JDK21，在进行压测时，项目不断重启。</p><h1 id="排查步骤"><a href="#排查步骤" class="headerlink" title="排查步骤"></a>排查步骤</h1><ol><li>通过命令查看k8s事件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pods -n &lt;namespace&gt; &lt;podName&gt;</span><br></pre></td></tr></table></figure><img src="/2025/08/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/image-20250909192824371.png" class><p>显示<code>OOMKilled</code>。在k8s中，如果容器使用的内存超出了其限制时，K8s就会杀死该容器进行重启。</p><p>这就说明，是因为内存不足导致的重启。</p><ol start="2"><li>排查为何内存占用飙升</li></ol><p>使用<code>jcmd</code>命令查看内存占用情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd &lt;pid&gt; VM.native_memory detail</span><br></pre></td></tr></table></figure><blockquote><p> 需要添加JVM参数：<code>-XX:NativeMemoryTracking=detail</code></p></blockquote><br><img src="/2025/08/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/image-20250909194512292.png" class><br><p>查看到直接内存一直在上涨（上图为配图，原图无法拷贝下来）。</p><p>或者直接使用arthas的<code>memory</code>/ <code>dashboard</code>命令观察</p><br><img src="/2025/08/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/image-20250909195305211.png" class><br><p>直接内存 从项目启动开始的30多M，迅速增长到800多M，最后容器被杀死，服务重启。</p><p>由此可以基本推断出，直接内存的增长是导致项目重启的直接原因。</p><ol start="3"><li><p>进一步验证猜想</p><p>在jvm中，直接内存的限制受到参数：<code>MaxDirectMemorySize</code>的影响，默认情况下，该值等于<code>-Xmx</code>最大堆内存。</p><p>直接内存不受 JVM 垃圾回收机制的直接管理，当直接内存使用超过设置值时，会触发 Full GC。</p><p>于是，添加JVM参数：<code>-XX:MaxDirectMemorySize=50M</code>，再次压测，服务正常不再重启。查看监控，触发了Full GC，并且每次Full GC时，DirectMemory的大小会降下来，说明被回收</p></li></ol><ol start="4"><li><p>排查根因</p><p>进入容器，dump堆内存快照。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>使用Jprofile分析快照。由于dump的是堆内存，并不能直接查看到直接内存的信息。</p><p>但是直接内存，一般是通过DirectMemory.alloct()等方式来分配，我们可以查看到快照中，含有DirectMemroy的引用，这个引用并不会太大，但其背后的引用却占据很大的内存</p><p>通过查看<strong>传入引用</strong>，可以找到到其堆栈</p></li></ol><blockquote><p>也可以通过工具 async-profiler抓取内存火焰图来分析</p><p><a href="https://github.com/async-profiler/async-profiler">github.com</a></p></blockquote><ol start="5"><li><p>根因结论</p><p>最终排查到，分配直接内存的代码如下：sun.nio.ch.Util#getTemporaryDirectBuffer</p><br><img src="/2025/08/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/image-20250909211923249.png" class></li></ol><p>bufferCache静态变量如下：</p><p>​        <img src="/2025/08/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/image-20250909212305193.png" class></p><br><p>每一个线程都有一个缓冲区，缓存着直接内存的地址值。</p><p>一开始，缓冲区中并没有数据，会分配直接内存并缓存起来，下次获取时，先判断当前获取的内存大小，在缓冲区中够不够，够的话直接返回，大小不够则新申请一块内存，并缓存起来，同时释放掉原先的内存。</p><p>这块代码并没有问题。</p><p>可是我们发现。二方包中的一块代码，在每次请求完成之后，都会通过反射方法，将threadLocals变量设置为Null，导致缓冲区被清空，于是，jvm不断申请对外内存，导致直接内存上涨过快。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>我们发现，在压测JDK8时，项目并不会重启。</p><p>JDK8中，使用的是G1GC（我们通过JVM设置的，默认是Parallel GC）</p><p>JDK21中，垃圾回收器变成了ZGC。</p><p>关于二者在垃圾回收方面的差异，还待进一步研究。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近项目由JDK8升级到了JDK21，在进行压测时，项目不断重启。&lt;/p&gt;
&lt;h1 id=&quot;排查步骤&quot;&gt;&lt;a href=&quot;#排查步骤&quot; cl</summary>
      
    
    
    
    <category term="JVM" scheme="https://c89757.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://c89757.github.io/tags/JVM/"/>
    
    <category term="questions" scheme="https://c89757.github.io/tags/questions/"/>
    
  </entry>
  
  <entry>
    <title>jdk8~21新特性</title>
    <link href="https://c89757.github.io/2025/06/24/jdk8-21%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://c89757.github.io/2025/06/24/jdk8-21%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2025-06-24T12:01:47.000Z</published>
    <updated>2025-12-11T15:02:37.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h1><ol><li>接口可以定义私有方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interfaceMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static after method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        System.out.println(<span class="string">&quot;default method.&quot;</span>);</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">new</span> MyInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interfaceMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.func();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>try-with-resources新写法</p><p>jdk8写法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">         FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        jdk9新写法</p><p>变量可以定义在外面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">       FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">       FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> (fis; fos) &#123;</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>@Deprecated注解变化</li></ol><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the version in which the annotated element became deprecated.</span></span><br><span class="line"><span class="comment">     * The version string is in the same format and namespace as the value of</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@code</span> <span class="doctag">@since</span>&#125; javadoc tag. The default value is the empty</span></span><br><span class="line"><span class="comment">     * string.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the version string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">since</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates whether the annotated element is subject to removal in a</span></span><br><span class="line"><span class="comment">     * future version. The default value is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> whether the element is subject to removal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">forRemoval</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String since default “” : 标识是从哪个版本开始废弃</p><p>boolean forRemoval() default false：标识该废弃的内容会在未来某个版本中移除</p><ol start="4"><li>String字符串的变化</li></ol><p>在jdk8之前，String内部采用char数组存储字符串</p><p>Jdk9之后，采用byte数组存储字符串，节省一般内存</p><blockquote><p>因为大多时候String存储的都是英文字符或者数字（对于老外而言），而英文字符只需要一个字节即可，用char数组来存储的话，浪费了一半的空间，所以为了节省，Jdk9之后，改成了byte数组</p></blockquote><p>byte数组如何存储中文？</p><blockquote><p>中文需要两个字节</p></blockquote><p>String中增加了下面2个成员变量</p><ul><li>COMPACT_STRINGS：判断是否压缩，默认时true，若为false，则不压缩，使用UTF16编码</li><li>coder：用来区分使用的字符编码。分别为LATIN1（值为0）和 UTF-16（值为1）</li></ul><p>在使用中文字符串时，1个中文会被存储到byte数组中的两个元素上，即存储1个中文，byte数组长度为2，存储2个中文，byte数组长度为4。（通过String.length()获取中文字符长度时，会除以2得到真实长度）</p><blockquote><p> 当字符串中存储了中英混合的内容时，1个英文字符会占用2个byte数组位置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">int</span> off, <span class="keyword">int</span> len, Void sig) &#123;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.coder = <span class="string">&quot;&quot;</span>.coder;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (COMPACT_STRINGS) &#123;</span><br><span class="line">        <span class="comment">// 如果含有中文，此处返回null</span></span><br><span class="line">        <span class="keyword">byte</span>[] val = StringUTF16.compress(value, off, len);</span><br><span class="line">        <span class="keyword">if</span> (val != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = val;</span><br><span class="line">            <span class="keyword">this</span>.coder = LATIN1;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.coder = UTF16;</span><br><span class="line">    <span class="keyword">this</span>.value = StringUTF16.toBytes(value, off, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] src, <span class="keyword">int</span> srcOff, <span class="keyword">byte</span>[] dst, <span class="keyword">int</span> dstOff, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = src[srcOff];</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0xFF</span>) &#123; <span class="comment">// 是否超过了1个字节</span></span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dst[dstOff] = (<span class="keyword">byte</span>)c;</span><br><span class="line">        srcOff++;</span><br><span class="line">        dstOff++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>模块化</li></ol><p>java8中有一个非常重要的包rt.jar，里面涵盖了java提供的类文件，在程序员运行java程序时jvm会加载rt.jar。</p><blockquote><p>这里的问题是rt.jar中的某些文件我们是不会使用的，比如使用java开发服务器端程序的时候通常用不到图形化界面的库java.awt，这就造成了内存的浪费</p></blockquote><p>java9中将rt.jar分成了不同的模块，一个模块下可以包含多个包，模块之间存在着依赖关系，其中java.base模块是基础模块，不依赖其他模块。这样在不适用这个模块的时候，就无需让jvm加载，减少内存浪费，让jvm加载程序的必要模块，并非全部模块，达到了瘦身效果</p><p><img src="/2025/06/24/jdk8-21%E6%96%B0%E7%89%B9%E6%80%A7/typora-user-images\jdk8-21新特性\image-20250818202313388.png" alt="image-20250818202313388"></p><ul><li>java17中还有一个jmods目录</li></ul><p><img src="/2025/06/24/jdk8-21%E6%96%B0%E7%89%B9%E6%80%A7/typora-user-images\jdk8-21新特性\image-20250626210910223.png" alt="image-20250626210910223"></p><p>jar包中含有.class文件，配置文件。jmods目录下都是jmod文件，jmod文件除了包含这两个文件之外，还有native library，legal licenses等，两个的主要区别是jmod主要用来编译器和链接期，并非运行期，因此对于很多开发者来说，在运行期仍然需要使用jar包。</p><p>模块化的优点：</p><ul><li>精简jvm加载的class类，提升加载速度</li><li>对包更精细的控制，提高安全                                           </li></ul><ol start="6"><li>jshell</li></ol><p>Jdk9中提供了一个交互式编程环境jshell。类似于python中的小窗口</p><ol start="7"><li>集合新API</li></ol><p>为List，Set 和Map接口添加了静态工厂方法，如of和copyOf()，用于创建不可变集合实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="JDK10"><a href="#JDK10" class="headerlink" title="JDK10"></a>JDK10</h1><ol><li>局部类型推断</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>jvm会自动推断该变量是什么类型的。</p><blockquote><p>注意：var的使用，仅适用于局部变量，增强for循环的索引，以及普通for循环的本地变量。</p><p>不能用于方法形参，构造方法形参，方法返回类型等。</p></blockquote><h1 id="JDK11"><a href="#JDK11" class="headerlink" title="JDK11"></a>JDK11</h1><ol><li>直接运行</li></ol><p>在之前的版本中，写完java代码之后，我们需要先通过<code>javac</code>命令编译，得到class文件，然后再通过<code>java</code> + 文件名的方法来运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java</span><br><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure><p>Jdk11中，可以通过<code>java</code>命令 + .java文件直接运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java HelloWorld.java</span><br></pre></td></tr></table></figure><ol start="2"><li>String新增API</li></ol><ul><li>strip()</li></ul><p>去除首尾空白字符。与trim()相比，它能去除unicode编码的空白字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;\u2000&#x27;</span>;</span><br><span class="line">String str = c + <span class="string">&quot;abc&quot;</span> + c;</span><br><span class="line">System.out.println(str.trim());</span><br><span class="line">System.out.println(str.strip());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">——————————————————————</span><br><span class="line"> abc </span><br><span class="line">abc</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li>isBlank()</li></ul><p>判断字符串是否为空（如果字符串仅仅只包含空白字符，也会判断为空）</p><h1 id="JDK12"><a href="#JDK12" class="headerlink" title="JDK12"></a>JDK12</h1><ol><li>switch语句升级</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> month = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">switch</span> (month) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> -&gt; System.out.println(<span class="string">&quot;spring&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> -&gt; System.out.println(<span class="string">&quot;summer&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JDK13"><a href="#JDK13" class="headerlink" title="JDK13"></a>JDK13</h1><ol><li>switch语句升级</li></ol><blockquote><p>13又对switch语句进行了升级，可以拥有返回值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> month = <span class="number">3</span>;</span><br><span class="line">String str = <span class="keyword">switch</span> (month) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> -&gt; <span class="string">&quot;spring&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> -&gt; <span class="string">&quot;summer&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="string">&quot;default&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><ol start="2"><li>文本块的变化</li></ol><blockquote><p>使用三重双引号包裹多行文本，可以自动管理换行和缩进</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        第一行</span></span><br><span class="line"><span class="string">        第二行</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="JDK14"><a href="#JDK14" class="headerlink" title="JDK14"></a>JDK14</h1><ol><li>instanceof模式匹配</li></ol><blockquote><p>如果匹配，会自动帮你强转</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String str) &#123;</span><br><span class="line"> String str2 = str + <span class="string">&quot;c&quot;</span>;</span><br><span class="line"> System.out.println(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>友好的空指针提示</li></ol><blockquote><p>针对空指针的报错，提示会更详细更友好</p></blockquote><ol start="3"><li>record类型</li></ol><blockquote><p>预览版，16成为正式版<a href="https://openjdk.org/jeps/395">JEP 395: Records</a></p></blockquote><p>Record 提供了一种紧凑的语法来定义只包含不可变数据的类，自动生成诸如 equals(), hashCode(), 和 toString() 等方法，简化了数据类的编写。</p><p>之前定义类，类中属性不可变时需要手动加上final修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginForm</span><span class="params">(String userName, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>record写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">LoginFormReocrd</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的class代码：会自动生成构造方法，get方法，但是没有setter，因为不许改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">LoginFormReocrd</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginFormReocrd</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">username</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">password</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JDK15"><a href="#JDK15" class="headerlink" title="JDK15"></a>JDK15</h1><ol><li>Sealed Classes</li></ol><p>密封类和接口，作用是限制一个类可以有哪些子类继承或实现</p><ul><li>如果指定模块的话，sealed class和其子类必须在同一个模块下</li><li>sealed class指定的子类必须直接继承该sealed class</li><li>sealed class的子类要用final修饰</li><li>sealed class的子类如果不想用final修饰的话，可以将子类声明为sealed class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="title">permits</span> <span class="title">Cat</span>, <span class="title">Dog</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="title">permits</span> <span class="title">OtherObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JDK16"><a href="#JDK16" class="headerlink" title="JDK16"></a>JDK16</h1><ol><li>record成为正式特性。</li></ol><h1 id="JDK17"><a href="#JDK17" class="headerlink" title="JDK17"></a>JDK17</h1><ol><li>switch表达式的模式匹配</li></ol><blockquote><p>预览版</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">            <span class="comment">// 判断a是否时Dog类型，如果是，则强转之后赋值给dog</span></span><br><span class="line">            <span class="keyword">case</span> Dog dog -&gt; dog.toString();</span><br><span class="line">            <span class="comment">// 增加了对null值的判断</span></span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">null</span> -&gt; System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">            <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>废弃安全管理器</li></ol><blockquote><p>废弃 Java 安全管理器及其相关API，标志着Java安全模型的一个重大变化，因为安全策略现在更倾向于使用操作系统级别的安全措施。</p></blockquote><h1 id="JDK18"><a href="#JDK18" class="headerlink" title="JDK18"></a>JDK18</h1><ol><li>默认使用UTF-8字符集</li></ol><blockquote><p>Java平台默认的字符集现在是UTF-8，这简化了跨平台的字符编码处理，减少了因操作系统和环境差异导致的问题。</p></blockquote><ol start="2"><li>简单的Web服务器</li></ol><blockquote><p>可以通过jwebserver命令启动jdk18中提供的静态web服务器</p></blockquote><ol start="3"><li>方法移除</li></ol><blockquote><p>在jdk18中标记了Object中的finalize方法，Thread中的stop方法将在未来被移除</p></blockquote><ol start="4"><li>@snippet注解</li></ol><blockquote><p>以前在文档注释中编写代码时需要添加code标签，不太方便，现在可以通过@snippet注解，更加方便的将文档注释中的代码展示在api文档中</p></blockquote><h1 id="JDK19"><a href="#JDK19" class="headerlink" title="JDK19"></a>JDK19</h1><ol><li>虚拟线程 Virtual Threads</li></ol><blockquote><p>预览版。也称为纤程，虚拟线程主要作用是用来提升服务器端的吞吐量</p></blockquote><p><img src="/2025/06/24/jdk8-21%E6%96%B0%E7%89%B9%E6%80%A7/typora-user-images\jdk8-21新特性\image-20251211170457727.png" alt="image-20251211170457727"></p><p>多个虚拟线程可以使用同一个操作系统线程，其创建所耗费的资源也是极其低廉的，无需系统调用和系统级别的上下文切换，且虚拟线程的生命周期短暂，不会有很深的栈调用，一个虚拟线程的生命周期只运行一个任务，因此我们可以创建大量的虚拟线程，且虚拟线程无需池化。</p><p><strong>虚拟线程的应用场景</strong></p><p>在服务器的应用程序中，可能会有大量的并发任务需要执行，而虚拟线程能够明显的提高应用的吞吐量。</p><ul><li>至少几千的并发任务量</li><li>任务为IO密集型</li></ul><p><strong>平台线程和虚拟线程</strong></p><p>平台线程（platform thread）：指java中的线程，比如通过Executors.newFixedThreadPool() 创建出来的线程，我们称之为平台线程。</p><p>虚拟线程并不会直接分配给cpu去执行，而是通过调度器分配给平台线程，平台线程再被调度器管理。java中虚拟线程的调度器采用了工作窃取的模式进行FIFO的操作，调度器的并行数默认是jvm获取的处理器数量（通过该方法获取的数量Runtime.getRuntime().availableProcessors()），调度器并非分时的。在使用虚拟线程编写程序时，不能控制虚拟线程何时分配给平台线程，也不能控制平台线程何时分配给cpu</p><p><img src="/2025/06/24/jdk8-21%E6%96%B0%E7%89%B9%E6%80%A7/typora-user-images\jdk8-21新特性\image-20251211180102122.png" alt="image-20251211180102122"></p><p><strong>携带器</strong></p><p>调度器将虚拟线程挂载到平台线程后，该平台线程叫做虚拟线程的携带器。</p><p>调度器并不维护虚拟线程和携带器之间的关联关系，因此在一个虚拟线程的生命周期中，可以被分配到不同的携带器，即虚拟线程运行了一小段代码后，可能会脱离当前携带器，此时其他的虚拟线程会被分配到这个携带器上。</p><p>携带器和虚拟线程是相互独立的，比如：</p><ul><li>虚拟线程不能同时使用携带器的标识，Thread.current()方法获取的就是虚拟线程本身</li><li>两者有各自的栈空间</li><li>两者不能访问对方的Thread Local变量</li></ul><p>在程序的执行过程中，虚拟线程遇到阻塞的操作时大部分情况下会被解除挂载，阻塞结束后，虚拟线程会被调度器重新挂载到携带器上，因此虚拟线程会频繁的挂载和解除挂载，这并不会导致操作系统线程的阻塞。</p><p>有些阻塞操作并不会导致虚拟线程解除挂载，这样会同时阻塞携带器和操作系统线程，例如：操作系统基本的文件操作，java中的Object.wait()方法。下面两种情况不会导致虚拟线程的解除挂载：</p><ol><li>执行synchronized同步代码（会导致携带器阻塞，所以建议使用ReentrantLock替换synchronized)</li><li>执行本地方法或外部函数</li></ol><p><strong>虚拟线程和平台线程api的区别</strong></p><p>从内存空间上来说，虚拟线程的栈空间可以看作是一个大块的栈对象，它被存储在了java堆中。</p><p>可以重复利用这部分栈空间，不用多次申请开辟新的内存地址</p><p>虚拟线程的栈空间最大可以达到平台线程的栈空间容量</p><p>虚拟线程并不是GC Root，其中的引用不会出现stop word，当虚拟线程被阻塞之后，比如BlockingQueue.take()，平台线程既不能获取到虚拟线程，也不能获取到queue队列，这样该平台线程可能会被回收掉，虚拟线程在运行或阻塞时不会被GC</p><ul><li>通过Thread构造方法创建的线程都是平台线程</li><li>虚拟线程是守护线程，不能通过setDaemon方法改成非守护线程</li><li>虚拟线程的优先级默认是5，不能被修改</li><li>虚拟线程不支持stop()，suspend()，resume()方法</li></ul><p><strong>创建虚拟线程的方法</strong></p><ul><li>Thread.startVirtualThread()方式创建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Runnable task = () -&gt; &#123;</span><br><span class="line">    <span class="comment">// 输出为空，获取不到name</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;execute task.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建虚拟线程，创建完成之后无需再手动调用 thread.start()</span></span><br><span class="line">Thread thread = Thread.startVirtualThread(task);</span><br></pre></td></tr></table></figure><ul><li>Thread.ofVirtual()方式创建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Runnable task = () -&gt; &#123;</span><br><span class="line">    <span class="comment">// 输出thread-01</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;execute task.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建虚拟线程</span></span><br><span class="line">Thread thread = Thread.ofVirtual().name(<span class="string">&quot;thread-01&quot;</span>).unstarted(task);</span><br><span class="line"><span class="comment">// 手动启动虚拟线程</span></span><br><span class="line">thread.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>我们可以通过boolean virtual = thread.isVirtual() ，来判断当前线程是否为虚拟线程。</p><h1 id="JDK21"><a href="#JDK21" class="headerlink" title="JDK21"></a>JDK21</h1><blockquote><p>虚拟线程成为正式版。</p></blockquote><ol><li>字符串模板</li></ol><p>字符串模板可以让开发者更简洁的进行字符串拼接（例如拼接sql，json等）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String title = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">String content = STR.<span class="string">&quot;Hello \&#123;title&#125;&quot;</span>;</span><br><span class="line">System.out.println(content);</span><br></pre></td></tr></table></figure><blockquote><p>为预览功能，需要添加启动参数：–enable-preview</p></blockquote><ol start="2"><li>scope values</li></ol><p>scoped values是一个隐藏的方法参数，只有方法可以访问scoped values，它可以让两个方法之间传递参数时无需声明形参。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScopedValue&lt;String&gt; MESSAGE = ScopedValue.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ScopedValue.where(MESSAGE, <span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">            .run(() -&gt; receiveMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s = MESSAGE.get();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为预览功能，需要添加启动参数：–enable-preview</p></blockquote><ol start="3"><li>record pattern</li></ol><p>通过该特性可以结构record类型中的值</p><p><a href="https://openjdk.org/jeps/440">JEP 440: Record Patterns</a></p><ol start="4"><li>switch模式匹配</li></ol><p><a href="https://openjdk.org/jeps/441">JEP 441: Pattern Matching for switch</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">formatterPatternSwitch</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (obj) &#123;</span><br><span class="line">        <span class="keyword">case</span> Integer i -&gt; String.format(<span class="string">&quot;int %d&quot;</span>, i);</span><br><span class="line">        <span class="keyword">case</span> Long l    -&gt; String.format(<span class="string">&quot;long %d&quot;</span>, l);</span><br><span class="line">        <span class="keyword">case</span> Double d  -&gt; String.format(<span class="string">&quot;double %f&quot;</span>, d);</span><br><span class="line">        <span class="keyword">case</span> String s  -&gt; String.format(<span class="string">&quot;String %s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">default</span>        -&gt; obj.toString();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以在case中使用when子句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStringNew</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (response) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">null</span> -&gt; &#123; &#125;</span><br><span class="line">        <span class="keyword">case</span> String s</span><br><span class="line">        when s.equalsIgnoreCase(<span class="string">&quot;YES&quot;</span>) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;You got it&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> String s</span><br><span class="line">        when s.equalsIgnoreCase(<span class="string">&quot;NO&quot;</span>) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Shame&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> String s -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Sorry?&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDK9&quot;&gt;&lt;a href=&quot;#JDK9&quot; class=&quot;headerlink&quot; title=&quot;JDK9&quot;&gt;&lt;/a&gt;JDK9&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;接口可以定义私有方法&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;ta</summary>
      
    
    
    
    <category term="JDK" scheme="https://c89757.github.io/categories/JDK/"/>
    
    
    <category term="JDK" scheme="https://c89757.github.io/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>https详解</title>
    <link href="https://c89757.github.io/2025/03/19/https%E8%AF%A6%E8%A7%A3/"/>
    <id>https://c89757.github.io/2025/03/19/https%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-03-19T12:09:40.000Z</published>
    <updated>2025-12-18T16:42:27.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><blockquote><p>超文本传输协议（HTTP）是<strong>应用层</strong>协议的一种，是基于TCP/IP的通信协议</p></blockquote><h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><ul><li>无连接：HTTP客户端，即浏览器发出请求后，客户端等待响应。服务端处理该请求并返回响，然后客户端断开连接。（半双工协议）</li><li>独立于媒体：只要客户端和服务器都知道如何处理数据内容，任何类型的数据都可以通过HTTP发送。客户端和服务器都需要使用适当的MIME类型指定内容类型。</li><li>无状态：服务器和客户端仅在当前请求期间彼此知道。</li></ul><h2 id="一个标准的HTTP请求构成"><a href="#一个标准的HTTP请求构成" class="headerlink" title="一个标准的HTTP请求构成"></a>一个标准的HTTP请求构成</h2><p>HTTP会话由HTTP客户端（即用户的浏览器）通过用户代理打开，并且连接请求消息被发送到HTTP服务器。请求消息由以下几行组成：</p><ul><li>请求行</li><li>请求头</li><li>空行</li><li>请求体</li></ul><img src="/2025/03/19/https%E8%AF%A6%E8%A7%A3/https%E8%AF%A6%E8%A7%A3-01.png" class><h1 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h1><blockquote><p>Https，也称作Http Over TLS，TLS的前身是SSL。TLS1.0通常被标示为SSL3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3</p><p>HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。</p></blockquote><img src="/2025/03/19/https%E8%AF%A6%E8%A7%A3/https%E8%AF%A6%E8%A7%A3-02.png" class><p>它是在应用层和传输层间加了一个软件层，当进行网络传输时，从上而下就是在加密，从下而上就是在解密。</p><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><blockquote><p>使用同一密钥进行加密和解密</p></blockquote><p>优点：加解密速度快</p><p>缺点：密钥分发（无法安全的通过网络传输将密钥分发给对方，分发过程中也有可能被窃取）</p><p>常见的对称加密算法：</p><ul><li>AES</li><li>DES 3DES</li><li>RC系列（RC2、RC4、RC5）</li></ul><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><blockquote><p>加密和解密使用不同的密钥</p></blockquote><p>非对称加密算法，必须腰有两个密钥，一个公钥，一个私钥</p><p>如果使用公钥加密，必须使用私钥解密；</p><p>如果使用私钥加密，必须使用公钥解密</p><p>优点：可以更安全的将公开密钥传输给通信发送发</p><p>缺点：运算速度慢，与对称加密算法相比大约相差上百倍</p><p>常见非对称加密算法</p><ul><li>RSA</li><li>ECC</li></ul><h2 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h2><p>https采用混合的加密机制。使用非对称加密算法，来加密对称加密的所使用的公钥，然后通信双发交换对称密钥，之后使用对称密钥来进行通信</p><img src="/2025/03/19/https%E8%AF%A6%E8%A7%A3/https%E8%AF%A6%E8%A7%A3-04.png" class><p>但是，仅凭加密，还无法做到绝对安全，数据可能会被中间人劫持。</p><img src="/2025/03/19/https%E8%AF%A6%E8%A7%A3/https%E8%AF%A6%E8%A7%A3-05.png" class><p>主要原因在于，客户端无法区分，收到的公钥是服务器真实的公钥，还是伪造的公钥。</p><p>于是就引入了证书校验机制。</p><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>用来证明公钥拥有者的身份。</p><p>证书包含了公钥信息、拥有者身份信息（主体）、以及数字证书认证机（CA）构对这份文件的数字签名签名</p><p>数字证书认证机构(CA，Certificate Authority)是客户端与服务器双方都可信赖的第三方机构。</p><blockquote><p>业界现行的标准是国际电信联盟电信标准化部门指定的X.509</p></blockquote><img src="/2025/03/19/https%E8%AF%A6%E8%A7%A3/https%E8%AF%A6%E8%A7%A3-03.png" class>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP协议&quot;&gt;&lt;a href=&quot;#HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;HTTP协议&quot;&gt;&lt;/a&gt;HTTP协议&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;超文本传输协议（HTTP）是&lt;strong&gt;应用层&lt;/strong&gt;协议的一种，是</summary>
      
    
    
    
    <category term="网络" scheme="https://c89757.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="协议" scheme="https://c89757.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="网络" scheme="https://c89757.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>记一次mysql死锁问题</title>
    <link href="https://c89757.github.io/2024/08/07/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <id>https://c89757.github.io/2024/08/07/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</id>
    <published>2024-08-07T13:41:21.000Z</published>
    <updated>2025-12-18T19:24:49.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>线上生产报障，查看程序日志，发现某条更新sql报错，报错信息<code>dead lock</code></p><h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p>在Mysql客户端执行命令：<code>show engine innodb status</code>，可以查看到死锁信息（默认只会记录最后一次发生死锁的信息）</p><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><ul><li>事务隔离级别</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@global</span>.tx_isolation</span><br></pre></td></tr></table></figure><blockquote><p>REPEATABLE-READ</p></blockquote><ul><li>新建测试表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test_deadlock`  (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `account_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `message_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  INDEX `idx_tenant_id`(`tenant_id`, `account_id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  INDEX `idx_message_id`(`message_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br></pre></td></tr></table></figure><ul><li>插入测试数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tmp`.`test_deadlock` (`id`, `tenant_id`, `account_id`, `message_id`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tmp`.`test_deadlock` (`id`, `tenant_id`, `account_id`, `message_id`) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tmp`.`test_deadlock` (`id`, `tenant_id`, `account_id`, `message_id`) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tmp`.`test_deadlock` (`id`, `tenant_id`, `account_id`, `message_id`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tmp`.`test_deadlock` (`id`, `tenant_id`, `account_id`, `message_id`) <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tmp`.`test_deadlock` (`id`, `tenant_id`, `account_id`, `message_id`) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><ul><li>复现</li></ul><table><thead><tr><th>时刻</th><th>事务1</th><th>事务2</th></tr></thead><tbody><tr><td>T1</td><td>begin;</td><td>begin;</td></tr><tr><td>T2</td><td>SELECT * FROM test_deadlock force index(idx_tenant_id) where tenant_id = ‘123’ and account_id in (‘X’) for update</td><td></td></tr><tr><td>T3</td><td></td><td>SELECT * FROM test_deadlock force index(idx_message_id) where message_id = 200 and account_id in (‘Z’,’X’) for update</td></tr><tr><td>T4</td><td></td><td>阻塞</td></tr><tr><td>T5</td><td>SELECT * FROM test_deadlock force index(idx_tenant_id) where tenant_id = ‘123’ and account_id in (‘Z’) for update</td><td></td></tr></tbody></table><br><p><code>show engine innodb status</code>执行后的日志:</p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 349487, ACTIVE 4 sec fetching rows</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 4 lock struct(s), heap size 1136, 12 row lock(s)</span><br><span class="line">MySQL thread id 11, OS thread handle 31016, query id 739 localhost ::1 root Sending data</span><br><span class="line">SELECT * FROM test_deadlock force index(idx_message_id) where message_id = 200 and</span><br><span class="line">account_id in (&#x27;Z&#x27;, &#x27;X&#x27;) for update</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED: # 等待的锁信息</span><br><span class="line"><span class="meta">#</span><span class="bash"> 准备对主键索引加record锁</span></span><br><span class="line">RECORD LOCKS space id 444 page no 3 n bits 80 index PRIMARY of table `tmp`.`test_deadlock` trx id 349487 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 9 PHYSICAL RECORD: n_fields 6; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000006; asc     ;; # 主键=6这一行</span><br><span class="line"> 1: len 6; hex 00000005374c; asc     7L;;</span><br><span class="line"> 2: len 7; hex 39000002420842; asc 9   B B;;</span><br><span class="line"> 3: len 3; hex 313233; asc 123;;    # tenantId = 123</span><br><span class="line"> 4: len 1; hex 58; asc X;;          # account_id = &#x27;X&#x27;</span><br><span class="line"> 5: len 8; hex 80000000000000c8; asc         ;;</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION: # 事务2的信息</span><br><span class="line"><span class="meta">#</span><span class="bash"> 事务id: 349486 &lt; 349487, 说明比事务1早开始</span></span><br><span class="line">TRANSACTION 349486, ACTIVE 8 sec starting index read, thread declared inside InnoDB 5000</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">5 lock struct(s), heap size 1136, 5 row lock(s)</span><br><span class="line">MySQL thread id 3, OS thread handle 31696, query id 743 localhost ::1 root Sending data</span><br><span class="line">SELECT * FROM test_deadlock force index(idx_tenant_id) where tenant_id = &#x27;123&#x27; and account_id in (&#x27;Z&#x27;) for update</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line"><span class="meta">#</span><span class="bash"> 持有的锁信息 主键索引上 主键=6的这一行</span></span><br><span class="line">RECORD LOCKS space id 444 page no 3 n bits 80 index PRIMARY of table `tmp`.`test_deadlock` trx id 349486 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 9 PHYSICAL RECORD: n_fields 6; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000006; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000005374c; asc     7L;;</span><br><span class="line"> 2: len 7; hex 39000002420842; asc 9   B B;;</span><br><span class="line"> 3: len 3; hex 313233; asc 123;;</span><br><span class="line"> 4: len 1; hex 58; asc X;;</span><br><span class="line"> 5: len 8; hex 80000000000000c8; asc         ;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line"><span class="meta">#</span><span class="bash"> 事务2正在等待的锁</span></span><br><span class="line">RECORD LOCKS space id 444 page no 3 n bits 80 index PRIMARY of table `tmp`.`test_deadlock` trx id 349486 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 11 PHYSICAL RECORD: n_fields 6; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000005; asc     ;;</span><br><span class="line"> 1: len 6; hex 000000053750; asc     7P;;</span><br><span class="line"> 2: len 7; hex 3b000002430574; asc ;   C t;;</span><br><span class="line"> 3: len 3; hex 313233; asc 123;;</span><br><span class="line"> 4: len 1; hex 5a; asc Z;;</span><br><span class="line"> 5: len 8; hex 80000000000000c8; asc         ;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br></pre></td></tr></table></figure><br><p>根本原因就是并发情况下，索引顺序不一致，导致加锁顺序不一致产生的死锁</p><br><img src="/2024/08/07/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/T1.png" class><br><img src="/2024/08/07/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/T2.png" class><br><blockquote><p>By the way! 即使事务2的语句改为只查询’Z’也会发生死锁：  </p><p>SELECT * FROM test_deadlock force index(idx_message_id) where message_id = 200 and account_id in (‘Z’) for update；</p><p>这是因为：二级索引上包含的信息，并不能判断条件是否成立，所以需要获取下一行数据，继续回表扫描。</p></blockquote><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul><li>诱导<code>mysql</code>执行器走同一个索引</li><li>从业务上面，避免这种场景</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;线上生产报障，查看程序日志，发现某条更新sql报错，报错信息&lt;code&gt;dead lock&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;排查&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://c89757.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://c89757.github.io/tags/MySQL/"/>
    
    <category term="questions" scheme="https://c89757.github.io/tags/questions/"/>
    
  </entry>
  
  <entry>
    <title>Reactor模型</title>
    <link href="https://c89757.github.io/2024/07/10/Reactor%E6%A8%A1%E5%9E%8B/"/>
    <id>https://c89757.github.io/2024/07/10/Reactor%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-07-10T14:55:02.000Z</published>
    <updated>2025-12-21T11:13:20.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><blockquote><p>资源的”通行证”</p></blockquote><p>在Linux系统中，文件描述符是一个非负整数，用来标识和管理一个打开的资源。</p><p>Linux系统中，一切皆文件。不管是磁盘上的文件、网络链接（Socket），管道（Pipe），还是键盘硬件设备，在Linux系统中都被称为”文件”。文件描述符就像一张”通行证”，让你能对这些资源进行读、写、关闭等操作</p><p>怎么使用文件描述符？</p><p>以读取一个文件<code>note.txt</code>为例：</p><ol><li>打开文件：程序告诉Linux，”我要用note.txt”，系统返回一个文件描述符（fd=3）</li><li>读写操作：用这个<code>fd</code>去读取或写入数据</li><li>关闭文件：用完后归还”通行证”，释放资源</li></ol><p>文件描述符是用户程序和Linux内核之间的”桥梁”。当你写程序向读文件、发网络数据、或控制设备时，文件描述符帮你把请求传递给内核，内核再去操作底层的资源</p><p><strong>文件描述符的限制</strong></p><p>Linux为了保护系统资源和安全，设置了文件描述符的限制。</p><blockquote><p>资源管理：文件描述符会占用内存和CPU，打开太多会导致系统卡顿</p><p>安全防护：防止恶意程序无限打开文件，搞乱系统</p></blockquote><ol><li>软限制</li></ol><p>软限制可以临时调整，但不能超过硬限制</p><ul><li>查看软限制 <code>ulimit - Sn</code></li><li>修改软限制：<code>ulimit -Sn 修改后的数量</code> ，如<code>ulimit -Sn 2048</code></li></ul><ol start="2"><li>硬限制</li></ol><p>硬限制是系统的硬性规定，连管理员也必须遵守，除非修改配置文件</p><ul><li>查看硬限制<code>ulimit -Hn</code></li></ul><ol start="3"><li>不同级别的限制</li></ol><ul><li>进程级： 每个程序（进程）有自己的文件描述符”配额”，查看：<code>cat /proc/[pid]/limits</code></li><li>用户级：特定用户或组的限制，配置在：<code>/etc/security/limits.conf</code></li></ul><h1 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>Blocking IO</p><blockquote><p>应用进程被阻塞，直到数据复制到用户缓冲区中才返回</p></blockquote><img src="/2024/07/10/Reactor%E6%A8%A1%E5%9E%8B/BIO.png" class><br><br><br><br><p>或者如下图：</p><img src="/2024/07/10/Reactor%E6%A8%A1%E5%9E%8B/BIO-2.png" class><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>Non-blocking IO</p><img src="/2024/07/10/Reactor%E6%A8%A1%E5%9E%8B/NIO.png" class><br><blockquote><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成。</p><p>需要不断轮询内核，数据是否就绪，涉及太多无效频繁的系统调用。</p></blockquote><ul><li>阻塞IO与非阻塞IO的主要区别在于内核中数据尚未就绪时，如何处理</li></ul><p>对于非阻塞IO，则直接返回给用户态<code>EWOULDBLOCK</code>错误；而阻塞IO则一直处于阻塞状态，直到数据就绪并从内核态拷贝到用户态后才返回。</p><blockquote><p>非阻塞I/O在调用<code>recvform</code>时，需要主动参与内核数据到用户空间的拷贝，这一阶段也会阻塞</p></blockquote><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><h3 id="select-poll"><a href="#select-poll" class="headerlink" title="select/poll"></a>select/poll</h3><p>非阻塞IO：涉及多次无用、频繁的系统调用。非阻塞socket在read时，并不知道啥时候数据会准备好，所以需要不断主动询问。</p><img src="/2024/07/10/Reactor%E6%A8%A1%E5%9E%8B/io-select.png" class><br><ul><li>select调用——等待任意socket可读</li></ul><ol><li>应用程序调用<code>select()</code>，传入一组socket文件描述符（如fd10，fd11，fd12）</li><li>内核检查这些socket是否有数据可读</li><li>如果没有数据到达，内核会让当前进程进入阻塞状态，直到一个socket有数据</li></ol><blockquote><p><code>select</code>是默认同步阻塞的，可以设置超时</p></blockquote><br><ul><li>当某个socket数据就绪——&gt; 返回可读状态</li></ul><ol><li>当某个socket收到一个数据包</li><li>内核将该socket标记为”可读”</li><li><code>select()</code>返回，告诉应用程序：”现在可以读取数据了”</li><li>应用程序知道哪个socket就绪后，开始调用<code>recvfrom()</code>来获取数据</li></ol><blockquote><p>select的作用就是：一次性检测多个socket的状态，避免轮询每个socket</p></blockquote><br><ul><li><code>recvfrom</code>调用——实际接收数据</li></ul><ol><li>应用程序调用<code>recvfrom()</code>，传入socket文件描述符，请求从已知socket读取数据</li><li>内核执行数据拷贝：将数据从内核缓冲区复制到用户空间缓冲区</li><li>这个过程也是阻塞的：如果数据还没完全准备好，进程也会卡住</li></ol><br><p>​    使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 <code>recvfrom</code> 把数据从内核复制到进程中。</p><p>​    它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</p><br><blockquote><p>IO多路复用主要复用的是系统调用。</p><p>从原先非阻塞IO的情况下，多个client需要各自发送<code>recvfrom</code>系统调用去不断询问内核数据是否已就绪；转变成了现在通过一次系统调用select/poll，由内核主动通知用户哪些client已就绪（read、write、accept等事件）。大大减少了无效的系统调用次数</p></blockquote><br><p>select/poll在调用时，都需从用户态拷贝管理的全量描述符到内核态；</p><p>返回时都从内核态拷贝全量的描述符到用户态；再由用户态遍历全量的描述符判断哪些描述符有就绪事件</p><ul><li><p>优点：利用了一次系统调用select()/poll()就可以实现管理多个client的事件（read、write、accept等）。大大降低了之前非阻塞IO频繁无效的系统调用</p></li><li><p>缺点：每次select()/poll()都需要将注册管理的多个client从用户态拷贝到内核态。在连接数很多上百万时。拷贝带来的资源开销较大，影响性能</p></li></ul><p><strong>select() vs poll()</strong></p><table><thead><tr><th>特性</th><th>select()</th><th>poll()</th></tr></thead><tbody><tr><td>fd数量限制</td><td>有（FD_SETSIZE，通常是1024）</td><td>理论上无限制（仅受到系统资源限制）</td></tr><tr><td>fd集合表示</td><td>使用位图</td><td>使用数组</td></tr><tr><td>超时精度</td><td>微秒</td><td>毫秒</td></tr><tr><td>时间复杂度</td><td>O(n)</td><td>O(n)</td></tr></tbody></table><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><blockquote><p>select()/poll()每次调用都需要拷贝管理的全量的fd到内核态，影响性能</p></blockquote><img src="/2024/07/10/Reactor%E6%A8%A1%E5%9E%8B/io-epoll.png" class><p><strong>epoll的三大系统调用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建 epoll 实例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>; <span class="comment">// size 建议为 1024 或更大，实际由内核自动扩展</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 注册/修改/删除文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 等待事件发生</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>epoll_create()</code></td><td>创建一个 epoll 实例，返回一个文件描述符（<code>epfd</code>）</td></tr><tr><td><code>epoll_ctl()</code></td><td>控制 epoll 实例:   • <code>EPOLL_CTL_ADD</code>：添加 fd   • <code>EPOLL_CTL_MOD</code>：修改监听事件 • <code>EPOLL_CTL_DEL</code>：删除 fd</td></tr><tr><td><code>epoll_wait()</code></td><td>阻塞等待事件，返回就绪的 fd 列表</td></tr></tbody></table><p><strong>epoll的核心数据结构</strong></p><p>epoll的搞笑源于其内部数据结构设计</p><ol><li>红黑树<ul><li>存储所有被监控的socket（fd）</li><li>支持快速插入、删除、查找</li><li>当调用<code>epo_ctr(ADD)</code>时，内核会把fd插入这棵树</li></ul></li><li>就绪链表<ul><li>存储当前已经就绪（可读/可写）的fd</li><li>当某个socket收到数据时，内核会将其加入此链表</li><li><code>epoll_wait()</code>只需要遍历这个链表，事件复杂度为O(1)</li></ul></li><li>事件回调机制<ul><li>内核在收到数据后，会：<ul><li>把对应的socket（的fd）加入就绪链表</li><li>如果有进程在<code>epoll_wait()</code>上阻塞，就唤醒它</li></ul></li></ul></li></ol><p><strong>epoll的工作模式</strong></p><p>epoll的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）</p><ul><li><p>LT模式</p><p>当<code>epoll_wait()</code>检测到描述符事件到达时，将此事件通知进程，此进程可以不立即处理该事件，下次调用 <code>epoll_wait()</code> 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p></li><li><p>ET模式</p><p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 <code>epoll_wait()</code> 时不会再得到事件到达的通知。</p><p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p></li></ul><h2 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a>信号驱动I/O</h2><p>​    应用进程使用 <code>sigaction</code> 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。</p><p>​    内核在数据到达时向应用进程发送 <code>SIGIO</code> 信号，应用进程收到之后在信号处理程序中调用<code>recvfrom</code> 将数据从内核复制到应用进程中。</p><img src="/2024/07/10/Reactor%E6%A8%A1%E5%9E%8B/io-sign.png" class><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><blockquote><p>异步I/O</p></blockquote><img src="/2024/07/10/Reactor%E6%A8%A1%E5%9E%8B/AIO.png" class><p>​    进行 <code>aio_read</code> 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p><p>​    异步I/O与信号驱动I/O的区别在于，信号驱动I/O的信号是通知应用进程可以开始I/O，然后应用进程调用<code>recvfrom</code>将数据从内核拷贝到用户空间。异步I/O的信号是通知应用进程I/O完成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><ul><li><strong>阻塞（Blocking） vs 非阻塞（Non-blocking）</strong>：描述的是 <strong>调用是否立即返回</strong>。(I/O调用是否会挂起进程)</li><li><strong>同步（Synchronous） vs 异步（Asynchronous）</strong>：描述的是 <strong>数据拷贝阶段是否由应用程序参与</strong>。</li></ul></blockquote><p><strong>同步I/O与异步I/O</strong></p><ul><li>同步I/O：应用进程 必须主动参与数据从内核到用户空间的拷贝（即调用<code>recvfrom</code>等，会阻塞）</li><li>异步I/O：不用主动参与数据拷贝。应用程序发起I/O后，内核在后台完成整个操作（包括数据拷贝），完成后通知应用</li></ul><p>BIO、NIO、I/O多路复用、信号驱动I/O都是同步I/O</p><blockquote><p>非阻塞式I/O和信号驱动I/O在等待数据阶段不会阻塞，但是在数据从内核复制到用户空间时会阻塞</p></blockquote><p><strong>区别</strong></p><blockquote><p>前四种I/O模型差异主要在第一阶段，第二阶段是一样的，都是阻塞等待数据从内核拷贝到应用进程</p></blockquote><img src="/2024/07/10/Reactor%E6%A8%A1%E5%9E%8B/io-diff.png" class><br><blockquote><p>这些I/O模式都是要靠操作系统进行支持，应用程序只是提供相应的实现，对操作系统进行调用。</p></blockquote><br><blockquote><p>个人理解：I/O多路复用其实没有第二阶段，它只是负责通知应用程序数据可读，只做一件事：通知。具体怎么读取数据，还是需要应用程序自身主动触发，比如使用同步阻塞读或者同步非阻塞读。是一次独立的I/O事件</p></blockquote><p><strong>容易混淆的概念</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;example.com&quot;</span>, <span class="number">80</span>);</span><br><span class="line">socket.setTimeout(<span class="number">3000</span>); <span class="comment">// 设置读取超时为 3 秒</span></span><br></pre></td></tr></table></figure><p>上述代码调用了<code>socket.setTimeout(3000)</code>后，是否为非阻塞I/O？</p><p>答：不是。<code>socket.setTimeout(3000)</code>并不会改变socket的”阻塞/非阻塞”模式，底层 socket 仍然是阻塞模式。</p><p>除非显式的设置socket为非阻塞,</p><p>非阻塞IO：无论数据是否就绪，系统调用立即返回。</p><ul><li>若有数据 → 返回读取字节数；</li><li>若无数据 → 返回 <code>-1</code> 并设置 <code>errno = EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</li></ul><p><code>socket.setTimeout(3000)</code>行为：调用<code>read()</code>后，最多等待3秒，如果3秒内没数据，抛出异常。不是立即返回。而是限时等待后返回，这叫”带超时的阻塞I/O”</p><br><p><strong>serverSocket.accept()为什么会被阻塞?</strong></p><p>服务器线程发起一个accept动作，询问操作系统 是否有新的socket套接字信息从端口X发送过来。</p><p>注意，是询问操作系统。也就是说socket套接字的IO模式支持是基于操作系统的，那么自然同步IO/异步IO的支持就是需要操作系统级别的了。</p><p>它内部的实现是使用的操作系统级别的同步IO（准确来说应该是同步阻塞I/O——BIO）</p><br><h1 id="惊群效应-C10K"><a href="#惊群效应-C10K" class="headerlink" title="惊群效应/C10K"></a>惊群效应/C10K</h1><ul><li>惊群效应</li></ul><p>​    惊群现象就是多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只可能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群。</p><ul><li>C10K问题</li></ul><blockquote><p>如何让单台服务器同时处理 10,000 个并发客户端连接？</p></blockquote><p>“C” 代表 <strong>Client（客户端）</strong>，“10K” 即 <strong>10,000</strong>。</p><p>该问题本质是<strong>如何高效管理大量并发 I/O 资源</strong></p><p>解决方案：</p><ul><li>I/O多路复用</li><li>非阻塞I/O</li><li>事件驱动架构（Reactor模式）</li></ul><h1 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h1><blockquote><p>Reactor 不是一种 I/O 模型，而是一种事件驱动的软件设计模式（架构模式）<br>而上文所说的五种I/O模型 是操作系统层面的 I/O 模型分类。</p></blockquote><p><strong>Reactor = I/O 多路复用（事件监听） + 同步非阻塞 I/O（事件处理）</strong></p><h2 id="传统IO模型"><a href="#传统IO模型" class="headerlink" title="传统IO模型"></a>传统IO模型</h2><p>​    对于传统IO模型，其主要是一个Server对接N个客户端，在客户端连接之后，为每个客户端都分配一个执行线程。如下图是该模型的一个演示：</p><br><img src="/2024/07/10/Reactor%E6%A8%A1%E5%9E%8B/traditional-io.png" class><br><ol><li>客户都安连接到达之后，服务端会分配一个线程给该客户端，该客户都安处理包括读取数据、解码、计算、编码、发送数据整个过程</li><li>服务端的吞吐量与服务器能提供的线程数量是呈线性关系的</li></ol><p>很显然，在并发量很大时，这种设计模式对于服务器来说压力很大。</p><ul><li>服务端资源有限，可创建线程数有限；且线程切换开销大</li><li>服务端每个线程不仅要进行IO读写，还需要进行业务计算</li><li>服务端在获取客户端连接，读取数据，以及写入数据的过程都是阻塞类型的（accept，read，write），在网络状况不好的情况下，这将极大的降低服务器每个线程的利用率，从而降低服务器吞吐量。</li></ul><h2 id="Reactor事件驱动模型"><a href="#Reactor事件驱动模型" class="headerlink" title="Reactor事件驱动模型"></a>Reactor事件驱动模型</h2><h3 id="单Reactor单线程"><a href="#单Reactor单线程" class="headerlink" title="单Reactor单线程"></a>单Reactor单线程</h3><img src="/2024/07/10/Reactor%E6%A8%A1%E5%9E%8B/single-thread-single-reactor.png" class><ul><li>Reactor（反应器）<ul><li>调度中心</li><li>维护一个I/O多路复用器（如epoll/Selector)</li><li>主动调用 <code>select()</code> / <code>poll()</code> / <code>epoll_wait()</code> 等系统调用，<strong>监听所有注册的 socket 是否有事件就绪</strong></li><li>收到事件后，将事件分发给对应的处理器(Acceptor或handler)</li></ul></li><li>Acceptor<ul><li>专门处理新连接建立的组件</li><li>监听服务端socket的<code>OP_ACCEPT</code>事件</li><li>当有新客户端连接时，调用<code>accept()</code>创建新的客户端<code>socket</code></li><li>将新创建的客户端socket注册到Reactor的多路复用器中，并设置为非阻塞</li></ul></li></ul><p>​    Acceptor会不断接收客户端的连接，然后将收到的连接交由Reactor进行分发，最后由具体的handler进行处理。</p><p>该模型中，除了I/O操作在Reactor线程外，业务逻辑处理操作也在Reactor线程上，当业务逻辑处理比较耗时时，会大大降低I/O请求的处理效率</p><h3 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a>单Reactor多线程</h3><img src="/2024/07/10/Reactor%E6%A8%A1%E5%9E%8B/single-reactor-thread-pool.png" class><br><ul><li>使用一个线程进行客户端连接的接收以及网络读写事件的处理</li><li>在接收到客户端连接后，将该连接交给线程池进行数据的处理</li></ul><p>​    引入了线程池，用来专门处理业务逻辑操作，提升了I/O相应速度</p><p>​    但是在百万级连接、高并发大数据量时，会有大量的客户端数据进行网络读写，单个Reactor线程效率会比较低下</p><h3 id="多Reactor多线程"><a href="#多Reactor多线程" class="headerlink" title="多Reactor多线程"></a>多Reactor多线程</h3><p>​    在单Reactor多线程模式中，由于网络读写在高并发的情况下会成为系统的一个瓶颈，因而针对该模型提出了一种改进后的模型。扩展了Reactor线程，引入了多个Reactor线程。</p><blockquote><p>subReactor可以有多个，图中并没有体现出来</p></blockquote><br><img src="/2024/07/10/Reactor%E6%A8%A1%E5%9E%8B/multi-reactor-multi-thread.png" class><br><ul><li>mainReactor<ul><li>主要用来处理客户端的连接</li><li>监听 服务端  的 <code>OP_ACCEPT</code> 事件；</li><li>当 <code>OP_ACCEPT</code> 就绪时，触发 acceptor 来处理新连接</li></ul></li><li>acceptor<ul><li>是一个事件处理器，被mainReactor回调</li><li>获取新的客户端连接，并将其注册到subReactor上</li></ul></li><li>subReactor<ul><li>接收acceptor注册过来的连接</li><li>监听新连接的读写事件</li></ul></li></ul><ul><li>典型实现<ul><li>Netty</li><li>memcached</li></ul></li></ul><br><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>Reactor = I/O 多路复用（事件监听） + 同步非阻塞 I/O（事件处理）</p><ol><li><p>既然I/O多路复用已经告知数据已准备好，为什么不直接使用同步阻塞I/O来操作数据呢？</p><p>理论上可行，但是现实不可行。因为 I/O多路复用的通知是”瞬时快照“，而状态可能在通知后发生改变。</p><p>比如数据可能被丢弃，多线程下的竞争（比如两个线程针对同一个socket进行read()操作，当被epoll通知告诉数据可读时，线程1将数据读走后，线程2读取数据为空，如果使用同步阻塞I/O读取，线程2就会卡死</p><blockquote><p>每个TCP socket在内核有一个接收缓冲区，所有对这个socket的read()调用都从同一个缓冲区读取数据；数据一旦被 read() 成功拷贝到用户空间，就从内核缓冲区中移除；</p></blockquote></li></ol><h1 id="Java中对多路复用的支持"><a href="#Java中对多路复用的支持" class="headerlink" title="Java中对多路复用的支持"></a>Java中对多路复用的支持</h1><p><strong>Channel</strong></p><p>通道：是建立一个应用程序和操作系统交互事件、传递内容的渠道（注意是连接到操作系统）。</p><p>一个通道会有一个专属的文件状态描述符。应用程序可以通过通道读取数据，也可以通过通道向操作系统写数据</p><br><p><strong>Selector</strong></p><p>选择器，根据Selector的职责，也可以称之为”轮询代理器”</p><p>应用程序将Channel注册到Selector对象上</p><ul><li><p>轮询代理</p><p>应用层不再通过阻塞模式或非阻塞模式直接访问操作系统“事件有没有发生”，而是由Selector代其询问</p></li><li><p>实现不同操作系统的支持</p><p>多路复用I/O是需要操作系统进行支持的，在Java中，要为 不同操作系统的多路复用I/O实现 编写不同的代码</p><p>（也就是说，不同操作系统下，Java针对Selector的实现不同。比如Windows的实现是<code>WindowsSelectorImpl</code>类）</p></li></ul><br><p><strong>Buffer</strong></p><p>数据缓冲区：在Java NIO框架中，为了保证每个Channel的数据读写速度，Java NIO框架为每一种需要支持数据读写的通道集成了Buffer的支持。</p><blockquote><p>不是所有的通道都需要支持数据读写。例如<code>ServerScoketChannel</code>它只支持对<code>OP_ACCEPT</code>事件的监听，所以它是不能直接进行网络数据内容的读写的，所以它就不需要也没有集成Buffer</p></blockquote><p>Buffer有两种工作模式：写模式和读模式</p><p>在读模式下，应用程序只能从Buffer中读取数据，不能进行写操作</p><p>但是在写模式下，应用程序是可以进行读操作的。</p><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerSocket</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        ServerSocket socket = serverSocketChannel.socket();</span><br><span class="line">        socket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务端只能注册`OP_ACCEPT`事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selector.select(<span class="number">3000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;no event....&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里就是本次询问操作系统，所获取到的“所关心的事件”的事件类型(每一个通道都是独立的)</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (selectionKeys.hasNext()) &#123;</span><br><span class="line">                    SelectionKey readyKey = selectionKeys.next();</span><br><span class="line">                    selectionKeys.remove(); <span class="comment">// 已经处理的事件key要移除，不然还会在selectedKeys集合中</span></span><br><span class="line">                    SelectableChannel selectableChannel = readyKey.channel();</span><br><span class="line">                    <span class="keyword">if</span> (readyKey.isValid() &amp;&amp; readyKey.isAcceptable()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;OP_ACCEPT event&quot;</span>);</span><br><span class="line">                        ServerSocketChannel channel = (ServerSocketChannel) selectableChannel;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 在serverSocketChannel接收到/准备好 一个新的 TCP连接后， 会向程序返回一个新的socketChannel， 我们需要将其注册到Selector中</span></span><br><span class="line">                        SocketChannel socketChannel = channel.accept();</span><br><span class="line">                        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        <span class="comment">// socketChannel可以且只可以注册三种事件SelectionKey.OP_READ | SelectionKey.OP_WRITE | SelectionKey.OP_CONNECT</span></span><br><span class="line">                        socketChannel.register(selector, SelectionKey.OP_READ , ByteBuffer.allocate(<span class="number">2048</span>));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readyKey.isValid() &amp;&amp; readyKey.isReadable()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;OP_READ event&quot;</span>);</span><br><span class="line">                        readData(readyKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            serverSocketChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(SelectionKey readyKey)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel clientSocketChannel = (SocketChannel)readyKey.channel();</span><br><span class="line">        <span class="comment">// 拿到这个socket channel使用的缓存区，准备读取数据</span></span><br><span class="line">        ByteBuffer contextBytes = (ByteBuffer)readyKey.attachment();</span><br><span class="line">        <span class="comment">//将通道的数据写入到缓存区，注意是写入到缓存区。</span></span><br><span class="line">        <span class="comment">//由于之前设置了ByteBuffer的大小为2048 byte，所以可以存在写入不完的情况</span></span><br><span class="line">        <span class="comment">//没关系，我们后面来调整代码。这里我们暂时理解为一次接受可以完成</span></span><br><span class="line">        <span class="keyword">int</span> realLen = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            realLen = clientSocketChannel.read(contextBytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="comment">// 这里抛出了异常，一般就是客户端因为某种原因终止了。所以关闭channel就行了</span></span><br><span class="line">            clientSocketChannel.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果缓存区中没有任何数据</span></span><br><span class="line">        <span class="keyword">if</span>(realLen == -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no data...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将缓存区从写状态切换为读状态(实际上这个方法是读写模式互切换)。</span></span><br><span class="line">        <span class="comment">// 这是java nio框架中的这个socket channel的写请求将全部等待。</span></span><br><span class="line">        contextBytes.flip();</span><br><span class="line">        <span class="comment">//注意中文乱码的问题，我个人喜好是使用URLDecoder/URLEncoder，进行解编码。</span></span><br><span class="line">        <span class="comment">//当然java nio框架本身也提供编解码方式，看个人咯</span></span><br><span class="line">        <span class="keyword">byte</span>[] messageBytes = contextBytes.array();</span><br><span class="line">        String messageEncode = <span class="keyword">new</span> String(messageBytes , <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        String message = URLDecoder.decode(messageEncode, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果收到了“over”关键字，才会清空buffer，并回发数据；</span></span><br><span class="line">        <span class="comment">// 否则不清空缓存，还要还原buffer的“写状态”</span></span><br><span class="line">        <span class="keyword">if</span>(message.indexOf(<span class="string">&quot;over&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 清空已经读取的缓存，并从新切换为写状态(这里要注意clear()和capacity()两个方法的区别)</span></span><br><span class="line">            contextBytes.clear();</span><br><span class="line">            System.out.println((<span class="string">&quot;receive message from client: &quot;</span> + message));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回发数据，并关闭channel</span></span><br><span class="line">            ByteBuffer sendBuffer = ByteBuffer.wrap(URLEncoder.encode(<span class="string">&quot;回发处理结果&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).getBytes());</span><br><span class="line">            clientSocketChannel.write(sendBuffer);</span><br><span class="line">            clientSocketChannel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println((<span class="string">&quot;客户端信息还未接受完，继续接受======message : &quot;</span> + message));</span><br><span class="line">            <span class="comment">// 这是，limit和capacity的值一致，position的位置是realLen的位置</span></span><br><span class="line">            contextBytes.position(realLen);</span><br><span class="line">            contextBytes.limit(contextBytes.capacity());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="I-O-调度策略"><a href="#I-O-调度策略" class="headerlink" title="I/O 调度策略"></a>I/O 调度策略</h2><h3 id="NOOP"><a href="#NOOP" class="headerlink" title="NOOP"></a>NOOP</h3><p>No Operation。该算法是实现了简单的FIFO队列，所有I/O请求大致按照先来后到的顺序进行操作。</p><blockquote><p>NOOP 会在FIFO的基础上还做了相邻I/O请求的合并</p></blockquote><h3 id="CFQ"><a href="#CFQ" class="headerlink" title="CFQ"></a>CFQ</h3><p>Completely Fair Queuing。该算法特点是：按照I/O请求地址进行排序，而不是按照先来后到的顺序。</p><p>CFQ是默认的磁盘调度算法。</p><p>先来的I/O请求并不一定被满足，可能出现饥饿现象</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/yinwenjie/article/details/48274255">https://blog.csdn.net/yinwenjie/article/details/48274255</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件描述符&quot;&gt;&lt;a href=&quot;#文件描述符&quot; class=&quot;headerlink&quot; title=&quot;文件描述符&quot;&gt;&lt;/a&gt;文件描述符&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;资源的”通行证”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Linux系统中，文件描述符</summary>
      
    
    
    
    <category term="网络" scheme="https://c89757.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="I/O" scheme="https://c89757.github.io/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>科学上网-自建梯子</title>
    <link href="https://c89757.github.io/2024/05/11/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90/"/>
    <id>https://c89757.github.io/2024/05/11/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90/</id>
    <published>2024-05-11T12:12:58.000Z</published>
    <updated>2024-05-11T14:20:38.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="购买VPS"><a href="#购买VPS" class="headerlink" title="购买VPS"></a>购买VPS</h1><ul><li><p><a href="https://www.vultr.com/">vultr</a>：截至2024-05-10，基本已死。服务器ip大多都ping不通</p></li><li><p><a href="https://manage.hostease.com/store/go-vps">hostease</a>：美国主机商，在香港有机房，香港服务器不需要备案，且支持支付宝付款</p></li></ul><br><blockquote><p>以下操作基于centos7，建议镜像选用centos</p></blockquote><h1 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h1><blockquote><p>用xshell或其他客户端，远程连接上服务器</p></blockquote><h2 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h2><p>依次执行以下命令</p><br><blockquote><p>如果没有wget，先安装：yum install -y wget</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br><span class="line"></span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line"></span><br><span class="line">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure><br><p>根据提示，输入密码、端口、加密方式，等待安装即可。</p><br><p>上述安装完成之后，一般速度较慢，所以我们需要配置加速（类似于一种算法，能加速网络传输）</p><p>安装Google BBR：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget — no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span><br><span class="line"></span><br><span class="line">chmod +x bbr.sh</span><br><span class="line"></span><br><span class="line">./bbr.sh</span><br></pre></td></tr></table></figure><br><p>显示 “Press any key to start…” 按回车确认。</p><p>提示重启VPS，输入Y确认，等待重启即可</p><br><p><strong>补充</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/shadowsocks start      # 启动</span><br><span class="line">/etc/init.d/shadowsocks stop       # 停止</span><br><span class="line">/etc/init.d/shadowsocks restart    # 重启</span><br><span class="line">/etc/init.d/shadowsocks status     # 状态</span><br></pre></td></tr></table></figure><p><a href="https://jackmezone.medium.com/vultr%E6%90%AD%E5%BB%BAss%E5%8F%8A%E9%94%90%E9%80%9F%E4%BC%98%E5%8C%96%E5%8A%A0%E9%80%9F%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B-69763d7e2cdc">原文链接</a></p><h1 id="安装客户端"><a href="#安装客户端" class="headerlink" title="安装客户端"></a>安装客户端</h1><h2 id="shadowsocks-1"><a href="#shadowsocks-1" class="headerlink" title="shadowsocks"></a>shadowsocks</h2><p>官网下载客户端：</p><p><a href="https://github.com/shadowsocks/shadowsocks-windows/releases">https://github.com/shadowsocks/shadowsocks-windows/releases</a></p><p>下载完成安装之后，打开客户端，配置ip、密码、加速方式即可</p><br><img src="/2024/05/11/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90/image-20240511214852432.png" class><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="godaddy"><a href="#godaddy" class="headerlink" title="godaddy"></a>godaddy</h2><p>美国域名服务器，不需要备案</p><p><a href="https://www.godaddy.com/en-sg">官网链接</a></p><blockquote><p>官网被墙了，需要梯子才可访问。而且其官网本身会检测VPN，一般市场上的机场用的人多，都会被检测出来，通过自建的VPN可以访问</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;购买VPS&quot;&gt;&lt;a href=&quot;#购买VPS&quot; class=&quot;headerlink&quot; title=&quot;购买VPS&quot;&gt;&lt;/a&gt;购买VPS&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.vultr.com/&quot;&gt;vultr&lt;/a&gt;：截至2024</summary>
      
    
    
    
    <category term="网络" scheme="https://c89757.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="other" scheme="https://c89757.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB-FullTextIndex</title>
    <link href="https://c89757.github.io/2024/04/24/InnoDB-FullTextIndex/"/>
    <id>https://c89757.github.io/2024/04/24/InnoDB-FullTextIndex/</id>
    <published>2024-04-24T11:24:50.000Z</published>
    <updated>2025-12-18T17:11:58.399Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>InnoDB全文检索索引，是基于文本的列(CHAR、VARCHAR或TEXT列)上创建的，以加快对这些列中包含的数据的查询和DML操作。</p><p>InnoDB全文索引采用了倒排索引设计。倒排索引存储一个单词列表，对于每个单词，存储该单词出现在其中的文档列表。为了支持邻近搜索，每个字的位置信息也以字节偏移量的形式存储</p><p><code>MySql5.7.6</code>之前，全文检索只支持英文索引，不支持中文全文索引。</p><p><code>MySql5.7.6</code>之后，内置了<code>ngram</code>全文解析器，用来支持中文、日文、韩文分词</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>全文搜索使用MATCH() AGAINST()语法执行。MATCH()接受一个逗号分隔的列表，该列表指定要搜索的列。AGAINST接受一个要搜索的字符串和一个可选的修饰符，该修饰符指示要执行的搜索类型。</p></blockquote><p>全文检索支持三种搜索方式</p><ul><li><p>自然语言搜索</p><p>将搜索字符串解释为自然人类语言中的短语(自由文本中的短语)。</p><p>如果给出了<code>IN natural language MODE</code>修饰符，或者没有给出修饰符，全文搜索就是自然语言搜索。</p></li><li><p>boolean搜索</p><p>使用特殊查询语言的规则解释搜索字符串。</p><p>字符串包含要搜索的单词。例如某个单词必须在匹配行中出现或不存在</p></li><li><p>查询扩展搜索</p><p>是对自然语言搜索的修改。</p><p>搜索字符串用于执行自然语言搜索。然后将搜索返回的最相关行的单词添加到搜索字符串中，并再次进行搜索。该查询返回第二次搜索的行。</p></li></ul><h1 id="自然语言搜索"><a href="#自然语言搜索" class="headerlink" title="自然语言搜索"></a>自然语言搜索</h1><blockquote><p>默认情况下或使用IN NATURAL LANGUAGE MODE修饰符时，MATCH()函数针对文本集合执行字符串的自然语言搜索。集合是包含在FULLTEXT索引中的一个或多个列的集合。搜索字符串作为参数提供给AGAINST()。对于表中的每一行，MATCH()返回一个相关性值;也就是说，搜索字符串与MATCH()列表中指定的列中该行中的文本之间的相似性度量。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   title <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   body TEXT,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   FULLTEXT (title,body)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.08</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> articles (title,body) <span class="keyword">VALUES</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   (<span class="string">&#x27;MySQL Tutorial&#x27;</span>,<span class="string">&#x27;DBMS stands for DataBase ...&#x27;</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   (<span class="string">&#x27;How To Use MySQL Well&#x27;</span>,<span class="string">&#x27;After you went through a ...&#x27;</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   (<span class="string">&#x27;Optimizing MySQL&#x27;</span>,<span class="string">&#x27;In this tutorial, we show ...&#x27;</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   (<span class="string">&#x27;1001 MySQL Tricks&#x27;</span>,<span class="string">&#x27;1. Never run mysqld as root. 2. ...&#x27;</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   (<span class="string">&#x27;MySQL vs. YourSQL&#x27;</span>,<span class="string">&#x27;In the following database comparison ...&#x27;</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>   (<span class="string">&#x27;MySQL Security&#x27;</span>,<span class="string">&#x27;When configured properly, MySQL ...&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">6</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">6</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="keyword">MATCH</span> (title,body)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> AGAINST (<span class="string">&#x27;database&#x27;</span> <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------+------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> title             <span class="operator">|</span> body                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------+------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> MySQL Tutorial    <span class="operator">|</span> DBMS stands <span class="keyword">for</span> DataBase ...             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> MySQL vs. YourSQL <span class="operator">|</span> <span class="keyword">In</span> the following database comparison ... <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------+------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>默认情况下，以不区分大小写的方式执行搜索。若要执行区分大小写的全文搜索，请对索引列使用二进制排序。例如，可以为使用的<code>latin1</code>字符集的列分配<code>latin1_bin</code>排序规则，使其对全文搜索区分大小写。</p><p>当在WHERE子句中使用MATCH()时，如前面所示的示例，只要满足以下条件，返回的行将自动按照最高相关性优先排序：</p><ul><li>必须没有显式的ORDER BY子句。</li><li>必须使用全文索引扫描而不是表扫描来执行搜索。</li><li>如果查询连接表，则全文索引扫描必须是连接中最左边的非常量表。</li></ul><p>要计算count值，你可以这么写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> articles </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span> (title,body)</span><br><span class="line">AGAINST (<span class="string">&#x27;database&#x27;</span> <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE);</span><br></pre></td></tr></table></figure><p>有时候这样写可能会更快</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">     <span class="built_in">COUNT</span>(IF(<span class="keyword">MATCH</span> (title,body) AGAINST (<span class="string">&#x27;database&#x27;</span> <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE), <span class="number">1</span>, <span class="keyword">NULL</span>))</span><br><span class="line">     <span class="keyword">AS</span> count</span><br><span class="line">     <span class="keyword">FROM</span> articles;</span><br></pre></td></tr></table></figure><blockquote><p>第一个查询做了一些额外的工作(根据相关性对结果排序)，但也可以使用基于WHERE子句的索引查找。如果搜索匹配的行很少，索引查找可能会使第一个查询更快。第二个查询执行全表扫描，如果搜索词出现在大多数行中，则可能比索引查找快。</p></blockquote><p>对于自然语言全文搜索，MATCH()函数中命名的列必须与表中某些<code>FULLTEXT</code>索引中包含的列相同。</p><p>对于前面的查询，MATCH()函数中指定的列(title和body)与文章表<code>FULLTEXT</code>索引定义中指定的列相同。</p><p>要分别搜索标题或正文，需要为每列创建单独的<code>FULLTEXT</code>索引。</p><p>使用索引的全文搜索只能在MATCH()子句中命名单个表中的列，因为索引不能跨多个表。</p><h1 id="全文索引表"><a href="#全文索引表" class="headerlink" title="全文索引表"></a>全文索引表</h1><p>创建InnoDB全文索引时，会创建一组索引表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table_id, name, space <span class="keyword">from</span> INFORMATION_SCHEMA.INNODB_SYS_TABLES;</span><br></pre></td></tr></table></figure><p>辅助索引表名的前缀是<code>FTS</code>_，后缀是<code>index_#</code>。每个辅助索引表通过与被索引表的<code>table_id</code>匹配的辅助索引表名中的十六进制值与被索引表相关联。</p><h1 id="全文检索缓存"><a href="#全文检索缓存" class="headerlink" title="全文检索缓存"></a>全文检索缓存</h1><p>当文本被插入时，将对其进行标记，并将单个单词和相关数据插入全文索引中。</p><p>这个过程，即使对于文本比较小，也可能导致对索引表进行大量小的插入，从而使对这些表的并发访问成为争用点。</p><p>为了避免这个问题，InnoDB使用全文索引缓存来临时缓存索引表中最近插入的行。</p><p>插入时先保存到这个内存缓存结构，直到缓存满，然后将它们批量刷新到磁盘(到辅助索引表)</p><p>可以通过如下语句，查询最近插入的行的标记化数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_FT_INDEX_CACHE;</span><br></pre></td></tr></table></figure><p>缓存和批处理刷新行为避免了对辅助索引表的频繁更新，还避免了对同一个单词的多次插入，并最大限度地减少了重复条目。不是逐个刷新每个单词，而是将相同单词的插入合并并作为单个条目刷新到磁盘，从而提高了插入效率，同时使辅助索引表尽可能小。</p><blockquote><p>全文索引缓存，仅仅为最近插入的行 缓存标记化的数据，查询时，已经刷新到磁盘的数据不会被带回到全文检索缓存中。直接查询辅助索引表中的数据，并且在返回之前，将辅助索引表中的结果与全文索引缓存中的结果合并。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;InnoDB全文检索索引，是基于文本的列(CHAR、VARCHAR或TEXT列)上创建的，以加快对这些列中包含的数据的查询和DML操作。&lt;/p&gt;
&lt;p&gt;InnoDB全文索引采用了倒排索引设计。倒排索引存储一个单词列表，对于每个单词，存储该单词出现在</summary>
      
    
    
    
    <category term="MySQL" scheme="https://c89757.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://c89757.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>XA事务与两阶段提交</title>
    <link href="https://c89757.github.io/2024/04/23/XA%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/"/>
    <id>https://c89757.github.io/2024/04/23/XA%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/</id>
    <published>2024-04-22T16:15:30.000Z</published>
    <updated>2025-12-18T17:06:40.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>MySQL分为server层和存储引擎层，而<strong>事务具体是在存储引擎层实现的</strong>。</p><p>在书写包含在一个事务中的语句时，不同语句可能会涉及不同存储引擎的表，这时如果我们想保持整个事务要么全部执行，要么全部不执行的话，本质上就需要保证各个存储引擎的事务全部提交，或者全部回滚。</p></blockquote><p>我们有一个大的事务，我们可以称其为<code>全局事务</code>，这个全局事务由若干的小的事务组成。要实现这个大的事务，就必须让它对应的若干个小的事务全部完成，或者全部回滚。我们也可以把这个大的全局事务称作<code>分布式事务</code>。</p><h1 id="XA规范"><a href="#XA规范" class="headerlink" title="XA规范"></a>XA规范</h1><p>XA规范提出了2个角色</p><ul><li>一个全局事务由多个小的事务组成，所以需要一个事务协调器（Transaction Coordinator）或资源管理器（Resource Manager）</li><li>管理一个小事务的角色被称为事务管理器（Transaction Manager）</li></ul><p>要提交一个全局事务，那么属于该全局事务的若干个小事务就应该全部提交，只要有任何一个小事务无法提交，那么整个全局事务就应该全部回滚。</p><p>XA规范中指出，要提交一个全局事务，必须分为2步</p><ul><li><p>Prepare阶段</p><p>当事务协调器准备提交一个全局事务时，会依次通知各个事务管理器，进行提交，如果事务管理器觉得没有问题，就把执行过程中所产生的redo日志都刷新到磁盘，然后应答事务协调器；如果事务协调器不能正确提交事务，则也需要通知事务协调器</p></li><li><p>Commit阶段</p><p>如果在Prepare阶段各个事务管理器给事务协调器的应答都是OK，没有问题，那么事务协调器就要真正通知各个事务管理器，去提交事务。</p><p>如果Prepare阶段有事务管理器给事务协调器的应答是，不能提交事务，于是事务协调器就通知各个事务管理器，进行事务回滚。</p><p>不过在事务协调器在统一提交和回滚之前，都需要在某个地方记录一下这个全局事务已提交，以及各个子事务的状态信息。</p></li></ul><p>XA规范把上述全局事务提交时所经历的两个阶段称作<strong>两阶段提交</strong>。</p><h1 id="MySql中的XA事务"><a href="#MySql中的XA事务" class="headerlink" title="MySql中的XA事务"></a>MySql中的XA事务</h1><p>MySQL中的XA事务分为<code>外部XA</code>和<code>内部XA</code></p><h2 id="外部XA"><a href="#外部XA" class="headerlink" title="外部XA"></a>外部XA</h2><p>在MySql的外部XA实现中，MySql服务器充当事务管理器，而连接服务器的客户端程序充当事务协调器。</p><p>想在MySQL中使用XA事务，需要一些特殊的语句：</p><ul><li><code>XA &#123;START|BEGIN&#125; xid</code> ：该语句用于开启一个<code>XA</code>事务，此时该<code>XA</code>事务处于<code>ACTIVE</code>状态。</li></ul><p>在一台MySql服务器上，每个XA事务都必须有一个唯一的id，被称作<code>xid</code>。这个<code>xid</code>是由发其<code>XA</code>事务的应用程序（客户端）自己指定的，只要我们自己保证它唯一就好了。</p><p>这个<code>xid</code>其实是由<code>gtrid</code>、<code>bqual</code>、<code>formatID</code>三个部分组成的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xid: gtrid [, bqual [, formatID ]]</span><br></pre></td></tr></table></figure><p>其中<code>gtrid</code>（global transaction id）是指全局事务id，是一个字符串，<code>bqual</code>是指分支限定符，<code>formatID</code>是指<code>gtrid</code>和<code>bqual</code>所使用的格式。<code>bqual</code>和<code>formatID</code>省略。</p><ul><li><p><code>XA END xid</code>：在使用<code>XA START xid</code>开启了一个XA事务后，客户端就可以接着发送属于这个XA事务的各条语句，等所有语句都发送完毕后，就可以接着发送<code>XA END xid</code>来告知服务器由<code>xid</code>标识的XA事务的所有语句都输入完了。此时该XA事务处于<code>IDLE</code>状态。</p></li><li><p><code>XA PREPARE xid</code>：对于处于<code>IDLE</code>状态的XA事务，应用程序就可以询问MySQL服务器是否准备好提交这个XA事务了，此时就可以给服务器发送<code>XA PREPARE xid</code>语句。当MySQL服务器收到此语句后，就需要做准备提交前的工作了，比如把该事务执行过程中所产生的redo日志刷新到磁盘等。此时XA事务处于<code>PREPARE</code>状态。</p></li><li><p><code>XA ROLLBACK xid</code>：应用程序通过发送此语句来让MySQL服务器回滚xid所标识的事务。此时XA事务处于<code>ABORT</code>状态。</p></li><li><p><code>XA RECOVER</code>：应用程序想看一下当前MySQL服务器上已经处于Prepare状态的XA事务有哪些，就可以发送该语句。</p></li></ul><p>现在各个公司由于表中数据太多，这些数据会被分散在不通服务器中存储。由应用程序员分别和不同的MySQL服务器打交道实在费劲，所以有一种称作<code>数据库中间件</code>的东西开始问世。即应用程序只将SQL语句发送给数据库中间件，中间件分析一下该SQL访问的数据都在哪些不同的服务器中存储着，并且计算出不通服务器应该执行哪些SQL语句。然后就可以对不同的服务器分别开启XA事务，并且让把不同服务器需要执行的语句分别发送到不同的服务器中。等应用程序员告知中间件准备提交事务时，中间件先给各个服务器发送<code>XA PREPARE</code>语句，如果各个服务器都返回OK的话，接着就给各个服务器发送<code>XA COMMIT</code>语句来提交XA事务，等各个服务器把提交成功的消息返回给中间件，中间件就可以通知应用程序事务提交成功了。</p><h2 id="内部XA"><a href="#内部XA" class="headerlink" title="内部XA"></a>内部XA</h2><p>对于一台服务器来说，即使客户端使用<code>BEGIN/START TRANSACTION</code>语句开启的普通事务，事务所包含的语句也有可能涉及多个存储引擎。此时MySQL内部采用XA规范来保证所有支持事务的存储引擎要么全部提交，要么全部回滚，这也被称作MySQL的<code>内部XA</code>。</p><p>在MySQL内部执行一个事务时，存储引擎会修改相应的数据，server层会记录语句对应的binlog。这是一个原子性的行为，要么都完成，要么都不完成</p><p>那我们需要保证：如果存储引擎提交了事务，server层的<code>binlog</code>日志必须也被写入到硬盘上；如果存储引擎回滚了事务，server层的<code>binlog</code>日志必须不能被写入到硬盘上。</p><p>那我们需要保证：<strong>如果存储引擎提交了事务，server层的binlog日志必须也被写入到硬盘上；如果存储引擎回滚了事务，server层的binlog日志必须不能被写入到硬盘上</strong>。</p><h2 id="有binlog参与的内部XA事务"><a href="#有binlog参与的内部XA事务" class="headerlink" title="有binlog参与的内部XA事务"></a>有binlog参与的内部XA事务</h2><p> 当客户端执行<code>COMMIT</code>语句或者在自动提交的情况下，MySQL内部开启一个XA事务，分两阶段来完成XA事务的提交：</p><ul><li><p>Prepare阶段：存储引擎将该事务执行过程中产生的redo日志刷盘，并且将本事务的状态设定为<code>PREPARE</code>。<code>binlog</code>啥也不干，下面看一下具体的代码</p><p>首先我们知道事务执行过程中需要写undo日志，这些undo日志被写到若干个页面中，这些页面也被称作<code>Undo页面</code>，这些页面会串成一个链表，称作<code>Undo页面</code>链表。在一个事务对应的Undo页面链表的首个页面中，记录了一些关于这个事务的一些属性。</p></li></ul><p><img src="/2024/04/23/XA%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/typora-user-images\XA事务与两阶段提交\image-20240423221552725.png" alt="image-20240423221552725"></p><p><code>Undo Log Segment Header</code>部分</p><p><img src="/2024/04/23/XA%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/typora-user-images\XA事务与两阶段提交\image-20240423221840133.png" alt="image-20240423221840133"></p><p>其中的<code>TRX_UNDO_STATE</code>字段就表明该事务目前处于什么状态。当处于Prepare阶段时，会将<code>TRX_UNDO_STATE</code>字段的值设置为<code>TRX_UNDO_PREPARED</code>（整数5），表明当前事务处在Prepare阶段。</p><p><code>Undo Log Header</code>部分：</p><p>包括了各种信息，其中有两个属性</p><p><code>TRX_UNDO_XID_EXISTS</code>：表示有没有xid信息</p><p><code>XID</code>信息：表示具体的xid是什么</p><p>当处于Prepare阶段时，调用<code>innobase_xa_prepare</code>函数会将<code>TRX_UNDO_XID_EXISTS</code>设置为TRUE，并将本次内部XA事务的<code>xid</code>（这个xid是mysql自己生成的）写入<code>XID信息</code>处。</p><ul><li>Commit阶段：先将事务执行过程中产生的<code>binlog</code>刷新到硬盘，再执行存储引擎的提交工作。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;MySQL分为server层和存储引擎层，而&lt;strong&gt;事务具体是在存储引擎层实现的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在书写包含在一个事务中的语句时，不同语句可能会涉及不同存储引擎的表，这时如果我们想保持整个事务要么全部执行，要么全部不执行的</summary>
      
    
    
    
    <category term="MySQL" scheme="https://c89757.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://c89757.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql的锁</title>
    <link href="https://c89757.github.io/2024/04/21/MySql%E7%9A%84%E9%94%81/"/>
    <id>https://c89757.github.io/2024/04/21/MySql%E7%9A%84%E9%94%81/</id>
    <published>2024-04-21T07:23:11.000Z</published>
    <updated>2025-12-18T17:04:42.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h1><blockquote><p>一致性读：事务利用<code>MVVC</code>进行读取操作称为一致性读（或者称为快照读），一致性读不会对表中任何记录加锁<br>锁定读：通过加锁的方式</p></blockquote><ul><li>共享锁（S锁）</li></ul><blockquote><p>多个事务可以同时拥有共享锁，但是会排斥独占锁</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ...... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure><p>如： 事务1拥有数据行的共享锁，此时事务2可以获取到该数据行的共享锁，但是如果事务2想要获取独占锁的话，会被阻塞，直到事务1释放共享锁后，才能获取到独占锁</p><ul><li>独占锁（X锁）</li></ul><blockquote><p>只有一个事务可以获取到独占锁，会排斥其他共享锁、独占锁</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ...... <span class="keyword">FOR</span> UPDATE</span><br></pre></td></tr></table></figure><p>如：事务1拥有数据行的独占锁后，此时事务2无论是想获取该数据行的共享锁还是独占锁都将被阻塞，直到事务1释放独占锁为止</p><h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><ul><li>表级S锁</li></ul><p>如果一个事务给表加了S（共享）锁，那么：</p><p>其他事务<strong>可以</strong>继续获得该表的<strong>S</strong>锁</p><p>其他事务<strong>可以</strong>继续获得表中数据行的<strong>S</strong>锁</p><p>其他事务<strong>不能</strong>获得继续获得该表的<strong>X</strong>锁</p><p>其他事务<strong>不能</strong>获得继续获得该表中数据行的<strong>X</strong>锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES `table_name` READ;</span><br></pre></td></tr></table></figure><ul><li>表级X锁</li></ul><p>如果一个事务给表加了X（独占）锁，那么：</p><p>其他事务<strong>不能</strong>继续获得该表的<strong>S</strong>锁</p><p>其他事务<strong>不能</strong>继续获得表中数据行的<strong>S</strong>锁</p><p>其他事务<strong>不能</strong>获得继续获得该表的<strong>X</strong>锁</p><p>其他事务<strong>不能</strong>获得继续获得该表中数据行的<strong>X</strong>锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES `table_name` WRITE;</span><br></pre></td></tr></table></figure><h1 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h1><p>在对表加表级独占锁时，如何知道表中的数据行是否已经被加了行锁呢？</p><ul><li>意向共享锁（Intention Shared Lock）：IS锁，当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁</li><li>意向独占锁（Intention Exclusive Lock）：IX锁，当事务准备在某条记录上加X锁时，需要现在表级别加一个IX锁</li></ul><blockquote><p>IS锁、IX锁是表级锁，他们的作用仅仅是为了在之后加表级别的S锁和X锁时，可以快速判断表中的记录是否被上锁</p></blockquote><h1 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h1><blockquote><p>MySQL使用元数据锁来管理对数据库对象的并发访问，并确保数据的一致性。元数据锁不仅适用于表，还适用于库、存储过程、函数、触发器等</p></blockquote><p><a href="https://dev.mysql.com/doc/refman/5.7/en/metadata-locking.html">官方文档解释</a></p><p>在对表执行<code>DDL</code>语句时，其实是通过<code>Metadata Lock（MDL）</code>来实现的。一般情况下，也不会使用<code>Innodb</code>引擎的表级锁。</p><p>比如：在对某个表执行<code>ALTER TABLE</code>等<code>DDL</code>语句时，其他事务对该表的<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>等语句时，会发生阻塞。</p><blockquote><p>不是所有的都会阻塞，某些情况下，<code>MySql</code>支持<code>online ddl</code>，提供了并发<code>DML</code>的支持，不会对其他事务的读写数据产生阻塞</p></blockquote><h1 id="AUTO-INC锁"><a href="#AUTO-INC锁" class="headerlink" title="AUTO_INC锁"></a>AUTO_INC锁</h1><p>我们可以给表的某个列加上<code>AUTO_INCREMENT</code>属性，让其自增</p><p>系统在给该列递增赋值时，有两种方式，由系统变量<code>innodb_autoinc_lock_mode</code>控制，他有三个可选值</p><ul><li>0：采用<code>AUTO_INC</code>锁，也就是在执行插入语句时，加一个表级别的<code>AUTO_INC</code>锁，然后为每条待插入记录的<code>AUTO_INCREMENT</code>列分配递增的值。在该语句执行结束之后（不是提交事务后），就会把<code>AUTO_INC</code>锁释放掉。</li><li>2：采用轻量级锁，在插入数据，生成<code>AUTO_INCREMENT</code>列的值时，获取这个轻量级锁，然后在生成本次插入语句需要的<code>AUTO_INCREMENT</code>值之后，就把这个锁释放掉，而不需要等到整个插入语句执行完成之后才释放锁</li><li>1：二者混用。当插入条数确定时，采用轻量级锁；当插入条数不确定时，采用轻量级锁采用<code>AUTO_INC</code>锁，如<code>INSERT INTO ... SELECT </code>、<code>REPLACE...SELECT</code>等语句。</li></ul><h1 id="INNODB中的行级锁"><a href="#INNODB中的行级锁" class="headerlink" title="INNODB中的行级锁"></a>INNODB中的行级锁</h1><p><code>INNDODB</code>中，有几种不同类型的行锁</p><ul><li>LOCK_REC_NOT_GAP</li></ul><p>就是最’’普通’的行锁。这种行锁有S锁和X锁的区分的</p><ul><li>LOCK_GAP</li></ul><p>间隙锁，顾名思义，会对数据行之间的间隙加锁</p><p>给一个数据行加上间隙锁之后，会锁住其前面的间隙，不允许其他事务在这个区间执行插入操作。给一条记录加gap锁，并不会影响其他事务对该条记录加行锁或者继续加gap锁</p><p>当我们给<code>Supremum</code>加上gap锁之后，表示从数据最大行 ~ +∞ 这区间，不允许插入数据</p><ul><li>LOCK_ORDINARY</li></ul><p>这种类型的锁，既可以锁住某条记录，也可以给它加gap锁，即可以阻止其他事务在该记录的前面的间隙插入新记录。</p><ul><li>LOCK_INSERT_INTENTION</li></ul><p>插入意向锁</p><p>一个事务在插入一条记录时，需要判断插入位置是否已被别的事务加了gap锁。如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交为止。在这个等待的过程中，也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在处于等待状态。</p><p>这种类型的锁命名为Insert Intention Lock。</p><ul><li>隐式锁</li></ul><p>一般情况下，执行<code>INSERT</code>语句是不需要在内存中生成锁结构的（如果当前插入的间隙已经被加了gap锁，那么本次insert操作会阻塞，并且当前事务会在该间隙上加入一个插入意向锁。）</p><p>如果当前插入的间隙没有加gap锁，那么当前事务不会为<code>INSERT</code>生成锁结构，但是如果有其他记录，想要获取这个数据，那该怎么办？</p><ul><li><p>情景1：对于聚簇索引记录来说，有一个<code>trx_id</code>隐藏列，该隐藏列记录着最后改动该记录的事务的事务id。</p><p>在当前事务中新插入一条聚簇索引记录后，该记录的<code>trx_id</code>隐藏列代表的就是当前事务的事务id。如果其他十五次是相对该记录添加S锁和X锁，首先会看一下该记录的<code>trx_id</code>隐藏列代表的事务是否是当前活跃事务。如果不是的话就可以正常读取。如果是的话，会帮当前事务创建一个X锁的锁结构，该锁结构的<code>is_waiting</code>属性为false；然后为自己也创建一个锁结构，该锁结构的<code>is_waiting</code>属性为true，之后自己进入等待状态。</p></li></ul><ul><li>情景2：对于二级聚簇索引来说，本身并没有<code>trx_id</code>隐藏列，但是在二级索引页面的<code>Page Header</code>部分有一个<code>PAGE_MAX_TRX_ID</code>属性，该属性代表对该页面做改动的最大的事务id。如果<code>PAGE_MAX_TRX_ID</code>属性值小于当前最小的活动事务id，那就说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后通过回表找到对应聚簇索引记录，然后再重复情景1的做法。</li></ul><h1 id="INNODB锁的内存结构"><a href="#INNODB锁的内存结构" class="headerlink" title="INNODB锁的内存结构"></a>INNODB锁的内存结构</h1><p>对一条记录加锁的本质就是在内存中创建一个锁结构与之关联。</p><p>如果符合以下条件，这些记录的锁就可以放到一个锁结构中：</p><ul><li>在同一个事务中进行加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样</li><li>等待状态的是一样的</li></ul><p>锁结构大致如下所示：</p><p><img src="/2024/04/21/MySql%E7%9A%84%E9%94%81/typora-user-images\MySql的锁\image-20240421234713237.png" alt="image-20240421234713237"></p><ul><li><p>锁所在的事务信息：无论是表级锁还是行级锁，一个锁属于一个事务，这里记载着该锁对应的事务信息</p><blockquote><p>锁所在的事务信息在内存结构中只有一个指针，所以不会占用多大内存空间。通过指针可以找到内存中关于该事务的更多信息</p></blockquote></li><li><p>索引信息：对于行级锁来说，需要记录以下加锁的记录属于哪个索引</p></li><li><p>表级/行锁信息：表级锁结构和行级锁结构在这个位置内容是不同的</p></li><li><p>type_mode：锁的类型</p></li></ul><h1 id="语句加锁分析"><a href="#语句加锁分析" class="headerlink" title="语句加锁分析"></a>语句加锁分析</h1><h2 id="普通的select"><a href="#普通的select" class="headerlink" title="普通的select"></a>普通的select</h2><ul><li><code>READ UNCOMMITTED</code>：不加锁，直接读取记录的最新版本；可能出现脏读、不可重复读和幻读现象</li><li><code>READ COMMITTED</code>：不加锁，在每次执行普通的select语句时，都会生成一个<code>ReadView</code>，这样避免了脏读现象，能避免脏读，但是不能避免不可重复读和幻读现象</li><li><code>REPEATABLE READ </code>：不加锁，只有在第一次执行select时，会生成<code>ReadView</code></li><li><code>SERIALIZABLE</code>：<ul><li><code>autocommit</code> = 0 时，普通的select语句会自动加上共享锁，也就是<code>select ... lock in share mode</code>。</li><li><code>autocommit</code> = 1 时，即启用自动提交，不会加锁，利用<code>MVVC</code>生成<code>ReadView</code>来读取记录。（启用自动提交后，意味着一个事务中只包含一条语句，而一条语句不会出现可重复读、幻读的现象）</li></ul></li></ul><h2 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h2><ul><li>SELECT … LOCK IN SHARE MODE</li><li>SELECT … FOR UPDATE</li><li>UPDATE …</li><li>DELETE …</li></ul><blockquote><p> <code>update</code> 和 <code>delete</code> 在执行过程中，需要首先定位到被改动的记录并给记录加锁，因此也能被认定为是一种锁定读</p></blockquote><ul><li><p>匹配模式（match mode）</p><p>在使用索引进行扫描时，查询优化器首先会生成若干个扫描区间。如果对于联合索引 [a，b]，有下面几种情况</p><ul><li>精确匹配：如果形成扫描区间匹配时只有一个值，是一个单点扫描区间。比如where a = 1，扫描区间就是[1,1]。或者where a = 1 and b = 1，也属于精确扫描</li><li>不精确匹配：如果形成的扫描区间有多个值，比如 where a = 1 and b &gt; 1，扫描区间是 [(1,1), (1, +∞)]，这种就不算是单点扫描区间，这种匹配模式就是不精确匹配</li></ul></li><li><p>唯一性搜索（unique search）</p><p>如果在扫描某个区间的记录前，就能事先确定该扫描区间内最多只包含一条记录的话，那么就把这种情况称作唯一性搜索</p><ul><li>匹配模式为精确匹配</li><li>使用的索引是主键或唯一二级索引</li><li>如果使用的索引是唯一二级索引，并且搜索条件不能为”索引列IS NULL”的形式（因为唯一二级索引来说，可以存储多个值为NULL 的记录）</li><li>如果索引中包含多个列，那么在生成扫描区间时，每一个列都得被用到、</li></ul><blockquote><p>也就是说，搜索条件能够确定结果只有唯一一条</p></blockquote></li></ul><p><strong><code>SELECT ... LOCK IN SHARE MODE</code>加锁过程</strong></p><p>隔离级别**不大于<code>READ COMMITED</code>**时，一般情况下，读取某个扫描区间中记录的过程如下：</p><ol><li><p>首先快速在B+树叶子节点中定位到该扫描区间中的第一条记录，把该记录作为当前记录</p></li><li><p>为当前记录加S型行锁</p></li><li><p>判断索引条件下推的条件是否成立</p><p>索引下推：（<code>index condition pushdown</code>,<code>ICP</code>）把一些搜索条件下推到存储引擎中判断，而不是返回到Server层再判断。<code>ICP</code>只适用于二级索引，不适用于聚簇索引。仅适用于select语句，不适用<code>update</code>、<code>delete</code></p></li><li><p>执行回表操作</p><p>如果扫描的是二级索引记录，则可能需要回表获取聚簇索引记录，并且给该聚簇索引记录加S型行锁</p></li><li><p>判断边界条件是否成立</p></li><li><p>server层判断条件是否成立</p></li></ol><blockquote><p>对于上述的查询过程来说，如果走的二级索引，会先将二级索引加行锁，并且回表后，还需要给聚簇索引记录加行锁</p></blockquote><p>在隔离级别不大于<code>READ COMMITED</code>时，在扫描区间时，先给记录加锁，如果记录不满足条件时，则释放锁，如果记录满足条件，则不会释放锁</p><p>隔离级别**不小于<code>REPETATABLE READ</code>**时，对一个select语句来说</p><p>如果扫描的是聚簇索引，则：</p><p>在对区间扫描时，加的是S型的<code>LOCK_ORDINARY</code>，也就是行锁+gap锁。</p><p>如果扫到的记录符合条件，则不会释放锁；如果扫到的记录不符合条件，也不会释放锁。</p><p>如果先扫描二级索引，再回表扫描聚簇索引，则：</p><p>在对二级索引的区间扫描时，先对<strong>二级索引记录</strong>加上<strong>S型</strong>的<code>LOCK_ORDINARY</code>，也就是<strong>行锁+gap锁</strong>，然后回表找到聚簇索引对应行，对该<strong>聚簇索引记录</strong>加一个<strong>S型行锁</strong>。</p><p>存储引擎将查询到的聚簇索引记录返回给Server层，Server层判断记录是否符合条件，如果<strong>符合</strong>，则<strong>不会</strong>释放加在该记录上的锁</p><p>如果Server层判断记录<strong>不符合</strong>条件，则丢弃这条结果数据，并且也<strong>不会</strong>释放加在该记录上的锁</p><blockquote><p>SELECT … FOR UPDATE语句加锁过程与上述的SELECT … LOCK IN SHARE MODE语句类似，只不过加的都是X锁 </p></blockquote><p>如果匹配模式是精确模式</p><ul><li>隔离级别不大于<code>READ_COMMITTED</code>时，不会为扫描区间后面的下一条记录加锁</li><li>隔离级别不小于<code>REPEATABLE_READ</code>时，则会为扫描区间后面的下一条记录加gap锁</li></ul><ul><li>当隔离级别不小于<code>REPEATABLE READ</code>时，如果匹配模式不是精确匹配，并且没有找到精确匹配的记录，则会为该扫描区间后面的下一条记录加<code>LOCK_ORDINARY</code>（行锁+gap锁）</li><li>无论是哪个隔离级别，只要是唯一型搜索，并且读到的记录没有标记为’已删除’（记录头信息中的<code>delete_flag</code> = 1），就为读取到的记录加行锁</li></ul><h1 id="查看事务加锁情况"><a href="#查看事务加锁情况" class="headerlink" title="查看事务加锁情况"></a>查看事务加锁情况</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.INNODB_TRX;</span><br></pre></td></tr></table></figure><ul><li><code>trx_tables_locked</code>：表级锁</li><li><code>trx_rwos_locked</code>：加了多少个行级锁（不包含隐式锁）</li><li><code>trx_lock_structs</code>：表示该事务生成了多少个内存中的锁结构</li></ul><blockquote><p>系统中发生了某个事务因为想要获取锁而被阻塞的情况时，会在这个表中记录</p><p>tips：已过时，在<code>MySql8.0</code>中已经被移除</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.INNODB_LOCKS;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINE INNODB STATUS;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;行级锁&quot;&gt;&lt;a href=&quot;#行级锁&quot; class=&quot;headerlink&quot; title=&quot;行级锁&quot;&gt;&lt;/a&gt;行级锁&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;一致性读：事务利用&lt;code&gt;MVVC&lt;/code&gt;进行读取操作称为一致性读（或者称为快照读），一致性读不</summary>
      
    
    
    
    <category term="MySQL" scheme="https://c89757.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://c89757.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql增加varchar长度</title>
    <link href="https://c89757.github.io/2024/04/17/MySql%E5%A2%9E%E5%8A%A0varchar%E9%95%BF%E5%BA%A6/"/>
    <id>https://c89757.github.io/2024/04/17/MySql%E5%A2%9E%E5%8A%A0varchar%E9%95%BF%E5%BA%A6/</id>
    <published>2024-04-17T11:29:10.000Z</published>
    <updated>2025-12-18T17:06:26.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近需要增加某个<code>varchar</code>字段的长度，由<code>varchar(50)</code>扩展为<code>varchar(100)</code>，但是表中数据很大，担心锁表，想到了<code>MySql</code>的<code>online-DDL</code>，于是测试了一下，发现了一些有趣的事情，记录一下。</p><br><h1 id="varchar"><a href="#varchar" class="headerlink" title="varchar"></a>varchar</h1><blockquote><p> 先从<code>varchar</code>字段的存储方式说起，人们通常拿<code>char</code>和<code>varchar</code>对比，此处也一起探讨下。</p><p><a href="#https://dev.mysql.com/doc/refman/5.7/en/char.html">官网文档对二者的说明</a></p></blockquote><p>​    <code>char</code>类型的字段长度固定，在建表时的申明就已经确定，长度范围在0 ~ 255，数据的真实长度不足时，会用空格填充。如果数据本身就带有空格，在检索时，会删除尾随的空格，除非开启<code>sql_mode</code>：<code>PAD_CHAR_TO_FULL_LENGTH S</code></p><p>​    <code>varchar</code>是可变长字段，长度范围在0 ~ 65535。在数据行中的格式中，一般还会有个可变长字段长度列表，来记录变长字段存储的真实长度。</p><p>（针对某些行格式来说，如compact，如果采用的是不定长的编码字符集的话，比如<code>gbk</code>表示一个字符要1~2字节，<code>mysql</code>的<code>utf8</code>表示一个字符要1~3字符，此时char类型的字段的长度 也会被加到可变长字段长度列表中）</p><br><h1 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h1><ul><li>compact</li></ul><p>如果表采用的是compact行格式，那每个数据行的格式如下</p><img src="/2024/04/17/MySql%E5%A2%9E%E5%8A%A0varchar%E9%95%BF%E5%BA%A6/image-20240417202411995.png" class><br><p>其中我们重点关注一下 <strong>变长字段长度列表</strong> 这个结构，需要注意的是，这个结构并不是在所有数据行都有，它只存储值不为空的列的长度。</p><blockquote><p>也就是说，如果一行数据中，没有变长字段，或者所有的变长字段都为空，就不需要有这个结构</p></blockquote><p>针对某一行的某一个<code>varchar</code>字段来说，如果他不为空的话，则<strong>在变长字段长度列表中</strong>，需要1~2个字节来存储其数据的长度，具体是一个字节还是两个字节，规则如下：</p><ul><li>如果变长字段允许的最大长度不超过255，则使用一个字节存储</li><li>如果变长字段允许的最大长度超过了255，并且实际的长度超过了127字节时，需要两个字节去存储其长度</li><li>列为溢出列（下面解释何为溢出列）</li></ul><blockquote><p>比如针对 <code>utf8mb4</code>编码的行来说，<code>varchar(30)</code>，最多可以存储的字节为：4 * 30 = 120字节，此时在变长字段长度列表中，只需要一个字节存储其长度即可。</p></blockquote><p><code>MySql</code>对数据行的大小都有一定限制，如果变长字段存储的值很长，超过一定长度怎么办？</p><p>针对这种很长、占用字节数很多的列，在记录真实数据处只会存储改列的一部分数据，而把剩余的数据存放在外部页中，然后用20字节指针指向外部页。这种列称为<code>溢出列</code></p><p>针对<code>compcat</code>行格式来说，如果一列数据特别多，则只会存储前<code>768</code>字节的数据，然后将剩余数据记录在其他页中，数据格式如下：</p><br><img src="/2024/04/17/MySql%E5%A2%9E%E5%8A%A0varchar%E9%95%BF%E5%BA%A6/image-20240417211255191.png" class><br><p>需要注意的是，此时变长列表中记录的长度，是内部存储部分的长度 + 20字节指针。这里就是 768 + 20</p><br><blockquote><p>所以不论数据多长，占用多少字节，都只需要两个字节存储其长度</p></blockquote><br><ul><li>dynamic</li></ul><p><code>dynamic</code>行格式是<code>compcat</code>的变种，具有相同的存储特性。</p><p>在处理溢出页上，<code>dynamic</code>不会在记录的真实数据处存储该溢出列真实数据的前768字节，而是把所有真实数据都存储到溢出页中，只在记录的真实数据处存储20字节大小的指针。</p><br><img src="/2024/04/17/MySql%E5%A2%9E%E5%8A%A0varchar%E9%95%BF%E5%BA%A6/image-20240417215418849.png" class><br><h1 id="online-ddl"><a href="#online-ddl" class="headerlink" title="online-ddl"></a>online-ddl</h1><blockquote><p><code>MySql</code> 在线<code>DDL</code>功能，提供了一些特性，如：</p><p>更少的磁盘空间和I/O开销，尽可能少地加锁</p></blockquote><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-operations.html#online-ddl-column-operations">官网地址</a></p><ul><li>Extending <code>VARCHAR</code> column size</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">*</span>tbl_name<span class="operator">*</span> CHANGE <span class="keyword">COLUMN</span> c1 c1 <span class="type">VARCHAR</span>(<span class="number">255</span>), ALGORITHM<span class="operator">=</span>INPLACE, LOCK<span class="operator">=</span><span class="keyword">NONE</span>;</span><br></pre></td></tr></table></figure><br><p>值的注意的是：就地<code>ALTER TABLE</code>只支持将<code>VARCHAR</code>列的大小从0增加到255字节，或者从256字节增加到更大的大小。</p><p>原因就是上面所说的行格式。255字节时，只需要更改字段限制就好了。</p><p>如果我们把<code>VARCHAR(50)</code>更改<code>VARCHAR(63)</code>，假设行编码为<code>utf8mb4</code>，原长度为 50 * 4 &lt; 255，所以变长字段列表中只需要一个字节记录。修改后允许的最大长度为63字符，即最大字节为 63 * 4 = 252 &lt; 255。也只需要一个字节去记录长度，所以此时扩展其大小速度很快。</p><p>如果我们将大小修改为<code>VARCHAR(100)</code>，修改后允许的最大长度为100，即最大字节为 100 * 4 = 400 &gt; 255，此处是就需要两个字节去记录长度，所以此时扩展其大小速度比较慢，因为还需要调整每行的长度。</p><br><p>执行<code>DDL</code>语句时，可以通过以下语句查看锁情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    r.trx_id waiting_trx_id,</span><br><span class="line">    r.trx_mysql_thread_id waiting_thread,</span><br><span class="line">    r.trx_query waiting_query,</span><br><span class="line">    b.trx_id blocking_trx_id,</span><br><span class="line">    b.trx_mysql_thread_id blocking_thread,</span><br><span class="line">    b.trx_query blocking_query</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    information_schema.innodb_lock_waits w</span><br><span class="line">        <span class="keyword">INNER</span> <span class="keyword">JOIN</span> information_schema.innodb_trx b <span class="keyword">ON</span></span><br><span class="line">            b.trx_id <span class="operator">=</span> w.blocking_trx_id</span><br><span class="line">        <span class="keyword">INNER</span> <span class="keyword">JOIN</span> information_schema.innodb_trx r <span class="keyword">ON</span></span><br><span class="line">            r.trx_id <span class="operator">=</span> w.requesting_trx_id;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近需要增加某个&lt;code&gt;varchar&lt;/code&gt;字段的长度，由&lt;code&gt;varchar(50)&lt;/code&gt;扩展为&lt;code&gt;va</summary>
      
    
    
    
    <category term="MySQL" scheme="https://c89757.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://c89757.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql的日志</title>
    <link href="https://c89757.github.io/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/"/>
    <id>https://c89757.github.io/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/</id>
    <published>2024-04-14T10:06:02.000Z</published>
    <updated>2025-12-18T17:04:35.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><blockquote><p>二进制日志，记录了数据库发生的变化。如新建了一个数据库或者表、表结构发生改变、表中的数据发生了变化时都会记录相应的<code>binlog</code>日志。</p></blockquote><p>主要作用</p><ul><li>用于复制</li></ul><p><code>MySql</code>主从复制就依赖<code>binlog</code>，主服务器将数据<strong>同步</strong>给各个从服务器</p><ul><li>用于恢复</li></ul><p>数据误删后可以通过<code>binlog</code>恢复</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>可以通过如下命令查看是否当前服务器是否开启了<code>binlog</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_bin&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>binlog</code>日志并不是仅写到一个文件中，而是写入一组文件中，这组文件的命名如下：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">basename.<span class="number">000001</span></span><br><span class="line">basename.<span class="number">000002</span></span><br><span class="line">basename.<span class="number">000003</span></span><br><span class="line">basename.<span class="number">000004</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>启动选项<code>log-bin[=base_name]</code>中的<code>base_name</code>就是这组<code>binlog</code>日志文件名称都包含的部分。</p><p>如果不配置<code>basename</code>，<code>MySQL</code>服务器会默认将<code>主机名-bin</code>作为<code>binlog</code>日志文件的<code>basename</code>。</p><p>除了这些真正存储的<code>binlog</code>日志文件以外，<code>MySql</code>服务器还会在相同的路径下生成一个关于<code>binlog</code>的索引文件。</p><p>文件名为<code>.index</code>结尾，同时他是他是一个文本文件，里面存储的是各个<code>binlog</code>文件的路径</p><h2 id="查看binlog"><a href="#查看binlog" class="headerlink" title="查看binlog"></a>查看binlog</h2><p><code>binlog</code>中记录数据库发生更改的各种事件（events），这些事件的种类非常多，我们熟悉的有：</p><ul><li>WRITE_ROWS_EVENT：插入记录。</li><li>UPDATE_ROWS_EVENT：更新记录。</li><li>DELETE_ROWS_EVENT：删除记录。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> BINLOG EVENTS</span><br><span class="line">   [<span class="keyword">IN</span> <span class="string">&#x27;log_name&#x27;</span>]</span><br><span class="line">   [<span class="keyword">FROM</span> pos]</span><br><span class="line">   [LIMIT [<span class="keyword">offset</span>,] row_count]</span><br></pre></td></tr></table></figure><ul><li><p><code>[IN &#39;log_name&#39;]</code>：<code>log_name</code>表示我们要查看哪个<code>binlog</code>日志文件的内容。</p></li><li><p><code>[FROM pos]</code>：<code>pos</code>表示我们要查看<code>binlog</code>文件的起始偏移量（通过指定这个值可以直接去查看某个偏移量处的事件）。</p></li><li><p><code>offset</code>表示我们要从哪个事件开始查看，<code>row_count</code>表示我们要查看多少个事件。</p></li></ul><p><strong>mysqlbinlog</strong></p><blockquote><p>由于<code>binlog</code>是二进制格式的，我们不能直接以文本的形式查看。使用<code>SHOW BINLOG EVENTS</code>又只能看到粗略的信息，如果我们想查看<code>binlog</code>日志文件的详细信息的话，就需要使用<code>MySQL</code>给我们提供的实用工具——<code>mysqlbinlog</code>。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog ./basename.000001</span><br></pre></td></tr></table></figure><h1 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h1><blockquote><p>事务已经提交，但是还没有刷到磁盘，但是如果此时服务宕机，可能会造成数据丢失。</p><p>比如：数据刚提交，或者只更改了buffer pool中的数据，但是还没有刷新到磁盘，服务宕机，内存中的数据就没了。</p><p><code>redolog</code>记录的就是，对数据的更改操作。如把某个页的地址偏移量为1000的数据更改为2。这样即使服务宕机，重启后，只需要按照<code>redolog</code>记录的步骤重新更新数据页即可。</p><p>为了让已经提交的事务对数据的更改能永久生效，即使服务器崩溃，也能通过<code>redolog</code>恢复</p><p><code>redolog</code>是顺序写入磁盘的。</p></blockquote><h2 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h2><p><code>redolog</code>本质上只是记录了一下事务对数据库进行了哪些修改。</p><p><code>MySql</code>针对不同的修改场景，定义了多种类型的redo日志，但大部分类型的redo日志都有以下这种通用格式</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240414192757001.png" alt="image-20240414192757001"></p><ul><li>type：这条redo日志的类型</li><li>space ID：表空间ID</li><li>page number：页号</li><li>data：这条redo日志的具体内容</li></ul><h2 id="简单的日志类型"><a href="#简单的日志类型" class="headerlink" title="简单的日志类型"></a>简单的日志类型</h2><p>有些极其简单的修改，只需要记录一些某个页面的某个偏移量处修改了几个字节、修改后的内容，这种极其简单的<code>redolog</code>称为物理日志，并且根据在页面中写入数据的多少划分为几种不同类型的<code>redo</code>日志类型.</p><ul><li><code>MLOG_1BYTE</code>（type字段对应的十进制数字为1）：表示在某个页面偏移量处写了1字节的redo日志类型</li><li><code>MLOG_2BYTE</code>（type字段对应的十进制数字为2）：表示在某个页面偏移量处写了2字节的redo日志类型</li><li><code>MLOG_4BYTE</code>（type字段对应的十进制数字为4）：表示在某个页面偏移量处写了4字节的redo日志类型</li><li><code>MLOG_8BYTE</code>（type字段对应的十进制数字为8）：表示在某个页面偏移量处写了8字节的redo日志类型</li><li><code>MLOG_WRITE_STRING</code>（type字段对应的十进制数字为30）：表示在某个页面偏移量处写入1个 <code>字节序列</code> 的redo日志类型</li></ul><p>对于<code>MLOG_ n BYTE</code>格式的日志，他们的通用日志格式如下：</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240415224554545.png" alt="image-20240415224554545"></p><p>对于``MLOG_WRITE_STRING`类型的日志来说，格式都差不多，只不过具体数据中包含的字节数量不同。格式如下：</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240415225620019.png" alt="image-20240415225620019"></p><p><code>MLOG_WRITE_STRING</code>类型的<code>redolog</code>因为不确定写入的具体数据占用多少字节，所以需要在日志结构中添加一个<code>len</code>字段。</p><h2 id="复杂的日志类型"><a href="#复杂的日志类型" class="headerlink" title="复杂的日志类型"></a>复杂的日志类型</h2><p>对于一个<code>INSERT</code>语句来说，他对B+树的影响如下</p><ol><li>表中有几个索引，一条<code>INSERT</code>语句就有可能更新多少棵<code>B+</code>树</li><li>针对一棵<code>B+</code>树来说，有可能只更新叶子节点，也有可能需要更新内节点页面，还可能新增内节点页面（比如新增后的页面不够了，需要页分类，此时就需要在内节点新增目录记录）</li></ol><p>其实需要更新的东西很多，比如Page Director中的槽信息，Page Header中的各种统计信息，数据会按照索引列的大小排成一个单向链表，所以还需要更新上一条记录的记录头中的指针，也就是<code>next record</code>属性</p><p>针对这种比较复杂的更改，需要记录的东西太多，我们又不能把整个页面记录下来，太浪费了，于是就有了新的<code>redolog</code>日志类型</p><ul><li><p><code>MLOG_REC_INSERT</code>（type字段对应的十进制数字为9）：表示在插入一条使用非紧凑行格式（redundant）的记录时，redo日志的类型</p></li><li><p><code>MLOG_COMP_REC_INSERT</code>（type字段对应的十进制数字为38）：表示在插入一条使用紧凑行格式（compact、dynamic、compressed）的记录时，redo日志的类型</p></li><li><p><code>MLOG_COMP_PAGE_CREATE</code>（type字段对应的十进制数字为58）：表示在创建一个存储紧凑行格式记录的页面时，redo日志的类型</p></li><li><p>……</p></li></ul><p><code>MLOG_COMP_REC_INSERT</code>类型的<code>redolog</code>格式如下：</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240415233226592.png" alt="image-20240415233226592"></p><h2 id="Mini-Transication"><a href="#Mini-Transication" class="headerlink" title="Mini-Transication"></a>Mini-Transication</h2><ul><li>以组的形式写入<code>redolog</code></li></ul><p>比如<code>INSERT</code>语句，再插入时，可能会产生很多条<code>redolog</code>；例如：再插入时，叶子节点空间不足，就需要页分裂，同时向父节点加一个目录项，如果此时父节点的页面空间也不足，就需要再次分裂。如果我们再插入的过程中，只记录了一部分的<code>redolog</code>，此时系统崩溃，待系统重启恢复后，按照<code>redolog</code>的记录去恢复，就会形成一条不正确的 <code>B+</code> 树。</p><p>所以<code>MySql</code>为了保证这个操作的原子性，记录<code>redolog</code>时，都是以组的形式来记录。在进行恢复时，对于一个组内的<code>redolog</code>，要么全部恢复，要么一条都不会恢复。</p><blockquote><p> 如何区分日志属于哪一组呢？</p><p><code>MySql</code>会在每个组的日志结尾处，插入一条特殊类型的<code>redolog</code>，叫做<code>MLOG_MUTIL_REC_END</code>，以这个日志结尾的就属于一组<code>redolog</code></p></blockquote><h2 id="redo-log-block"><a href="#redo-log-block" class="headerlink" title="redo log block"></a>redo log block</h2><p>一个<code>MTR</code>（<code>Mini-Transication</code>）生成的<code>redo</code>日志都放在了大小为512字节的页中，称为<code>block</code>。</p><p><code>redo block</code>的格式示意图：</p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240417000328320.png" alt="image-20240417000328320" style="zoom:80%;"><ul><li><code>LOG_BLOCK_HDR_NO</code>：每一个<code>block</code>都有一个大于0的唯一编号，该属性就表示该编号值</li><li><code>LOG_BLOCK_HDR_DATA_LEN</code>：表示<code>block</code>中已经使用了多少字节；初始值12（因为<code>log block body</code>从第12个字节处开始）。随着往<code>block</code>中写入的<code>redo</code>日志越来越多，该属性也跟着增长。</li><li><code>LOG_BLOCK_FIRST_REC_GROUP</code>：一个<code>redo</code>日志也可以称为一条<code>redo</code>日志记录（<code>redo log record</code>）。一个<code>MTR</code>会生成多条<code>redo</code>日志记录，这个<code>MTR</code>生成的这些<code>redo</code>日志记录被称为一个<code>redo</code>日志记录组（<code>redo log record group</code>）。<code>LOG_BLOCK_FIRST_REC_GROUP</code>就代表该<code>block</code>中第一个<code>MTR</code>生成的<code>redo</code>日志记录组的偏移量，其实也就是这个<code>block</code>中第一个<code>MTR</code>生成的第一条<code>redo</code>日志记录的偏移量。</li><li><code>LOG_BLOCK_CHECKPOINT_NO</code>：表示<code>checkpoint</code>的序列</li><li><code>LOG_BLOCK_CHECKSUM</code>：表示该<code>block</code>的校验值，用于正确性校验。</li></ul><h2 id="log-buffer"><a href="#log-buffer" class="headerlink" title="log buffer"></a>log buffer</h2><p>​    写入<code>redo</code>日志时，其实也是写在<code>redo log buffer</code>日志缓冲区的。</p><p>​    <code>MySql</code>服务器在启动时就向操作系统申请了一大片连续的内存空间，称为<code>redo log buffer</code>日志缓冲区。这片连续的内存空间被划分若干连续的<code>redo log block</code>。</p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240417232524707.png" alt="image-20240417232524707"><p>​    向<code>log buffer</code>中写入undo日志的过程中是顺序写入的，也就是先往前面的<code>block</code>中写，当该<code>block</code>的空闲空间用完之后再往下一个<code>block</code>中写。<code>MySql</code>维护了一个全局变量<code>buf_free</code>，记录偏移量，指明后续写入的<code>redo</code>日志应该写到<code>log buffer</code>中的哪个位置。</p><p>​    一个<code>MTR</code>执行过程中可能产生若干条<code>redo</code>日志，这些<code>redo</code>是一个不可分割的组，所以并不是每生成一条<code>redo</code>日志就该将其插入到<code>log buffer</code>中，而是将每个<code>MTR</code>运行过程中产生的日志暂存到一个地方；当该<code>MTR</code>结束时，再将过程中产生的一组<code>redo</code>日志全部复制到<code>log buffer</code>中。</p><h2 id="redo日志刷盘时机"><a href="#redo日志刷盘时机" class="headerlink" title="redo日志刷盘时机"></a>redo日志刷盘时机</h2><ul><li>log buffer 空间不足时</li></ul><p><code>log buffer</code>的大小是有限的，通过系统变量<code>innodb_log_buffer指定</code>，当写入<code>log buffer</code>的<code>redo</code>日志超过<code>log buffer</code>总容量的50%时，就需要把这些日志刷新到磁盘中</p><ul><li>事务提交时</li></ul><p>为了持久性，也为了保证系统崩溃后，能够恢复事务对页面的更改</p><ul><li>当某个脏页刷新到磁盘前，会保证先将该脏页对应的redo日志刷新磁盘中</li></ul><p>因为redo日志是顺序写入的，所以将某个脏页对应的redo日志从<code>redo log buffer</code>刷新到磁盘时，也会保证在其之前产生的redo日志也刷新到磁盘</p><ul><li>后台线程，定时刷新</li></ul><p>大约以每秒1次的频率将<code>log buffer</code>中的<code>redo</code>日志刷新到磁盘</p><ul><li>正常关闭服务器时</li></ul><h2 id="redo日志文件组"><a href="#redo日志文件组" class="headerlink" title="redo日志文件组"></a>redo日志文件组</h2><p>使用命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;datadir&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以查看redo日志的保存文件位置。</p><p>默认在数据目录下的<code>ib_logfile()</code>和<code>ib_logfile1()</code>两个文件中</p><p>下面是关于<code>redo log</code>的一些参数</p><ul><li><code>innodb_log_group_home_dir</code>：指定了<code>redo</code>日志文件所在的目录，默认就是当前的数据目录</li><li><code>innodb_log_file_size</code>：指定了每个<code>redo</code>日志文件的大小，在<code>MySql5.7</code>版本中的默认值就是48MB</li><li><code>innodb_log_files_in_group</code>：指定了redo日志文件的个数，默认值为2，最大值100</li></ul><p>redo日志是循环写入日志文件的，也就是先写入第一个文件，第一个文件满了，再写入第二个文件，以此类推，当最后一个文件写满了时，再写入第一个文件。</p><p>所以可能会有覆盖的风险。（如何解决：<a href="#checkpoint">checkpoint</a>)</p><h2 id="checkpointredo日志文件格式"><a href="#checkpointredo日志文件格式" class="headerlink" title="checkpointredo日志文件格式"></a>checkpointredo日志文件格式</h2><p><code>log buffer</code>本质上一片连续的内存空间，被划分为若干个<code>512</code>字节大小的<code>block</code>。将<code>log buffer</code>中的<code>redo</code>日志刷新到磁盘的本值就是把<code>block</code>镜像写入日志文件中，所以<code>redo</code>日志文件其实也是由若干个<code>512</code>字节大小的<code>block</code>组成。</p><p>在<code>redo</code><strong>日志文件组</strong>中，每个文件格式大小都一样，都是由下面两部分组成：</p><ul><li>前2048个字节（前4个block）用来存储一些管理信息</li><li>从第2048字节往后的字节用来存储<code>log buffer</code>中<code>block</code>镜像</li></ul><p>前4个<code>block</code>的结构如下：</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240418222559688.png" alt="image-20240418222559688"></p><p><strong>log file header</strong></p><ul><li><code>LOG_HEADER_FORMAT</code>：4字节，redo日志的版本，在<code>MySql5.7</code>中基本都为1</li><li><code>LOG_HEADER_PAD1</code>：4字节，用于字节填充，无实在意义</li><li><code>LOG_HEDAER_START_LSN</code>：8字节，标记本<code>redo</code>日志文件偏移量为2048字节处对应的<code>lsn</code>值</li><li><code>LOG_HEADER_CRETOR</code>：32字节 ，一个字节串，标记本<code>redo</code>日志文件的创建者是谁，正常运行时该值为<code>MySql</code>的版本号；在使用<code>mysqlbackup</code>命令创建<code>redo</code>日志文件时，该值为<code>ibbackup</code>和创建时间</li><li><code>LOG_BLOCK_CHECKSUM</code>：4字节，本<code>block</code>的校验值；所有的<code>block</code>都有该值，</li></ul><p><strong>checkpoint1</strong></p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240418223900310.png" alt="image-20240418223900310"><ul><li><code>LOG_CHECKPOINT_NO</code>：8字节，服务器执行checkpoint编号，每执行一次<code>checkpoint</code>，该值就加1</li><li><code>LOG_CHECKPOINT_LSN</code>：8字节，服务器在结束<code>checkpoint</code>时对应的<code>lsn</code>值；系统崩溃后恢复将从该值开始</li><li><code>LOG_CHECKPOINT_OFFSET</code>：8字节，上个属性中的<code>lsn</code>值在<code>redo</code>日志文件组中的偏移量</li><li><code>LOG_CHECKPOINT_LOG_BUF_SIZE</code>：8字节，服务器在执行<code>checkpoint</code>操作时对应的<code>log buffer</code>的大小</li><li><code>LOG_BLOCK_CHECKSUM</code>：4字节，本<code>block</code>的校验值；所有<code>block</code>都有该值</li></ul><p><code>checkpoint2</code>结构与<code>checkpoint1</code>一样</p><h2 id="log-sequence-number"><a href="#log-sequence-number" class="headerlink" title="log sequence number"></a>log sequence number</h2><p><code>INNODB</code>设计了一个为<code>lsn(log sequence number)</code>的全局变量，用来记录当前总共已经写入的<code>redo</code>日志量。</p><p><code>lsn</code>的值为<code>8704</code>，也就是一条<code>redo</code>日志也没写入时，<code>lsn</code>的值就是<code>8704</code></p><p>向<code>log buffer</code>中不断写入日志，其实是以<code>MTR</code>生成的一组<code>redo</code>日志为单位写入的，而且实际上是把日志写在了<code>log buffe body</code>处。但是在统计<code>lsn</code>的增长值时，是按照实际写入的日志量加上占用的<code>log buffer header</code>和<code>log buffer trailer</code>来计算的。</p><p>如下图：<code>buf_free</code>用来标记下一条redo日志应该写到<code>log buffer</code>中的哪个位置。</p><p><code>MTR1</code>写完以后，对于<code>MTR2</code>，一个页面装不下，跨页了，此时，<code>lsn</code>的偏移量应该加上第一个<code>block</code>的 <code>log block trailer</code>和第二个<code>block</code>的<code>log block header</code>。</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240418233324254.png" alt="image-20240418233324254"></p><blockquote><p>每一组由<code>MTR</code>生成的redo日志都有一个唯一的<code>lsn</code>值与其对应；<code>lsn</code>值越小，说明<code>redo</code>日志产生得越早。</p></blockquote><h2 id="flushed-to-disk-lsn"><a href="#flushed-to-disk-lsn" class="headerlink" title="flushed_to_disk_lsn"></a>flushed_to_disk_lsn</h2><p>全局变量<code>flushed_to_disk_lsn</code>，用来表示刷新到磁盘的redo日志的总量</p><blockquote><p><code>lsn</code>是用来记录redo日志在<code>log buffer</code>中的日志量</p></blockquote><p>在系统第一次启动时，<code>flushed_to_disk_lsn</code>的值与<code>lsn</code>的值是相同的，都是8704。</p><p>随着系统的运行，<code>flushed_to_disk_lsn</code>的值，会逐渐被<code>lsn</code>甩开。因为先写log buffer，再刷新磁盘，毕竟磁盘的刷新没那么快，也没那么及时</p><p>他们的关系如下图：</p><p><code>buf_next_to_write</code>表示下一段将要刷新到磁盘的偏移量</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240419000257852.png" alt="image-20240419000257852"></p><blockquote><p>个人理解：<code>flushed_to_disk_lsn</code>是全局累加的，记录系统总共刷新了多少日志量。</p><p>但是<code>buf_next_to_write</code>是一个指针，用于记录当前刷新到了哪里，随着log buffer清空，这个值也会被复位，指向log buffer开头</p></blockquote><p>如果<code>lsn</code>的值和<code>flushed_to_disk_lsn</code>的值相同，则表示所有的redo日志都刷新到了磁盘。</p><h2 id="flush链表中的lsn"><a href="#flush链表中的lsn" class="headerlink" title="flush链表中的lsn"></a>flush链表中的lsn</h2><blockquote><p>当第一次修改buffer pool中的某页面时，会把该页面对应的控制块加入到flush链表的头部。（之后再次修改时，由于已经存在flush链表中，所以不再插入了）。也就是说，flush链表中的脏页按照页面的第一次修改时间进行排序的，。</p></blockquote><p>在flush链表的控制块中，记录着两个关于页面何时修改的属性。</p><ul><li>oldest_modification：第一次修改<code>buffer pool</code>中某个缓冲页时，就将修改该页面的<code>MTR</code>开始时的<code>lsn</code>值写入这个属性</li><li>newest_modification：每修改一次页面，都会将 修改该页面的<code>MTR</code>结束时对应的<code>lsn</code>值写入这个属性。也就是说，该属性表示页面最近一次需修改后对应的<code>lsn</code>值</li></ul><h2 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h2><p>redo日志文件是有限的，循环写入时，可能新的内容会覆盖旧的内容</p><blockquote><p>redo日志只是为了在系统崩溃后恢复脏页用的，如果对应的脏页已经被刷盘了，那么即使现在系统崩溃后，重启后也没必要使用redo日志恢复该页面了。也就是说该段redo日志就没用的了。</p></blockquote><p>所以判断某个redo日志占用的磁盘空间是否可以被覆盖，就是看对应脏页是否已经被刷新到磁盘</p><p><code>MySql</code>维护一个全部变量<code>checkpoint_lsn</code>，用来表示当前系统中可以被覆盖的redo日志总量是多少。当某个<code>MTR</code>生成的redo日志，被刷新到磁盘中，那么就可以执行一个增加<code>checkpoint_lsn</code>操作，这个操作称为执行一个<code>checkpoint</code></p><p>执行一个<code>checkpoint</code>可以分为两个步骤</p><ol><li>计算当前系统中可以被覆盖的redo日志对应的<code>lsn</code>值最大是多少</li><li>将<code>checkpoint_lsn</code>与对应的<code>redo</code>日志文件组偏移量以及此次<code>checkpoint</code>的编号写到日志文件的管理信息（<code>checkpoint1</code>或者<code>checkpoint2</code>）中</li></ol><p><code>MySql</code>维护了一个<code>checkpoint_no</code>变量，用来统计目前系统执行了多少次<code>checkpoint</code>；每执行一次<code>checkpoint</code>，该变量的值就加1。</p><p>当<code>checkpoint_no</code>的值是偶数时，就写到<code>checkpoint1</code>中，是奇数时，就写到<code>checkpoint2</code>中</p><h2 id="查看系统中的各种lsn值"><a href="#查看系统中的各种lsn值" class="headerlink" title="查看系统中的各种lsn值"></a>查看系统中的各种lsn值</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> innodb engine status;</span><br></pre></td></tr></table></figure><blockquote><p>-–<br>LOG<br>-–<br>Log sequence number 78434369<br>Log flushed up to   78434369<br>Pages flushed up to 78434369<br>Last checkpoint at  78434360<br>0 pending log flushes, 0 pending chkp writes<br>98 log i/o’s done, 0.00 log i/o’s/second<br>-——————— </p></blockquote><ul><li>Log sequence number：表示系统中的<code>lsn</code>值，也就是当前系统已经写入的redo日志量，包括写入到log buffer中的redo日志</li><li>Log flushed up to：表示<code>flused_to_disk_lsn</code>值，也就是当前系统已经写入磁盘的redo日志量</li><li>Pages flushed up to：表示flush链表中最早被修改的那个页面对应的<code>old_nodification</code>属性值</li><li>Last checkpoint at：表示当前系统的<code>checkpoint_lsn</code>值</li></ul><h2 id="innodb-flush-log-at-trx-commit"><a href="#innodb-flush-log-at-trx-commit" class="headerlink" title="innodb_flush_log_at_trx_commit"></a>innodb_flush_log_at_trx_commit</h2><p>该系统变量<code>innodb_flush_log_at_trx_commit</code>的系统变量的值</p><ul><li>0：表示在事务提交时，不立即向磁盘同步redo日志，这个任务交给后台线程来处理。</li><li>1：表示在事务提交时需要将redo日志同步到磁盘。默认值就是1</li><li>2：当该系统变量的值为2时，表示在事务提交时，需要将redo日志写到操作系统的缓冲区中，但并不需要保证将日志真正地刷新磁盘。</li></ul><h1 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h1><blockquote><p>用于事务回滚后的数据恢复</p></blockquote><p>比如：</p><p>对于insert语句，我们把这条记录的主键值记下来，回滚时只需要把这条记录删掉即可</p><p>对于delete语句，我们把这条记录的内容都记下来，回滚时再把这些内容组成的记录插入到表里就好了</p><p>对于update语句，需要把更新前的旧值记下来，回滚时把这些列更新为旧值即可</p><p>select语句并不会修改任何记录，所以也不会产生<code>undolog</code></p><h2 id="事务id"><a href="#事务id" class="headerlink" title="事务id"></a>事务id</h2><ul><li><p>只读事务：<code>START TRANSCATION READ ONLY</code>开启只读事务，在只读事务中，不允许对普通的表进行增删改操作，但是可以对用户临时表进行增删改操作。（这里说的用户临时表是指 <code>create temporary table</code>创建的表，不是语句执行过程中的那个<code>using temporary</code>，那个是系统临时表）</p></li><li><p>读写事务：<code>START TRANSCATION READ WRITE</code>开启读写事务，<code>BEGIN</code>和<code>START TRANSCATION</code>语句开启的也是读写事务。在读写事务中可以对表进行增删改操作。</p></li></ul><p>如果某个事务，在执行过程中，对某个表执行了写操作，也就是增删改，那么<code>InnoDB</code>存储引擎就会给它分配一个第一无二的事务id。</p><ul><li>对于只读事务来说，只有第一次对用户临时表进行增删改时，才会对其分配一个事务id。如果没有更改，则不会分配</li><li>对于读写事务来说，只有它第一次对某个表执行增删改操作时，才会为这个事务分配一个事务id，否则不分配事务id</li></ul><h2 id="日志格式-1"><a href="#日志格式-1" class="headerlink" title="日志格式"></a>日志格式</h2><h2 id="insert操作对应的undo日志"><a href="#insert操作对应的undo日志" class="headerlink" title="insert操作对应的undo日志"></a>insert操作对应的undo日志</h2><blockquote><p>insert语句导致的结果就是插入了一条记录，回滚操作就是把这条记录删除就好了。所以我们只要把这条记录的主键信息记录上就好了</p></blockquote><p><code>MySql</code>类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo</code>日志，其完整结构如下</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420135406839.png" alt="image-20240420135406839"></p><ul><li><code>undo no</code>：在一个事务是从0开始递增的。事务没提交时，每生成一条undo日志，那么该条日志的undo no就加1</li><li><code>table id</code>：每个表都会分配一个唯一的<code>table id</code>，可以通过<code>infomation_schema</code>的<code>innodb_sys_tables</code>表来查看对应的<code>table id</code></li><li>如果记录中主键只包含一列，那么在类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo</code>日志中，只需要把该列占用的存储空间大小和真实值记录下来。如果记录中的逐渐包含多个列，那么每个列占用的存储空间大小和对应的真实值都需要记录下来。（真实值就是指 对应的主键id）</li></ul><blockquote><p>在向表中插入一条记录时，其实聚簇索引和二级索引都需要插入记录。不过在记录undo日志时，只需要根据聚簇索引记录一条undo日志就好了。</p></blockquote><p><strong>by the way</strong>：<code>innodb</code>行格式</p><p>聚簇索引的记录除了会记录完整的用户数据以外，还会记录几个隐藏列：</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420135942889.png" alt="image-20240420135942889"></p><blockquote><p>row_id就是隐藏id，不是必须的</p></blockquote><p>这个<code>roll_pointer</code>，其实本质就是一个指向记录对应的undo日志指针。</p><p>当我们在一次事务中，插入了两条记录后，假如分配的事务id为100，其对应的关系如下图</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420141005150.png" alt="image-20240420141005150"></p><h2 id="delete操作对应的undo日志"><a href="#delete操作对应的undo日志" class="headerlink" title="delete操作对应的undo日志"></a>delete操作对应的undo日志</h2><p>数据页中的数据会根据记录头中的<code>next_record</code>属性组成一个单向链表。</p><p>被删除的记录也会根据记录头中的<code>next_record</code>属性组成一个链表，不过这个链表中的记录占用的存储空间可以被重新利用，所以这个链表也被称为<strong>垃圾链表</strong></p><p>Page Header部分中有一个名为<code>PAGE FREE</code>的属性，它指向垃圾链表的头节点</p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420142227528.png" alt="image-20240420142227528" style="zoom:80%;"><p>数据行中的记录头信息中，有一个<code>delete_flag</code>标识，用来标记数据是否被删除。</p><p>假如现在数据状态如下：</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420143626870.png" alt="image-20240420143626870"></p><p>我们要把正常记录的最后一条记录删掉，这个删除过程需要经历两个过程</p><ul><li><p>阶段1：仅仅将该记录的<code>delete_flag</code>标识位设置为1。这个过程称为<strong>delete mark</strong></p><blockquote><p>其实也会修改<code>trx_id</code>、<code>roll_pointer</code>这些隐藏列的值</p></blockquote></li></ul><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420144120007.png" alt="image-20240420144120007"></p><ul><li><p>阶段2：当该删除语句提交事务后，会有专门的线程来真正地把记录删除掉（也就是将记录移到垃圾链表）。这个过程阶段称为<strong>purge</strong></p><blockquote><p>被删除的记录，以头插法加到垃圾链表的头节点</p></blockquote></li></ul><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420144551844.png" alt="image-20240420144551844"></p><p>在阶段2执行完成之后，这条记录就算是被真正删除了，占用的存储空间也就可以被重新利用了。</p><p>事务一旦提交，也就不需要考虑回滚的事了，所以只需要针对第一阶段<code>delete mark</code>进行回滚就好了</p><p><code>MySql</code>设计了一种名为<code>TRX_UNDO_DEL_MARK_REC</code>类型的undo日志</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420150428571.png" alt="image-20240420150428571"></p><ul><li><p>在对一条记录进行delete mark操作之前，需要把该记录的<code>trx_id</code>和<code>roll_pointer</code>隐藏列的旧值都记录到对应的undo日志中的 <code>trx_id</code> 和 <code>roll_pointer</code>属性中。</p><blockquote><p>这样可以通过undo日志的<code>roll pointer</code>属性找到上一次对该记录进行改动时产生的<code>undo</code>日志</p><p>比如：现在有两个事务，一个对其更新，一个对其删除，更新在前，删除在后，删除后如果要回滚，应该回滚到更新后的状态，这个东西其实就是版本链</p></blockquote></li><li><p>索引各列信息：如果某个列，加到了索引列中，就会把索引的相关信息记录到这里。</p><blockquote><p>&lt;pos，len,  value&gt;：pos表示该列在记录中的位置，len该列占用的存储空间大小，value表示该列实际值</p></blockquote></li></ul><h2 id="update操作对应的undo日志"><a href="#update操作对应的undo日志" class="headerlink" title="update操作对应的undo日志"></a>update操作对应的undo日志</h2><ul><li><p>不更新主键</p><ul><li>就地更新（in-place update)<ul><li>在更新时，对于被更新的列来说，如果更新前后 占用的存储空间一样大，那么就可以直接在原记录的基础上修改对应列的值（必须一样大，更新后存储空间变大或变小，都不能就地更新）</li></ul></li><li>先删除旧记录，再插入新记录<ul><li>如果更新前后占用的存储空间大小不一致，就需要先把这条旧记录删除，再根据更新后的值插入一条新记录</li><li>这里说的删除不是delete mark，而是真正的删除，也就是加入到垃圾链表。这里执行删除操作的也并不是delete语句中进行purge操作时使用的后台线程，而是用户线程执行的同步删除</li><li>如果新创建的记录占用的存储空间不超过旧记录占用的存储空间，那么可以直接重用旧记录的存储空间；否则需要在页面中新申请一块记录供新记录使用</li></ul></li></ul><p>针对这种不更新主键的情况（包括上面两种情况），<code>MySql</code>设计了一种类型为<code>TRX_UNDO_UPD_EXIST_REC</code>类型的undo日志</p></li></ul><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420154213392.png" alt="image-20240420154213392"></p><blockquote><p>如果update语句中更新的列包含了索引列，那么就会添加”索引列各列信息”这个部分，否则不会添加这个部分</p></blockquote><ul><li><p>更新主键</p><ul><li>在聚簇索引中，记录按照主键值的大小连成一个单向链表。如果更新了主键，那么这个主键在聚簇索引中的位置将要发生变化。</li></ul><p>对于这种更新主键的update语句，分两步进行处理</p></li></ul><ol><li>将旧记录执行<code>delete mark</code>操作</li><li>根据更新后各列的值，创建一条新记录，插入到聚簇索引中</li></ol><p>如果被更新的列包含了二级索引列。就需要更新二级索引的数据</p><ol><li>将旧记录执行<code>delete mark</code>操作</li><li>根据更新后各列的值，创建一条新的二级索引记录，插入到二级索引中</li></ol><h2 id="FIL-PAGE-UNDO-LOG"><a href="#FIL-PAGE-UNDO-LOG" class="headerlink" title="FIL_PAGE_UNDO_LOG"></a>FIL_PAGE_UNDO_LOG</h2><p>undo日志存放在类型为 <code>FIL_PAGE_UNDO_LOG</code>的页面中。这种页面的通用结构如下：</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420215420389.png" alt="image-20240420215420389"></p><h3 id="Undo-Page-Header"><a href="#Undo-Page-Header" class="headerlink" title="Undo Page Header"></a>Undo Page Header</h3><p>Undo Page Header是undo日志独有的，结构如下</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420215801433.png" alt="image-20240420215801433"></p><ul><li><p><code>TRX_UNDO_PAGE_TYPE</code>：本页面存放的undo日志类型</p><p>undo日志主要分为两个大类</p><ul><li><code>TRX_UNDO_INSERT</code>：一般由insert语句产生，更新语句更新主键时也会产生此类型的undo日志，<code>TRX_UNDO_INSERT_REC</code>的undo日志就属于这个大类。（这种类型的日志，在事务提交之后，可以直接删掉。下面这个类型的还需要为<code>MVVC</code>服务）</li><li><code>TRX_UNDO_UPDATE</code>：除了类型为<code>TRX_UNDO_INSERT_REC</code>的undo日志，其他类型的undo日志都属于这个大类。一般由DELETE、UPDATE语句产生的undo日志都属于这个大类。</li></ul><p><code>TRX_UNDO_PAGE_TYPE</code>属性的可选值就是上面两个，用来标记本页面用于存储哪个大类的undo日志。不同大类的undo日志不能混着存储。</p></li></ul><ul><li><code>TRX_UNDO_PAGE_START</code>：第一条undo日志在本页面中的起始偏移量。</li><li><code>TRX_UNDO_PAGE_FREE</code>：与上面的<code>TRX_UNDO_PAGE_START</code>对应，表示当前页面中存储的最后一条undo日志结束时的偏移量。</li><li><code>TRX_UNDO_PAGE_NODE</code>：代表一个链表节点结构。</li></ul><h2 id="undo页面链表"><a href="#undo页面链表" class="headerlink" title="undo页面链表"></a>undo页面链表</h2><p>一个事务可能包含多个语句，一个语句也可能对多个聚簇索引的记录进行改动。在对每条聚簇索引记录改动前，都需要记录1条或2条undo日志。</p><p>一个事务执行过程中可能产生很多undo日志。这些日志可能一个页面放不下，需要放到多个页面中，这些页面通过<code>TRX_UNDO_PAGE_NODE</code>属性连成一个链表 </p><p>一个事务执行过程中，可能会混合执行多种类型的语句，产生不同类型的undo日志。但是一个undo页面只能存储一个类型的undo日志。</p><p>所以一个事务的执行过程中，可能需要两个undo页面的链表。一条<code>insert undo</code>链表，另一条称为<code>unpdate undo</code>链表。</p><p>在对普通表和用户临时表的记录改动时所产生的undo日志要分别记录。所以一个事务最多有4个以undo页面为节点组成的链表。</p><p><img src="/2024/04/14/MySql%E7%9A%84%E6%97%A5%E5%BF%97/typora-user-images\MySql的日志\image-20240420230059192.png" alt="image-20240420230059192"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;binlog&quot;&gt;&lt;a href=&quot;#binlog&quot; class=&quot;headerlink&quot; title=&quot;binlog&quot;&gt;&lt;/a&gt;binlog&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;二进制日志，记录了数据库发生的变化。如新建了一个数据库或者表、表结构发生改变、表中</summary>
      
    
    
    
    <category term="MySQL" scheme="https://c89757.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://c89757.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB-BufferPool</title>
    <link href="https://c89757.github.io/2024/04/14/MySql-BufferPool/"/>
    <id>https://c89757.github.io/2024/04/14/MySql-BufferPool/</id>
    <published>2024-04-14T06:55:16.000Z</published>
    <updated>2025-12-18T17:04:55.795Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>其实就是一片连续的内存缓冲区，用于缓解CPU和磁盘的速度矛盾。</p><p>数据从磁盘加载出来后，会放到<code>BufferPool</code>中缓存起来，下次需要读取相同的页面时，直接从内存中获取即可。</p></blockquote><h1 id="BufferPoll的组成"><a href="#BufferPoll的组成" class="headerlink" title="BufferPoll的组成"></a>BufferPoll的组成</h1><p><code>BufferPool</code>会将一片连续的内存划分为若干个页面，页面大小与<code>InnoDB</code>表空间大小一致，也就是默认<code>16KB</code>，</p><p>每一个缓冲页对应一个控制块，记录了页面的一些元数据，比如该页面所属的表空间号，页号，缓冲页的物理地址等。</p><p>控制块也在<code>BufferPool</code>的内存中，放在缓冲页的前面，如下图</p><br><img src="/2024/04/14/MySql-BufferPool/1.png" class><br><h2 id="Free链表"><a href="#Free链表" class="headerlink" title="Free链表"></a>Free链表</h2><blockquote><p>为了知道哪一个缓冲页是空闲可用的。</p></blockquote><p><code>MySql</code>会将所有空闲的缓冲页的对应的<strong>控制块 作为一个节点</strong>放到链表中串起来，这个链表就是<code>free链表</code>（或空闲链表）.</p><p>在<code>MySql</code>服务刚刚启动时，会向操作系统申请一片连续的内存空间用于<code>BufferPoll</code>，将他划分为控制块和缓冲页，此时所有的缓冲页都是空闲可用的，即所有缓冲页（的控制块）都处于<code>free链表</code>中。当有数据需要加载进<code>BufferPoll</code>中时，从free链表中获取一个空闲的缓冲页，并将数据所对应的表空间、页号等信息填入缓冲页的控制块中，最后将该缓冲页对应的控制块从<code>free链表</code>中移除。</p><h2 id="如何知道数据页是否在缓冲页中"><a href="#如何知道数据页是否在缓冲页中" class="headerlink" title="如何知道数据页是否在缓冲页中?"></a>如何知道数据页是否在缓冲页中?</h2><p>在访问某个页的数据时，如果数据页已经被加载进<code>BufferPool</code>了，就不会再从磁盘读取数据，那么如何知道数据页已经被加载了呢？</p><p>加载磁盘数据时，其实是通过表空间号 + 页号来定位一个唯一页面的。</p><p><code>MySql</code>会维护一个<code>hash</code>表，<code>hash</code>表的key就是 表空间号 + 页号，value就是缓冲页控制块的地址。</p><p>当需要访问某个页面时，根据key从hash表中查找，如果value不为空，则直接访问内存中的数据；</p><p>如果value为空，则从磁盘加载页数据后，从free链表中获取一个缓冲页，将其缓存起来。</p><h2 id="Flush链表"><a href="#Flush链表" class="headerlink" title="Flush链表"></a>Flush链表</h2><blockquote><p>解决缓存一致性的问题</p></blockquote><br><p>当某个要修改某行数据时，如果该页的数据已经被加载进<code>BufferPoll</code>了，那<code>MySql</code>只会先修改<code>buffer pool</code>中的数据，不会立马更新磁盘，那么该修改过的缓冲页就被称为<strong>脏页（Dirty Page）</strong>。</p><br><blockquote><p>如果要修改二级索引数据，并且二级索引数据页不在buffer pool中，<code>MySql</code>会将其修改保存到change buffer中，待下次查询出来时，将其结果合并。change buffer属于buffer pool中的一小部分，change buffer只支持二级索引！</p></blockquote><br><p><code>Mysql</code>会维护一个<code>flush链表</code>，来管理这些脏页，由后台线程定期将脏页中的数据刷到磁盘</p><p>跟free链表结构差不多，flush链表也会将 脏页对应的控制块作为节点</p><h1 id="LRU链表"><a href="#LRU链表" class="headerlink" title="LRU链表"></a>LRU链表</h1><blockquote><p>缓冲页的淘汰策略</p></blockquote><p>buffer pool的内存大小有限，总会有用完的一天，如果缓冲页全部被用完了怎么办呢？</p><p><code>MySql</code>基于变种的<code>LRU</code>算法。将已经使用了的缓冲页对应的控制块串起来，用特定算法去淘汰掉最近最少使用的缓冲页。</p><blockquote><p>free链表中的控制块一定不在<code>LRU</code>链表中，但是flush链表中的控制块一定在<code>LRU链表</code>中。</p></blockquote><br><ul><li><code>InnoDB</code>的<strong>预读</strong></li></ul><p>有点空间局部性和时间局部性的味道</p><p>线性预读：当顺序访问某个区的页面超过了<code>innodb_read_ahead_threshold</code>的值，就会触发异步读取下一个区中的全部页面到<code>Buffer Pool</code>中</p><p>随机预读：如果某个区的13个连续的页面都已经被加载到了<code>Buffer Pool</code>中，就会触发一次异步读取本区的其他所有页面到<code>Buffer Pool</code>中。随机预读默认关闭，需要通过<code>innodb_random_read_ahead</code>开启。</p><br><p>预读可能导致 许多无用页面被加载到<code>Buffer Pool</code>中，影响到缓冲页的淘汰</p><p><code>MySql</code>将<code>LRU链表</code>按照一定比例划分为两个区域</p><p>young区域：存储使用频率较高的缓冲页，这部分链表也称为热数据</p><p>old区域：存储使用频率不是很高的缓冲页，这部分链表也称为冷数据</p><ul><li><p>当磁盘上的某个数据页在初次加载到<code>Buffer Pool</code>中时，该缓冲区对应的磁盘块会放到old区域的头部。如果该页面不进行后续访问，会逐渐从old区逐出，而不会影响到young区域中使用较频繁的缓存页。</p></li><li><p>对于全表扫描来说，短时间内访问大量使用频率非常低的页面（一个页面很有很数据，每次获取数据都相当于访问一次页面）。如果访问old区某个缓冲页的时间点，相较于上次访问的时间间隔 小于<code>innodb_old_blocks_time</code>的值，则不会将该old区的数据移动到young区。</p></li><li><p>只有访问的缓冲页位于young区域的1/4的后面时，才会被移动到<code>LRU链表</code>头部。这样可以降低调整链表的频率，提高性能</p></li></ul><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-change-buffer.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-change-buffer.html</a></p><h1 id="innodb-buffer-pool-instances"><a href="#innodb-buffer-pool-instances" class="headerlink" title="innodb_buffer_pool_instances"></a>innodb_buffer_pool_instances</h1><p>在多线程环境下，访问Buffer Pool的各种链表都需要加锁，锁粒度较大，影响效率。于是可以将一个大的<code>Buffer Pool</code>拆成若干个小的<code>Buffer Pool</code>，每个<code>Buffer Pool</code>都是称为一个实例，他们是相互独立的——独立申请内存，独立管理各种链表。</p><p>可以通过修改系统参数 <code>innodb_buffer_pool_instances</code>的值来修改<code>Buffer Pool</code>实例的个数</p><h1 id="innodb-buffer-pool-chunk-size"><a href="#innodb-buffer-pool-chunk-size" class="headerlink" title="innodb_buffer_pool_chunk_size"></a>innodb_buffer_pool_chunk_size</h1><p><code>MySql</code>在申请<code>buffer pool</code>的内存时，是以一个chunk为单位向操作系统申请空间的，一个chunk就代表一片连续的内存空间。</p><p>一个<code>Buffer Pool</code>实例其实就是由若干个chunk组成的</p><p>我们可以通过修改参数<code>innodb_buffer_pool_chunk_size</code>来调整chunk的大小</p><p>tips</p><blockquote><p><code>innodb_buffer_pool_size</code>的值 必须是 <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code>的倍数（主要为了保证每个Buffer Pool实例中的chunk数量相同</p></blockquote><h1 id="查看Buffer-Pool信息"><a href="#查看Buffer-Pool信息" class="headerlink" title="查看Buffer Pool信息"></a>查看Buffer Pool信息</h1><p>可以通过语句<code>show innodb engine status</code>来查看<code>innodb</code>存储引擎运行过程中的一些状态信息，其中就有Buffer Pool的信息（也可以查看死锁等信息）</p><p>下面是部分信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----------------------</span></span><br><span class="line">BUFFER POOL <span class="keyword">AND</span> MEMORY</span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line">Total <span class="keyword">large</span> memory allocated <span class="number">8585216</span></span><br><span class="line">Dictionary memory allocated <span class="number">229735</span></span><br><span class="line">Buffer pool size   <span class="number">512</span></span><br><span class="line"><span class="keyword">Free</span> buffers       <span class="number">254</span></span><br><span class="line">Database pages     <span class="number">256</span></span><br><span class="line"><span class="keyword">Old</span> database pages <span class="number">0</span></span><br><span class="line">Modified db pages  <span class="number">0</span></span><br><span class="line">Pending <span class="keyword">reads</span>      <span class="number">0</span></span><br><span class="line">Pending writes: LRU <span class="number">0</span>, flush list <span class="number">0</span>, single page <span class="number">0</span></span><br><span class="line">Pages made young <span class="number">0</span>, <span class="keyword">not</span> young <span class="number">0</span></span><br><span class="line"><span class="number">0.00</span> youngs<span class="operator">/</span>s, <span class="number">0.00</span> non<span class="operator">-</span>youngs<span class="operator">/</span>s</span><br><span class="line">Pages read <span class="number">480</span>, created <span class="number">57</span>, written <span class="number">128</span></span><br><span class="line"><span class="number">0.00</span> <span class="keyword">reads</span><span class="operator">/</span>s, <span class="number">0.00</span> creates<span class="operator">/</span>s, <span class="number">0.76</span> writes<span class="operator">/</span>s</span><br><span class="line">Buffer pool hit rate <span class="number">1000</span> <span class="operator">/</span> <span class="number">1000</span>, young<span class="operator">-</span>making rate <span class="number">0</span> <span class="operator">/</span> <span class="number">1000</span> <span class="keyword">not</span> <span class="number">0</span> <span class="operator">/</span> <span class="number">1000</span></span><br><span class="line">Pages read ahead <span class="number">0.00</span><span class="operator">/</span>s, evicted <span class="keyword">without</span> access <span class="number">0.00</span><span class="operator">/</span>s, Random read ahead <span class="number">0.00</span><span class="operator">/</span>s</span><br><span class="line">LRU len: <span class="number">256</span>, unzip_LRU len: <span class="number">0</span></span><br><span class="line">I<span class="operator">/</span>O sum[<span class="number">34</span>]:cur[<span class="number">0</span>], unzip sum[<span class="number">0</span>]:cur[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li><p><code>Total memory allocated</code>：代表<code>Buffer Pool</code>向操作系统申请的连续内存空间大小，包括全部控制块、缓存页、以及碎片的大小。</p></li><li><p><code>Dictionary memory allocated</code>：为数据字典信息分配的内存空间大小，注意这个内存空间和<code>Buffer Pool</code>没啥关系，不包括在<code>Total memory allocated</code>中。</p></li><li><p><code>Buffer pool size</code>：代表该<code>Buffer Pool</code>可以容纳多少缓存<code>页</code>，注意，单位是<code>页</code>！</p></li><li><p><code>Free buffers</code>：代表当前<code>Buffer Pool</code>还有多少空闲缓存页，也就是<code>free链表</code>中还有多少个节点。</p></li><li><p><code>Database pages</code>：代表<code>LRU</code>链表中的页的数量，包含<code>young</code>和<code>old</code>两个区域的节点数量。</p></li><li><p><code>Old database pages</code>：代表<code>LRU</code>链表<code>old</code>区域的节点数量。</p></li><li><p><code>Modified db pages</code>：代表脏页数量，也就是<code>flush链表</code>中节点的数量。</p></li><li><p><code>Pending reads</code>：正在等待从磁盘上加载到<code>Buffer Pool</code>中的页面数量。</p><p>当准备从磁盘中加载某个页面时，会先为这个页面在<code>Buffer Pool</code>中分配一个缓存页以及它对应的控制块，然后把这个控制块添加到<code>LRU</code>的<code>old</code>区域的头部，但是这个时候真正的磁盘页并没有被加载进来，<code>Pending reads</code>的值会跟着加1。</p></li><li><p><code>Pending writes LRU</code>：即将从<code>LRU</code>链表中刷新到磁盘中的页面数量。</p></li><li><p><code>Pending writes flush list</code>：即将从<code>flush</code>链表中刷新到磁盘中的页面数量。</p></li><li><p><code>Pending writes single page</code>：即将以单个页面的形式刷新到磁盘中的页面数量。</p></li><li><p><code>Pages made young</code>：代表<code>LRU</code>链表中曾经从<code>old</code>区域移动到<code>young</code>区域头部的节点数量。</p><p>这里需要注意，一个节点每次只有从<code>old</code>区域移动到<code>young</code>区域头部时才会将<code>Pages made young</code>的值加1，也就是说如果该节点本来就在<code>young</code>区域，由于它符合在<code>young</code>区域1/4后边的要求，下一次访问这个页面时也会将它移动到<code>young</code>区域头部，但这个过程并不会导致<code>Pages made young</code>的值加1。</p></li><li><p><code>Page made not young</code>：在将<code>innodb_old_blocks_time</code>设置的值大于0时，首次访问或者后续访问某个处在<code>old</code>区域的节点时由于不符合时间间隔的限制而不能将其移动到<code>young</code>区域头部时，<code>Page made not young</code>的值会加1。</p><p>这里需要注意，对于处在<code>young</code>区域的节点，如果由于它在<code>young</code>区域的1/4处而导致它没有被移动到<code>young</code>区域头部，这样的访问并不会将<code>Page made not young</code>的值加1。</p></li><li><p><code>youngs/s</code>：代表每秒从<code>old</code>区域被移动到<code>young</code>区域头部的节点数量。</p></li><li><p><code>non-youngs/s</code>：代表每秒由于不满足时间限制而不能从<code>old</code>区域移动到<code>young</code>区域头部的节点数量。</p></li><li><p><code>Pages read</code>、<code>created</code>、<code>written</code>：代表读取，创建，写入了多少页。后边跟着读取、创建、写入的速率。</p></li><li><p><code>Buffer pool hit rate</code>：表示在过去某段时间，平均访问1000次页面，有多少次该页面已经被缓存到<code>Buffer Pool</code>了。</p></li><li><p><code>young-making rate</code>：表示在过去某段时间，平均访问1000次页面，有多少次访问使页面移动到<code>young</code>区域的头部了。</p><p>需要大家注意的一点是，这里统计的将页面移动到<code>young</code>区域的头部次数不仅仅包含从<code>old</code>区域移动到<code>young</code>区域头部的次数，还包括从<code>young</code>区域移动到<code>young</code>区域头部的次数（访问某个<code>young</code>区域的节点，只要该节点在<code>young</code>区域的1/4处往后，就会把它移动到<code>young</code>区域的头部）。</p></li><li><p><code>not (young-making rate)</code>：表示在过去某段时间，平均访问1000次页面，有多少次访问没有使页面移动到<code>young</code>区域的头部。</p><p>需要大家注意的一点是，这里统计的没有将页面移动到<code>young</code>区域的头部次数不仅仅包含因为设置了<code>innodb_old_blocks_time</code>系统变量而导致访问了<code>old</code>区域中的节点但没把它们移动到<code>young</code>区域的次数，还包含因为该节点在<code>young</code>区域的前1/4处而没有被移动到<code>young</code>区域头部的次数。</p></li><li><p><code>LRU len</code>：代表<code>LRU链表</code>中节点的数量。</p></li><li><p><code>unzip_LRU</code>：代表<code>unzip_LRU链表</code>中节点的数量（由于我们没有具体唠叨过这个链表，现在可以忽略它的值）。</p></li><li><p><code>I/O sum</code>：最近50s读取磁盘页的总数。</p></li><li><p><code>I/O cur</code>：现在正在读取的磁盘页数量。</p></li><li><p><code>I/O unzip sum</code>：最近50s解压的页面数量。</p></li><li><p><code>I/O unzip cur</code>：正在解压的页面数量。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;其实就是一片连续的内存缓冲区，用于缓解CPU和磁盘的速度矛盾。&lt;/p&gt;
&lt;p&gt;数据从磁盘加载出来后，会放到&lt;code&gt;BufferPool&lt;/code&gt;中缓存起来，下次需要读取相同的页面时，直接从内存中获取即可。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://c89757.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://c89757.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>程序OOM时soft-reference没有被回收?</title>
    <link href="https://c89757.github.io/2024/03/30/%E7%A8%8B%E5%BA%8FOOM%E6%97%B6soft-reference%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%9B%9E%E6%94%B6/"/>
    <id>https://c89757.github.io/2024/03/30/%E7%A8%8B%E5%BA%8FOOM%E6%97%B6soft-reference%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%9B%9E%E6%94%B6/</id>
    <published>2024-03-30T14:57:37.000Z</published>
    <updated>2025-12-18T17:27:32.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在编写一块缓存代码时，想到了软引用，但是不太确定软引用究竟在什么时候会被回收，于是就写了一块测试代码</p><blockquote><p>JDK1.8 </p><p>-Xms60m -Xmx60m</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SoftReference&lt;<span class="keyword">byte</span>[]&gt; cache = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            func();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">            sniff();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        cache = <span class="keyword">new</span> SoftReference&lt;&gt;(bytes);</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] tmp = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">            list.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sniff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cache.get();</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;recycling data.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;object still live&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过不断往<code>list</code>填充 大小为<code>1M</code>的字节数组，为了让程序发生<code>OOM</code>，并且在捕获<code>OutOfMemoryError</code>时，来观测软引用的对象是否被回收了</p><p>（<code>cache.get() == null</code>就说明软引用关联的对象，在即将OOM时，被GC回收了）</p><p>但是程序运行结果如下：</p><blockquote><p>object still live</p></blockquote><p>说明在发生OOM时，GC并没有去回收这个软引用对象</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>什么叫软可达对象<em>softly reachable</em> </p><p>官网给出的原文如下：</p><blockquote><p>An object is <em>softly reachable</em> if it is not strongly reachable but can be reached by traversing a soft reference.</p></blockquote><p><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ref/package-summary.html#reachability">oracle官方文档链接</a></p><p>很重要的一点，<code>not strongly reachable</code>，不被强引用关联!</p><p>上述例子中，就是因为 <code>new byte[1024 * 1024]</code> 除了被软引用关联外，还被变量<code>bytes</code>的强引用关联，所以，即使到最后发生了<code>OOM</code>，<code>Garbage Collector</code>也不会去回收它。</p><p>将代码改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cache = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] tmp = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">            list.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不再使用变量去关联<code>new byte[1024 * 1024]</code>, 而是直接将他添加到引用对象中</p><p>程序运行结果：</p><blockquote><p>recycling data</p></blockquote><p>软引用对象被正常回收</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>在上述例子中，如果将代码改为如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static SoftReference&lt;byte[]&gt; cache = new SoftReference&lt;&gt;(new byte[0]);</span><br><span class="line"></span><br><span class="line">    public static List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            func();</span><br><span class="line">        &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">            sniff();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void func() &#123;</span><br><span class="line">        for(;;) &#123;</span><br><span class="line">            byte[] tmp = new byte[1024 * 1024];</span><br><span class="line">            list.add(tmp);</span><br><span class="line">            byte[] bytes = new byte[1024 * 1024];</span><br><span class="line">            cache = new SoftReference&lt;&gt;(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void sniff() &#123;</span><br><span class="line">        byte[] bytes = cache.get();</span><br><span class="line">        if (bytes == null) &#123;</span><br><span class="line">            System.out.println(&quot;recycling data.&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;object still live&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是将</p><p><code>byte[] bytes = new byte[1024 * 1024]; cache = new SoftReference&lt;&gt;(bytes);</code></p><p>这两行代码放入for循环里面，<code>list.add(tmp)</code>后面</p><p>程序运行结果：</p><blockquote><p>recycling data.</p></blockquote><br><p>按照我们上述的分析来说，这里也有一个强引用<code>bytes</code>关联这个数组，为什么发生<code>OOM</code>时软引用还能被回收呢？</p><br><p>因为这个例子有点特殊，事先说明一点，程序是运行到这一行发生的<code>OOM</code><br><code>byte[] bytes = new byte[1024 * 1024];</code></p><br><p>可以将代码加上几个打印点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] tmp = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        list.add(tmp);</span><br><span class="line">        System.out.println(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">        cache = <span class="keyword">new</span> SoftReference&lt;&gt;(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序是在输出<code>add</code>之后发生的<code>OOM</code>，但是并没有输出<code>after</code></p><p>值得注意的是，在循环中，<code>bytes</code>所指向的对象一直在变化。</p><p>如图：在执行完某一次循环的最后一行代码后，对象的指针如下</p><br><img src="/2024/03/30/%E7%A8%8B%E5%BA%8FOOM%E6%97%B6soft-reference%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%9B%9E%E6%94%B6/image-20240331000639577.png" class><br><p>紧接着继续循环，代码执行到<code>byte[] bytes = new byte[1024 * 1024];</code>时，对象的关系如下</p><br><img src="/2024/03/30/%E7%A8%8B%E5%BA%8FOOM%E6%97%B6soft-reference%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%9B%9E%E6%94%B6/image-20240331001043783.png" class><br><p>此时，软引用所指向的对象 并没有强引用的关联关系，如果此时发生内存紧张，那么软引用所引用的对象就会被回收。</p><blockquote><p>顺便一提，如果将那两行代码放在循环体的开始，程序运行结果又会不一样，究其原因还是当即将发生<code>OOM</code>时，软引用变量所持有的对象究竟有没有被强引用所关联。</p><p>在上述例子中，bytes变量所持有的对象的生命周期只在一个循环中，下次循环会被覆盖，原先的引用关系被断开。而<code>list.add(tmp)</code>，<code>tmp</code>所指向的对象一直被添加到static申明的变量中，生命周期也就和static变量一样</p></blockquote><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>感谢<code>stackOverFlow</code>上的这位老哥的答疑</p><p>原帖链接如下：</p><p><a href="https://stackoverflow.com/questions/78247787/java-softreference-soft-references-were-not-collected-before-the-occurrence-of">https://stackoverflow.com/questions/78247787/java-softreference-soft-references-were-not-collected-before-the-occurrence-of</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近在编写一块缓存代码时，想到了软引用，但是不太确定软引用究竟在什么时候会被回收，于是就写了一块测试代码&lt;/p&gt;
&lt;blockquote&gt;
</summary>
      
    
    
    
    <category term="java" scheme="https://c89757.github.io/categories/java/"/>
    
    
    <category term="questions" scheme="https://c89757.github.io/tags/questions/"/>
    
    <category term="java" scheme="https://c89757.github.io/tags/java/"/>
    
    <category term="GC" scheme="https://c89757.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>记-升级mariadb-java-client引发的问题</title>
    <link href="https://c89757.github.io/2024/03/11/%E8%AE%B0-%E5%8D%87%E7%BA%A7mariadb-java-client%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://c89757.github.io/2024/03/11/%E8%AE%B0-%E5%8D%87%E7%BA%A7mariadb-java-client%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2024-03-11T11:05:10.000Z</published>
    <updated>2025-12-18T17:15:24.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目中使用<code>flywaydb</code>作为数据库迁移工具</p><p>但是在执行一段<code>DDL</code>语句时，引发了报错</p><p>语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name MODIFY <span class="keyword">COLUMN</span> column_name data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>该字段之前默认<code>NULL</code>，现将其改为<code>NOT NULL</code></p><p>执行却报错：<code>Invalid use of null value;</code></p><h1 id="排错"><a href="#排错" class="headerlink" title="排错"></a>排错</h1><p>网上查了下，因为表中已经存在了<code>NULL</code>值，所以不允许将其修改为<code>NOT NULL</code>。</p><p>但是，将这段脚本直接放到<code>navicat</code>中却能执行成功。</p><p>到此开始怀疑是项目升级<code>mariadb-java-client</code>至<code>2.7.10</code>导致的。且这种语句执行结果的差异化，大多和<code>sql_mode</code>有关。</p><ol><li>查询<code>mysql</code>官网</li></ol><p><a href="https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html">https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html</a></p><p>没有明确找到针对词条语句有做差异化的<code>sql_mode</code>，推测是与严格模式有关——<code>STRICT_TRANS_TABLES</code>;</p><ol start="2"><li>在<code>navicat</code>中，查看<code>sql_mode</code></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@GLOBAL</span>.sql_mode;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@SESSION</span>.sql_mode;</span><br></pre></td></tr></table></figure><p>结果都为空</p><ol start="3"><li>设置session级别的<code>sql_mode</code></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION sql_mode <span class="operator">=</span> sys.list_add(@<span class="variable">@session</span>.sql_mode, <span class="string">&#x27;STRICT_TRANS_TABLES&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>设置完后，再次执行脚本，问题复现<code>Invalid use of null value</code>;</li></ol><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol><li>可以在<code>DDL</code>之前，通过<code>update</code>语句，将全部的NULL值修改为不为NULL</li></ol><ol start="2"><li>在执行<code>DDL</code>之前，判断是否开启了<code>STRICT_TRANS_TABLES</code>, 如果有开启，可以先将其移除，<code>DDL</code>执行之后再将其加回来</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION sql_mode <span class="operator">=</span> sys.list_drop(@<span class="variable">@session</span>.sql_mode, <span class="string">&#x27;STRICT_TRANS_TABLES&#x27;</span>);</span><br><span class="line">&#123;&#123;DDL&#125;&#125;;</span><br><span class="line"><span class="keyword">SET</span> SESSION sql_mode <span class="operator">=</span> sys.list_add(@<span class="variable">@session</span>.sql_mode, <span class="string">&#x27;STRICT_TRANS_TABLES&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>修改项目中数据库的<code>URL</code>连接串，添加参数<code>jdbcCompliantTruncation=false</code></li></ol><p>这个是通过源码发现的，当这个值为<code>true</code>时（默认为true)，<code>mariadb</code>连接<code>mysql</code>时，会添加上session级别的<code>STRICT_TRANS_TABLES</code>, 所以将他关掉即可。另外，开启这个值后，还影响一些其他功能，如：插入时，字段超长，将不会报错，而是截取</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;项目中使用&lt;code&gt;flywaydb&lt;/code&gt;作为数据库迁移工具&lt;/p&gt;
&lt;p&gt;但是在执行一段&lt;code&gt;DDL&lt;/code&gt;语句时，</summary>
      
    
    
    
    <category term="MySQL" scheme="https://c89757.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://c89757.github.io/tags/MySQL/"/>
    
    <category term="questions" scheme="https://c89757.github.io/tags/questions/"/>
    
  </entry>
  
  <entry>
    <title>resilience4j</title>
    <link href="https://c89757.github.io/2023/12/20/resilience4j/"/>
    <id>https://c89757.github.io/2023/12/20/resilience4j/</id>
    <published>2023-12-20T08:48:45.000Z</published>
    <updated>2025-12-21T17:16:28.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>/rɪˈzɪliəns/</p><blockquote><p><a href="https://github.com/resilience4j/resilience4j">https://github.com/resilience4j/resilience4j</a></p></blockquote><p>​    Resilience4j 是一个轻量级容错库，专为函数式编程而设计。设计灵感来源于Netflix 的Hystrix框架。Resilience4j 提供高阶函数（装饰器），通过断路器、速率限制器、重试或隔板来增强任何函数接口、lambda 表达式或方法引用。您可以在任何功能接口、lambda 表达式或方法引用上堆叠多个装饰器。这样做的好处是，你可以根据需要选择特定的装饰器进行组合</p><p><strong>核心模块</strong></p><ul><li>resilience4j-circuitbreaker: 熔断</li><li>resilience4j-ratelimiter: 限流</li><li>resilience4j-bulkhead: 隔离</li><li>resilience4j-retry: 自动重试（同步，异步）</li><li>resilience4j-cache: 结果缓存</li><li>resilience4j-timelimiter: 超时处理</li></ul><h1 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h1><p>​    断路器通过有限状态机实现，有三个普通状态：关闭、开启、半开，还有两个特殊状态：禁用、强制开启。</p><p>​    断路器使用滑动窗口来存储和统计调用的结果。你可以选择基于调用数量的滑动窗口或者基于时间的滑动窗口。</p><p>​    基于访问数量的滑动窗口统计了最近N次调用的返回结果。居于时间的滑动窗口统计了最近N秒的调用返回结果。</p><h2 id="基于访问数量的滑动窗口"><a href="#基于访问数量的滑动窗口" class="headerlink" title="基于访问数量的滑动窗口"></a>基于访问数量的滑动窗口</h2><p>​    基于访问数量的滑动窗口是通过一个有N个元素的循环数组实现。</p><p>​    如果滑动窗口的大小等于10，那么循环数组总是有10个统计值。滑动窗口增量更新总的统计值，随着新的调用结果被记录在环形数组中，总的统计值也随之进行更新。当环形数组满了，时间最久的元素将被驱逐，将从总的统计值中减去该元素的统计值，并该元素所在的桶进行重置。</p><p>​    检索快照（总的统计值）的时间复杂度为O(1)，因为快照已经预先统计好了，并且和滑动窗口大小无关。</p><p>​    关于此方法实现的空间需求（内存消耗）为O(n)。</p><h2 id="基于时间的滑动窗口"><a href="#基于时间的滑动窗口" class="headerlink" title="基于时间的滑动窗口"></a>基于时间的滑动窗口</h2><p>​    基于时间的滑动窗口是通过有N个桶的环形数组实现。</p><p>​    如果滑动窗口的大小为10秒，这个环形数组总是有10个桶，每个桶统计了在这一秒发生的所有调用的结果（部分统计结果），数组中的第一个桶存储了当前这一秒内的所有调用的结果，其他的桶存储了之前每秒调用的结果。</p><p>​    滑动窗口不会单独存储所有的调用结果，而是对每个桶内的统计结果和总的统计值进行增量的更新，当新的调用结果被记录时，总的统计值会进行增量更新。</p><p>​    检索快照（总的统计值）的时间复杂度为O(1)，因为快照已经预先统计好了，并且和滑动窗口大小无关。</p><p>​    关于此方法实现的空间需求（内存消耗）约等于O(n)。由于每次调用结果（元组）不会被单独存储，只是对N个桶进行单独统计和一次总分的统计。</p><p>​    每个桶在进行部分统计时存在三个整型，为了计算，失败调用数，慢调用数，总调用数。还有一个long类型变量，存储所有调用的响应时间</p><h2 id="失败率和慢调用率阈值"><a href="#失败率和慢调用率阈值" class="headerlink" title="失败率和慢调用率阈值"></a>失败率和慢调用率阈值</h2><p>​    当失败率大于或等于配置的阈值时，断路器的状态将从关闭变为开启，例如，当超过50%的调用失败时，断路器开启。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;/rɪˈzɪliəns/&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/resilienc</summary>
      
    
    
    
    <category term="分布式" scheme="https://c89757.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://c89757.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2.0</title>
    <link href="https://c89757.github.io/2023/12/18/OAuth2-0/"/>
    <id>https://c89757.github.io/2023/12/18/OAuth2-0/</id>
    <published>2023-12-18T09:36:09.000Z</published>
    <updated>2025-12-18T16:39:36.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​    OAuth2.0允许用户授权第三方应用访问他们在另一个服务提供方上的数据，而无需分享他们的凭证（如用户名、密码）</p><p><strong>基本概念</strong></p><ul><li><p>客户端（Client）</p><p>请求访问资源的<strong>第三方应用</strong>。客户端可以是Web站点、App、设备等</p></li><li><p>服务提供商（Service Provider）</p><p>服务提供商是指提供、存放资源的网络服务。</p></li><li><p>资源所有者（Resource Owner）</p><p>资源所有者通常就是指用户。他们拥有服务提供商上的资源</p></li><li><p>授权服务器（Authorization Server)</p><p>授权服务器是服务提供商用于处理和发放访问令牌的服务器。当用户请求访问资源时，需要先向授权服务器请求访问令牌。</p></li><li><p>资源服务器（Resource Server）</p><p>资源服务器是服务提供商用于存储和管理资源的服务器。当用户访问令牌后，就可以向资源服务器请求资源。</p></li><li><p>访问令牌（Access Token）</p><p>访问令牌是授权服务器发放给客户端的一个凭证。表示客户端有权访问资源所有者的资源。访问令牌有一定的有效期，过期后需要使用刷新令牌来获取新的访问令牌。</p></li><li><p>刷新令牌（Refresh Token）</p><p>刷新令牌是授权服务器在发放访问令牌时一同发放的一个凭证，用于在访问令牌过期后获取新的访问令牌。刷新令牌通常有较长的有效期，甚至可以设置为永不过期。</p></li><li><p>用户代理（User Agent）</p><p>通常指浏览器</p></li></ul><h1 id="四种模式"><a href="#四种模式" class="headerlink" title="四种模式"></a>四种模式</h1><h2 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h2><p>授权码模式用于获取访问<code>AccessToken</code>和<code>RefreshToken</code>，并针对保密客户端进行了优化。</p><p>由于这是一个基于重定向的流程，客户端必须能够与资源所有者的用户代理（通常是网络</p><p>浏览器）进行交互，并能接收来自授权服务器的传入请求（通过重定向）</p><br><img src="/2023/12/18/OAuth2-0/AuthorizationCodeGrant.png" class><br><br><p>A. 客户端（第三方应用）通过将资源所有者的用户代理（浏览器）指向授权服务器来启动流程。</p><p>会带上客户端的标识、重定向URL。一旦资源所有者（用户）同意/拒绝访问，授权服务器会通过用户代理跳到到该URI</p><p>B. 授权服务器对资源所有者进行验证（通过用户代理），并确定资源所有者是同意还是拒绝客户端的访问请求</p><p>C. 如果资源所有者允许访问，授权服务器会使用之前（在请求重或客户端注册期间）提供的重定向URI将用户代理重定向回客户端。重定向URI里带上授权码</p><p>D. 客户端通过授权码向授权服务器请求令牌。请求时带上授权码与<code>redirect_uri</code>（并且<code>redirect_uri</code>必须与A步骤中的相同）</p><p>E. 授权服务器对客户端以及授权码进行认证，认证成功后，授权服务器将返回客户端<code>AccessToken</code>和<code>RefreshToken</code>（可选）</p><br><br><p>举例：</p><p>登录CSDN时，采用QQ登录。</p><p>前提：CSDN会先去QQ开放平台注册一个应用，获得client_id、client_secret。并配置一些redirect_url</p><ol><li><p>点击QQ登录时，浏览器会跳转到QQ登录页面，并且url中的参数response_type=code表示为授权码模式，client_id为客户端标识</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://graph.qq.com/oauth2.0/show?</span><br><span class="line">which=Login</span><br><span class="line">&amp;display=pc</span><br><span class="line">&amp;client_id=100270989</span><br><span class="line">&amp;response_type=code</span><br><span class="line">&amp;redirect_uri=https://passport.csdn.net/account/login?pcAuthType=qq&amp;newAuth=true&amp;state=test</span><br></pre></td></tr></table></figure><blockquote><p>对于资源服务器（QQ）来说，会去校验client_id是否合法，也就是是否注册过。还会校验redirect_url是否合法。</p></blockquote></li><li><p>用户输入QQ所需账户密码，点击登录</p></li><li><p>用户确认授权后，QQ会通过302跳转的形式，跳转到<code>redirect_uri</code>，并在URI后面拼上code授权码</p><blockquote><p><a href="https://passport.csdn.net/account/login?pcAuthType=qq&amp;newAuth=true&amp;state=test&amp;code=E3965C5203EDC6410DF2BF4D889740D6">https://passport.csdn.net/account/login?pcAuthType=qq&amp;newAuth=true&amp;state=test&amp;code=E3965C5203EDC6410DF2BF4D889740D6</a></p></blockquote></li><li><p>CSDN（的后端）服务器会通过授权码向QQ服务器索要Token，并与QQ做认证（AK、SK形式）</p></li><li><p>QQ认证成功后，会给CSDN颁发Token，CSDN即可以通过Token调用QQ开放api，也可以据此来创建自己的会话凭证</p></li></ol><br><p><strong>为什么不能直接获取AccessToken，而是通过授权码去获得？/ 能不能省略授权码这一步</strong></p><blockquote><p>答：不能。如果去掉授权码这一步骤，授权服务器直接返回AccessToken，类似于隐式授权模式</p><p>AccessToken通过浏览器URL返回，不安全。</p><p>无法确定客户端身份：没办法验证客户端的身份，容易被伪造</p></blockquote><br><p><strong>通过授权码获取AccessToken时，为什么必须携带redirect_uri？为什么要与获取授权码时的保持一致?</strong></p><blockquote><p>为了安全考虑（可攻击场景很多，协议规定）</p><p><strong><code>redirect_uri</code> 校验的核心价值是：防止“合法客户端被利用来兑换一个在非预期上下文中生成的授权码”。</strong></p></blockquote><blockquote><p>一个 client_id 可能注册了多个合法的 redirect_uri，利用低级别接口的授权码可以去换取高权限接口的token。不校验redirect_uri可能导致越权或业务逻辑绕过。</p></blockquote><h2 id="隐式授权模式-简化模式"><a href="#隐式授权模式-简化模式" class="headerlink" title="隐式授权模式/简化模式"></a>隐式授权模式/简化模式</h2><p>​    隐式授予类型用于获取访问令牌（不支持签发刷新令牌）</p><p>​    并针对已知可操作特定重定向 URI 的公共客户端进行了优化。 这些客户端通常是在浏览器中使用 JavaScript 等脚本语言实现的。</p><p>​    由于这是一个基于重定向的流程，客户端必须能够与资源所有者的用户代理（通常是浏览器）交互，并能接收来自授权服务器的传入请求（通过重定向）</p><p>​    在授权代码授予类型中，客户端会分别请求授权码和访问令牌，而客户端收到的访问令牌则是授权请求的结果。<br>隐式授予类型不包括客户端身份验证，依赖于资源所有者的存在和重定向 URI 的注册。 由于访问令牌被编码到<br>重定向 URI 中，因此可能会暴露给资源所有者和驻留在同一设备上的其他应用程序。</p><blockquote><p><strong>隐式模式已被 RFC 6749 弃用</strong>，因为它把 token 放在 URL 中，极不安全。</p></blockquote><br><img src="/2023/12/18/OAuth2-0/ImplicitGrant.png" class><br><br><p>A. 客户端通过将资源所有者的用户代理指向授权端点来启动流程。 其中携带客户端标识符、请求范围、本地状态和重定向 URI，一旦访问被批准（或拒绝），授权服务器将把用户代理发回至该 URI。</p><p>B. 授权服务器对资源所有者进行验证（通过用户代理），并确定资源所有者是同意还是拒绝客户端的访问请求。</p><p>C. 如果资源所有者同意访问，授权服务器会使用之前提供的重定向 URI 将用户代理重定向回客户端。 重定向 URI 中携带了访问令牌。</p><p>D. 用户代理（浏览器）根据重定向指令，向网络托管的客户端资源发出请求。 </p><p>E. 网络托管的客户端资源会返回一个网页（通常是一个带有嵌入脚本t的HTML 文档），该网页能够访问<br>完整重定向 URI，包括用户代理保留的片段，并提取片段中包含的访问令牌（和其他参数）。</p><p>F. 用户代理在本地执行网络托管客户端资源提供的脚本，提取访问令牌</p><p>G. 用户代理将访问令牌传递给客户端</p><br><blockquote><p>适用于公开的浏览器单页应用，令牌直接从授权服务器返回，不支持刷新令牌，且没有授权码的安全保证，令牌容易因为被拦截窃听而泄露。</p></blockquote><br><h2 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h2><p>​    密码模式适用于资源所有者与客户端之间存在信任关系。（比如自身内部系统）</p><br><img src="/2023/12/18/OAuth2-0/ResourceOwnerPasswordCredentialsGrant.png" class><br><br><p>A. 资源所有者向客户端提供用户名和密码</p><p>B. 客户端通过从资源所有处接收到的凭证，向授权服务器请求访问令牌。 发出请求时，客户端与授权服务器进行身份验证。</p><p>C. 授权服务器会对客户端进行身份验证，并验证资源所有者凭证，如果有效，则会发出访问令牌。</p><h2 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h2><p>​    客户端模式不涉及用户的参与</p><br><img src="/2023/12/18/OAuth2-0/ClientCredentialsGrant.png" class><br><p>A. 客户端向授权服务器进行身份验证，然后向令牌端点申请访问令牌。</p><p>B. 授权服务器会对客户端进行身份验证，如果有效，返回令牌。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.rfc-editor.org/rfc/rfc6749">https://www.rfc-editor.org/rfc/rfc6749</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;​    OAuth2.0允许用户授权第三方应用访问他们在另一个服务提供方上的数据，而无需分享他们的凭证（如用户名、密码）&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="协议" scheme="https://c89757.github.io/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="协议" scheme="https://c89757.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>MySql事务隔离级别与MVVC</title>
    <link href="https://c89757.github.io/2023/09/26/MySql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVVC/"/>
    <id>https://c89757.github.io/2023/09/26/MySql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVVC/</id>
    <published>2023-09-26T15:20:25.000Z</published>
    <updated>2025-12-18T17:05:20.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h1><p>事务并发执行时会遇到的一致性问题</p><ul><li>脏写</li></ul><p>一个事务修改了另一个未提交事务修改过的数据</p><ul><li>脏读</li></ul><p>一个事务读到了另一个未提交事务修改过的数据</p><blockquote><p>事务T1修改了数据项X的值，然后事务T2又读取了未提交事务T1针对数据项X修改后的值，之后T1中止，而T2提交，这就意味着T2读到了一个根本不存在的值。</p></blockquote><ul><li>不可重复读</li></ul><p>一个事务修改了另一个未提交事务读取的数据</p><blockquote><p>事务T1先读取了数据项X的值，然后T2又修改了未提交事务T1读取的数据项X的值，之后T2提交，然后T1再次读取数据项X的值时，会得到与第一次读取时不同的值。</p></blockquote><ul><li>幻读</li></ul><p>一个事务先根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写入了一些符合那些搜索条件的记录（可以是INSERT、DELETE、UPDATE操作），就意味着发生了幻读现象</p><blockquote><p>T1先读取符合搜索条件P的记录，然后T2写入了符合条件P的记录。之后T1再次读取符合搜索条件P的记录时，会发现两次读取的记录是不一样的。</p></blockquote><h1 id="SQL标准中的四种隔离级别"><a href="#SQL标准中的四种隔离级别" class="headerlink" title="SQL标准中的四种隔离级别"></a>SQL标准中的四种隔离级别</h1><p>上述一致性问题，会对事务的一致性产生不同程度的影响。按照可能导致一致性问题的严重性给这些现象排一下序：</p><p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p><p>sql标准中规定的并发事务执行过程中可以发生的现象</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITED</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>READ COMMITED</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>REPEATABLE READ</td><td>不可能</td><td>不可能</td><td>不可能</td></tr><tr><td>SERIALIZABLE</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><blockquote><p>脏写情况比较严重，任何隔离级别下都不允许该情况发生</p></blockquote><h1 id="MVVC原理"><a href="#MVVC原理" class="headerlink" title="MVVC原理"></a>MVVC原理</h1><p>​    对于InnoDB存储引擎的表来说，它的聚簇索引记录中都包含下面这两个必要的隐藏列（row_id并不是必要的；在创建表中有主键时，或许又不允许为NULL的UNIQUE键时，都不会包含row_id列）</p><ul><li>trx_id：一个事务每次对某条聚簇索引列记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列</li><li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中。这个隐藏列就相当于一个指针，可以通过它找到该记录修改前的信息</li></ul><p>​    每对记录做一次改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（insert操作对应的undo日志没有该属性，因为insert操作的记录并没有更早的版本），通过这个属性可以将这些undo日志串成一个链表。</p><br><img src="/2023/09/26/MySql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVVC/image-20231010234000323.png" class><p>​    在每次更新记录后，都会将旧值放入到一条undo日志中（就算是该记录的一个旧版本）。随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，这个链表称为版本链。版本链的头节点就是当前记录的最新值。同时，每个版本中还包含生成该版本时对应的事务id。</p><p>利用版本链来控制并发事务访问相同记录时的行为，我们把这种机制称为多版本并发控制（Multi-Version Concurrency Control, MVVC）</p><h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2><p>对于使用READ UNCOMMITTED隔离级别的事务来说，可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了；</p><p>对于<code>SERIALIZABLE</code>隔离级别的事务来说，可以使用加锁的方式</p><p>对于<code>READ COMMITED</code>和<code>REPEATABLE READ</code>隔离级别的事务来说，都必须保证读到已经提交的事务修改过多记录。</p><p>核心问题就是需要判断版本链中的哪个版本是当前事务可见的。于是<code>MySql</code>提出了<code>ReadView</code>的概念</p><ul><li><code>m_ids</code>：在生成<code>ReadView</code>时，当前<strong>系统中活跃</strong>的读写事务的事务id列表</li><li><code>min_trx_id</code>：在生成<code>ReadView</code>时，当前<strong>系统中活跃</strong>的读写事务中最小的事务id（也就是<code>m_ids</code>中的最小值）</li><li><code>max_trx_id</code>：在生成<code>ReadView</code>时，系统应该分配给下一个事务的事务id值</li><li><code>creator_trx_id</code>：生成该<code>ReadView</code>的事务的事务id</li></ul><blockquote><p>只有在对表中的记录进行改动时（执行INSERT、UPDATE、DELETE语句这些语句时），才会为事务分配唯一的事务id，否则一个事务的事务id值都默认为0</p></blockquote><p>有了<code>ReadView</code>后，在访问某条记录时，只需要按照下面的步骤来判断记录的某个版本是否可见</p><ul><li>如果被访问版本的<code>trx_id</code>属性值与<code>ReadView</code>中的<code>creator_trx_id</code>值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问</li><li>如果被访问版本的<code>trx_id</code>属性值小于<code>ReadView</code>中的<code>min_trx_id</code>值，表明生成该版本的事务 在当前事务生成<code>ReadView</code>前已经提交，所以可以被访问</li><li>如果被访问版本的<code>trx_id</code>属性值大于<code>ReadView</code>中的<code>max_trx_id</code>值，表明生成该版本的事务 在当前事务生成<code>ReadView</code>后才生成，所以不可被访问</li><li>如果被访问版本的<code>trx_id</code>属性值在<code>ReadView</code>的<code>min_trx_id</code>和<code>max_trx_id</code>之间，则需要判断该<code>trx_id</code>是否在 <code>m_ids</code>列表中。如果在，说明生成该版本的事务还是活跃的，不可以被访问。如果不在，说明事务已经提交，该版本可以被访问</li></ul><p>如果某个版本的数据对当前事务不可见，那就顺着版本链找到下一个版本的数据1，（也就是记录头中的<code>rool_pointer</code>串成的undo日志链表）继续上面的过程判断可见性。</p><p>如果找完最后一个版本，也不能可见，说明该记录对当前事务完全不可见。</p><h2 id="READ-COMMITED"><a href="#READ-COMMITED" class="headerlink" title="READ COMMITED"></a>READ COMMITED</h2><blockquote><p>每次读取数据前都生成一个ReadView</p></blockquote><p>所以<code>READ COMMITED</code>y有不可重复读的问题，</p><blockquote><p>事务T1先读取了数据项X的值，然后T2又修改了未提交事务T1读取的数据项X的值，之后T2提交，然后T1再次读取数据项X的值时，会得到与第一次读取时不同的值。</p></blockquote><p>因为每次查询都会新生成一个ReadView，对于第二次查询生成的ReadView来说，由于事务T2已经提交了，所以他能读取到</p><h2 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h2><blockquote><p>只有第一次执行查询语句时，才会生成一个<code>ReadView</code></p></blockquote><p>所以它可以解决重复读的问题</p><p>事务T1先读取数据项X的值后，会生成一个<code>ReadView</code>，然后事务T2又修改了T1读取的数据项X的值，之后T2提交。</p><p>此时数据行记录的trx_id会变成T2提交的事务id，第二次查询时，发现生成的<code>ReadView</code>中，不满足可见性原则，（<code>ReadView</code>中的<code>max_trx_id</code>小于当前数据行中记录的<code>trx_id</code>）所以不会读到事务2修改后的值</p><p><code>REPEATABLE READ</code>级别下，可以很大程度上解决幻读问题，但是并不能完全解决幻读</p><p>比如：</p><table><thead><tr><th>时刻</th><th>事务T1</th><th>事务T2</th></tr></thead><tbody><tr><td>T1</td><td>BEGIN;<br>SELECT * FROM <code>student</code> where number &gt;= 20221101;<br></td><td></td></tr><tr><td>T2</td><td></td><td>BEGIN;<br>INSERT INTO <code>tmp</code>.<code>student</code> (<code>number</code>, <code>name</code>, <code>major</code>) <br>    VALUES (20221104, ‘赵六’, ‘测试-RR级别下可能发生幻读问题’);<br>COMMIT;</td></tr><tr><td>T3</td><td>UPDATE student set name = ‘赵六2’ where number = 20221104;<br></td><td></td></tr><tr><td>T4</td><td>SELECT * FROM <code>student</code> where number &gt;= 20221101;<br>COMMIT;</td><td></td></tr></tbody></table><p>在T4时刻，T1事务就会发生幻读现象。</p><p>原因是：<code>UPDATE</code>语句不是采用<code>MVVC</code>这种快照读，而是采用的当前读。</p><blockquote><p>当前读是读取的数据库最新的数据，当前读和快照读不同，因为要读取最新的数据而且要保证事务的隔离性，所以当前读是需要对数据进行加锁的</p></blockquote><p>也就是说，事务T1的update语句，会对事务2新增的记录进行加锁、修改字段值、并且将隐藏列<code>trx_id</code>修改为自己的事务id，所以T4时刻根据MVVC再去读取时，发现满足可见性，所以产生幻读现象</p><h2 id="二级索引与MVVC"><a href="#二级索引与MVVC" class="headerlink" title="二级索引与MVVC"></a>二级索引与MVVC</h2><p>只有聚簇索引才有<code>trx_id</code>和<code>roll_pointer</code>隐藏列。那么，如果某个查询语句是使用二级索引来查询的，该如何判断可见性呢？</p><ul><li><p>步骤一：二级索引页面的PAGE HEADER部分，有一个名为<code>PAGE_MAX_TRX_ID</code>的属性，每当对该页面中的记录执行增删改操作时，如果执行该操作的事务的事务id大于 <code>PAGE_MAX_TRX_ID</code>属性值，就会把就会把<code>PAGE_MAX_TRX_ID</code>属性设置为执行该操作的事务的事务id。</p><p>也就是说，<code>PAGE_MAX_TRX_ID</code>的值代表着修改该二级索引页面的最大事务id。</p><p>当select语句访问某个二级索引记录时，首先看一下对应<code>ReadView</code>中的<code>min_trx_id</code>是否大于该页面的<code>PAGE_MAX_TRX_ID</code>，如果大于，则表示该页面中的所有记录都对该<code>ReadView</code>可见；否则就需要执行步骤2，回表之后再判断可见性</p></li><li><p>步骤二：利用二级索引记录中的主键值进行回表操作，得到对应聚簇索引记录后再判断可见性</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一致性问题&quot;&gt;&lt;a href=&quot;#一致性问题&quot; class=&quot;headerlink&quot; title=&quot;一致性问题&quot;&gt;&lt;/a&gt;一致性问题&lt;/h1&gt;&lt;p&gt;事务并发执行时会遇到的一致性问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脏写&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个事务修改了另一个未</summary>
      
    
    
    
    <category term="MySQL" scheme="https://c89757.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://c89757.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>jvm常见命令</title>
    <link href="https://c89757.github.io/2023/08/16/jvm%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>https://c89757.github.io/2023/08/16/jvm%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</id>
    <published>2023-08-16T12:55:41.000Z</published>
    <updated>2025-12-18T17:13:05.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jstat"><a href="#Jstat" class="headerlink" title="Jstat"></a>Jstat</h1><h2 id="JIT相关"><a href="#JIT相关" class="headerlink" title="JIT相关"></a>JIT相关</h2><ul><li>jstata  -compiler [pid]</li></ul><p>查看JIT编译器编译过的方法、耗时等</p><ul><li>jstat -printcompilation</li></ul><p>输出已经被JIT编译的方法</p><h2 id="垃圾回收相关"><a href="#垃圾回收相关" class="headerlink" title="垃圾回收相关"></a>垃圾回收相关</h2><ul><li>-gc</li></ul><blockquote><p> 显示与GC相关的对信息。包括Eden区、两个Survivor区、老年代、永久代等容量、已用空间</p></blockquote><p><code>jstat -gc [pid] 1000 10</code>: 每隔一秒（1000ms ）打印一次gc信息，总共打印10次</p><p><code>jstat -gc -t</code>: 会多一列Timestamp，表示Java进程启动的总时间；</p><p>我们可以比较Java进程启动的总时间以及总GC时间（GCT列），或者两次测量的间隔时间以及GC总时间的增量，得到GC时间占运行时间的比例</p><p>如果该比例超过20%，则说明目前堆压力较大；如果超过90%，则说明堆里几乎没有可用空间，随时都可能抛出OOM异常</p><ul><li>-gccapacoty</li></ul><blockquote><p>显示内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。</p></blockquote><ul><li>-gcutil</li></ul><blockquote><p>显示内容与-gc基本相同。但输出主要关注已使用空间占总空间的百分比</p></blockquote><ul><li>-gccause</li></ul><blockquote><p>与-gcutil功能一样，但会额外输出导致最后一次或当前正在发生的GC产生的原因</p></blockquote><ul><li>-gcnew</li></ul><blockquote><p>显示新生代GC情况</p></blockquote><ul><li>-gcnewcapacity</li></ul><blockquote><p>显示内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</p></blockquote><ul><li>-geold</li></ul><blockquote><p>显示老年代GC情况</p></blockquote><ul><li>-gcolccapacity</li></ul><blockquote><p>显示内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</p></blockquote><ul><li>-gcpermcapacity</li></ul><blockquote><p>显示永久代使用到的最大、最小空间</p></blockquote><p>jstat还可以用来判断是否出现内存泄漏</p><p>1、在长时间运行的Java程序中，我们可以运行jstat命令连续获取多行性能数据，并取这几行数据中OU列（即已占用的老年代内存）的最小值</p><p>2、然后我们每隔一段较长的时间重复一次上述操作，来获得多组OU最小值。如果这些值呈上升趋势，则说明该Java程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏</p><h1 id="Jinfo"><a href="#Jinfo" class="headerlink" title="Jinfo"></a>Jinfo</h1><p>查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数</p><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>PID必须要加上</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>no optition</td><td>输出全部的参数和系统属性</td></tr><tr><td>-flag name</td><td>输出对应名称的参数</td></tr><tr><td>-flag [+-name]</td><td>开启或关闭对应名称的参数，只有被编辑为manageable的参数才可以被动态修改</td></tr><tr><td>-flag name=value</td><td>设定对应名称的参数</td></tr><tr><td>-flags</td><td>输出全部的参数</td></tr><tr><td>-sysprops</td><td>输出系统属性</td></tr></tbody></table><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>jinfo甚至可以在运行时修改部分参数，并使之立即生效</p><p>但是，并非所有参数都支持动态修改，参数只有标记为manageable的flag可以被实时修改，其实，这个修改能力都是及其有限的</p><p>可以查看被标记为manageable的参数</p><p><code>java -XX:+PrintFlagsFinal -version |grep manageable</code></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>java -XX:+PrintFlagInitial</code></p><p>查看所有JVM参数启动的初始值</p><p><code>java -XX:+PrintFlagsFinal</code></p><p>查看所有JVM参数的最终只</p><p><code>java -XX+PrintCommandLineFlags</code></p><p>查看那些已经被用户或者JVM设置过的详细的XX参数的名称和值</p><h1 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h1><p>​    作用一方面是获取dump文件（堆转储快照文件，二进制文件），它还可以获取目标java进程的内存相关信息，包括Java堆各区域的使用情况、堆中对象的统计信息、类加载信息等。</p><p>​    由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要借助安全点机制，让所有线程留在不改变堆中数据的状态。也就是说，由jmap导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。</p><p>​    另外，如果某个线程长时间无法跑到安全点，jmap将一直等下去，与jstat则不同，垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中，则jstat只需直接读取即可。</p><p><a href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html"> 官方文档</a></p><ul><li><code>-dump</code></li></ul><p>生成Java堆转储快照：dump文件</p><p>-<code>dumplive</code>: 只保存堆中的存活对象</p><p>导出内存映像文件</p><blockquote><p>手动的方式</p></blockquote><p><code>jmap -dump:format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;</code></p><p><code>jmap -dump:live,format=b,file=&lt;filename.hprof&gt;&lt;pid&gt;</code></p><p>format作用：使jmap生成文件与.hprof格式匹配起来</p><blockquote><p>自动的方式</p></blockquote><p><code>-XX:+HeapDumpOnOutOfMemoryError</code></p><p><code>-XX:+HeapDumpPath=&lt;filename.hprof&gt;</code></p><ul><li><code>-heap</code></li></ul><p>输出整个堆空间的详细信息，包括GC的使用、堆配置信息，以及内存的使用信息等</p><ul><li><code>-histo</code></li></ul><p>输出堆中对象的统计信息，包括类、实例数量的合计容量</p><p><code>-histo:live</code>: 只统计堆中的存活对象（注意，此命令慎重使用，会引发FullGc）</p><ul><li><code>-permstat</code></li></ul><p>以ClassLoader为统计口径输出永久代的内存状态信息</p><p>仅linux/solaris平台有效</p><ul><li><code>-finalizerinfo</code></li></ul><p>显示在F-Queue中等待Finailzer线程执行finalize方法的对象</p><p>仅linux/solaris平台有效</p><ul><li><code>-F</code></li></ul><p>当虚拟机进程对-dump选项没有任何响应时，可使用此选项强制执行生成dump文件</p><p>仅linux/solaris平台有效</p><ul><li><code>-J &lt;flag&gt;</code></li></ul><p>传递参数给jmap启动的jvm</p><h1 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h1><p>​    Sun JDK提供的jhat命令与jmap命令搭配使用，用于分析jmap生成的heap dump文件（堆转储快照）。hgat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，用户可以在浏览器中查看分析结果</p><p>​    使用了jhat命令，就启动了一个http服务器，端口是7000，则<a href="http://localhost:7000/">http://localhost:7000</a></p><p>​    注意：jhat命令在JDK9后，已经被删除</p><p>基本使用语法：</p><p><code>jhat [option] [dumpfile]</code></p><h1 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h1><p>​    用于生成虚拟机指定进程当前时刻的线程快照（虚拟机堆栈跟踪）。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合</p><p>​    </p><ul><li><code>-F</code></li></ul><p>当正常输出的请求不被响应时，强制输出线程堆栈</p><ul><li><code>-l</code></li></ul><p>除堆栈外，显示关于锁的附加信息</p><ul><li>-m</li></ul><p>如果调用到本地方法的话，可以显示C/C++的堆栈</p><p>在thread dump中，要留意下面几种状态</p><ul><li><p>死锁，Deadlock (重点关注)</p></li><li><p>等待资源，Waiting on condition (重点关注)</p></li><li><p>等待获取监视器，Waiting on monitor entry (重点关注)</p></li><li><p>阻塞，Blocked （重点关注）</p></li><li><p>执行中，Runnable</p></li><li><p>暂停，Suspended</p></li><li><p>对象等待中，Object.wait() 或 TIMED_WAITING</p></li><li><p>停止， Parked</p></li></ul><h1 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h1><p>在JDK 1.7以后，新增了一个命令行工具jcmd</p><p>它是一个多功能的工具，可以用来实现前面除了jstat之外的所有命令的功能 。比如：用它来导出堆、内存使用、查看Java进程、导出线程信息、执行GC、JVM运行时间等。</p><h1 id="相关jvm参数"><a href="#相关jvm参数" class="headerlink" title="相关jvm参数"></a>相关jvm参数</h1><ul><li><code>-verbose:gc</code></li></ul><p>输出gc日志信息，默认输出到标准输出</p><ul><li><code>-XX:+PrintGc</code></li></ul><p>等同于<code>-verbose:gc</code>，表示打开简化的GC日志</p><ul><li><code>-XX:+PrintGCDetails</code></li></ul><p>在发生垃圾回收时打印内存回收详细的日志</p><ul><li><code>-XX:+PrintGCDateStamps</code></li></ul><p>输出GC发生时的时间戳</p><ul><li>-XX:+PrintHeapAtGc</li></ul><p>每一个GC前和GC后，都打印堆信息</p><ul><li><code>-Xlogg&lt;file&gt;</code> </li></ul><p>把GC日志写入到一个文件中去，而不是打印到标准输出中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Jstat&quot;&gt;&lt;a href=&quot;#Jstat&quot; class=&quot;headerlink&quot; title=&quot;Jstat&quot;&gt;&lt;/a&gt;Jstat&lt;/h1&gt;&lt;h2 id=&quot;JIT相关&quot;&gt;&lt;a href=&quot;#JIT相关&quot; class=&quot;headerlink&quot; title=&quot;JIT</summary>
      
    
    
    
    <category term="JVM" scheme="https://c89757.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://c89757.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>线上cpu飙升排查</title>
    <link href="https://c89757.github.io/2023/08/09/%E7%BA%BF%E4%B8%8Acpu%E9%A3%99%E5%8D%87%E6%8E%92%E6%9F%A5/"/>
    <id>https://c89757.github.io/2023/08/09/%E7%BA%BF%E4%B8%8Acpu%E9%A3%99%E5%8D%87%E6%8E%92%E6%9F%A5/</id>
    <published>2023-08-09T14:58:45.000Z</published>
    <updated>2025-12-18T17:13:19.932Z</updated>
    
    <content type="html"><![CDATA[<p>1、找出服务运行的进程号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure><p>2、利用top命令查看对应进程下，各个线程占用情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -H -p &#123;pid&#125;</span><br></pre></td></tr></table></figure><p>3、找到占用最高的线程，拿到线程其线程号，将其转为十六进制（因为java里面记录的线程号都是十六进制）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &#x27;%x\n&#x27; &#123;tid&#125;</span><br></pre></td></tr></table></figure><p>4、利用<code>jstack</code>抓取线程快照</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack -l &#123;pid&#125; |grep ‘&#123;十六进制tid&#125;&#x27;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、找出服务运行的进程号&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c</summary>
      
    
    
    
    <category term="JVM" scheme="https://c89757.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://c89757.github.io/tags/JVM/"/>
    
    <category term="questions" scheme="https://c89757.github.io/tags/questions/"/>
    
  </entry>
  
  <entry>
    <title>阻塞队列</title>
    <link href="https://c89757.github.io/2023/03/09/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>https://c89757.github.io/2023/03/09/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2023-03-09T15:21:33.000Z</published>
    <updated>2023-03-09T16:28:23.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK里的阻塞队列"><a href="#JDK里的阻塞队列" class="headerlink" title="JDK里的阻塞队列"></a>JDK里的阻塞队列</h1><ul><li>ArrayBlockingQueue</li></ul><p>数组构成的有界阻塞队列</p><ul><li>LinkedBlockingQueue</li></ul><p>链表构成的无界阻塞队列</p><p>tips: 使用无界阻塞队列的put或offer方法时，永远不会阻塞， 因为队列不可能满</p><ul><li>PriorityBlockingQueue</li></ul><p>一个支持优先级排序的无界阻塞队列</p><ul><li>DelayQueue</li></ul><p>一个使用优先级队列实现的无界阻塞队列</p><ul><li>SynchronousQueue</li></ul><p>一个不存储元素的阻塞队列</p><ul><li>LinkedTransferQueue</li></ul><p>由链表组成的无界阻塞队列</p><ul><li>LinkedBlockingDeque</li></ul><p>由链表结构组成的双向阻塞队列</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDK里的阻塞队列&quot;&gt;&lt;a href=&quot;#JDK里的阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;JDK里的阻塞队列&quot;&gt;&lt;/a&gt;JDK里的阻塞队列&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;ArrayBlockingQueue&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数组构</summary>
      
    
    
    
    <category term="java" scheme="https://c89757.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://c89757.github.io/tags/java/"/>
    
  </entry>
  
</feed>
