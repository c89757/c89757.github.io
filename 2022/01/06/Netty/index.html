<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Netty | Colin</title>
  <meta name="description" content="BIO&amp;NIO&amp;AIOBIO        ​    blocking  I&#x2F;O , 即阻塞IO，同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）   先看单线程的版本   12345678910111213141516public s">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty">
<meta property="og:url" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="BIO&amp;NIO&amp;AIOBIO        ​    blocking  I&#x2F;O , 即阻塞IO，同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）   先看单线程的版本   12345678910111213141516public s">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/BIO%E6%A8%A1%E5%9E%8B.jpg">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211228135209446.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211228135657845.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211228135818793.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211228140749246.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211228140830135.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211228141003312.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211228141032475.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211228141938073.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211228142756229.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211228143047146.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211229140326931.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211229142929435.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211229145434837.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211229145749365.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211229150505122.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211229152042072.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211229154555019.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211229154651306.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211229155841635.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211229155400979.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211229162707964.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211230144907856.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20211230153144948.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20220106101739198.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20220106113434967.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20220112165624349.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20220112165808528.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20220112170251931.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20220112170736235.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20220120102408589.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20220112172945020.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20220117160915775.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20220120142215255.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20220124095737022.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20220126101511843.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20220126102424203.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20220209143331857.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/Netty%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.jpg">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20220303161701778.png">
<meta property="og:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/image-20220303161827343.png">
<meta property="article:published_time" content="2022-01-06T12:58:22.000Z">
<meta property="article:modified_time" content="2022-03-25T08:55:54.425Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="nio">
<meta property="article:tag" content="netty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://c89757.gitee.io/colinstar/2022/01/06/Netty/BIO%E6%A8%A1%E5%9E%8B.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="http://c89757.gitee.io/colinstar/2022/01/06/Netty/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/colinstar/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://gitee.com/c89757" target="_blank">
          <img class="img-circle img-rotate" src="/colinstar/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">colin</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">悟已往之不谏，知来者之可追</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Changsha, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/colinstar/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/colinstar/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/colinstar/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/colinstar/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/colinstar/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/colinstar/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/colinstar/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/colinstar/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/colinstar/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/colinstar/categories/JUC/">JUC</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/colinstar/categories/MySql/">MySql</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/colinstar/categories/Mysql/">Mysql</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/colinstar/categories/java/">java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/colinstar/categories/jvm/">jvm</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/colinstar/categories/mysql/">mysql</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/colinstar/categories/netty/">netty</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/colinstar/categories/others/">others</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/colinstar/categories/springboot/">springboot</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/colinstar/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/colinstar/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/GC/" rel="tag">GC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/JUC/" rel="tag">JUC</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/MySql/" rel="tag">MySql</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/Mysql/" rel="tag">Mysql</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/java/" rel="tag">java</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/jvm/" rel="tag">jvm</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/maven/" rel="tag">maven</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/mysql/" rel="tag">mysql</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/netty/" rel="tag">netty</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/nio/" rel="tag">nio</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/other/" rel="tag">other</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/others/" rel="tag">others</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/questions/" rel="tag">questions</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/spring/" rel="tag">spring</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/springboot/" rel="tag">springboot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/%E5%A0%86/" rel="tag">堆</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/colinstar/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">排序算法</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/colinstar/tags/GC/" style="font-size: 13px;">GC</a> <a href="/colinstar/tags/JUC/" style="font-size: 13.6px;">JUC</a> <a href="/colinstar/tags/MySql/" style="font-size: 13.8px;">MySql</a> <a href="/colinstar/tags/Mysql/" style="font-size: 13.2px;">Mysql</a> <a href="/colinstar/tags/java/" style="font-size: 13.2px;">java</a> <a href="/colinstar/tags/jvm/" style="font-size: 13.4px;">jvm</a> <a href="/colinstar/tags/maven/" style="font-size: 13px;">maven</a> <a href="/colinstar/tags/mysql/" style="font-size: 14px;">mysql</a> <a href="/colinstar/tags/netty/" style="font-size: 13px;">netty</a> <a href="/colinstar/tags/nio/" style="font-size: 13px;">nio</a> <a href="/colinstar/tags/other/" style="font-size: 13px;">other</a> <a href="/colinstar/tags/others/" style="font-size: 13px;">others</a> <a href="/colinstar/tags/questions/" style="font-size: 13.2px;">questions</a> <a href="/colinstar/tags/spring/" style="font-size: 13px;">spring</a> <a href="/colinstar/tags/springboot/" style="font-size: 13px;">springboot</a> <a href="/colinstar/tags/%E5%A0%86/" style="font-size: 13px;">堆</a> <a href="/colinstar/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 13.6px;">多线程</a> <a href="/colinstar/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 13px;">排序算法</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/colinstar/archives/2024/05/">五月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/colinstar/archives/2024/04/">四月 2024</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/colinstar/archives/2024/03/">三月 2024</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/colinstar/archives/2023/09/">九月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/colinstar/archives/2023/08/">八月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/colinstar/archives/2023/03/">三月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/colinstar/archives/2023/02/">二月 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/colinstar/archives/2023/01/">一月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/colinstar/archives/2022/12/">十二月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/colinstar/archives/2022/11/">十一月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/colinstar/archives/2022/06/">六月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/colinstar/archives/2022/03/">三月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/colinstar/archives/2022/01/">一月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/colinstar/archives/2021/12/">十二月 2021</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/colinstar/categories/%E7%BD%91%E7%BB%9C/">网络</a>
              </p>
              <p class="item-title">
                <a href="/colinstar/2024/05/11/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90/" class="title">科学上网-自建梯子</a>
              </p>
              <p class="item-date">
                <time datetime="2024-05-11T12:12:58.000Z" itemprop="datePublished">2024-05-11</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/colinstar/categories/MySql/">MySql</a>
              </p>
              <p class="item-title">
                <a href="/colinstar/2024/04/24/InnoDB-FullTextIndex/" class="title">InnoDB-FullTextIndex</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-24T11:24:50.000Z" itemprop="datePublished">2024-04-24</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/colinstar/categories/mysql/">mysql</a>
              </p>
              <p class="item-title">
                <a href="/colinstar/2024/04/23/XA%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/" class="title">XA事务与两阶段提交</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-22T16:15:30.000Z" itemprop="datePublished">2024-04-23</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/colinstar/categories/MySql/">MySql</a>
              </p>
              <p class="item-title">
                <a href="/colinstar/2024/04/21/MySql%E7%9A%84%E9%94%81/" class="title">MySql的锁</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-21T07:23:11.000Z" itemprop="datePublished">2024-04-21</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/colinstar/categories/MySql/">MySql</a>
              </p>
              <p class="item-title">
                <a href="/colinstar/2024/04/17/MySql%E5%A2%9E%E5%8A%A0varchar%E9%95%BF%E5%BA%A6/" class="title">MySql增加varchar长度</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-17T11:29:10.000Z" itemprop="datePublished">2024-04-17</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#BIO-amp-NIO-amp-AIO"><span class="toc-number">1.</span> <span class="toc-text">BIO&amp;NIO&amp;AIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BIO"><span class="toc-number">1.1.</span> <span class="toc-text">BIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.1.1.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">存在的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO"><span class="toc-number">1.2.</span> <span class="toc-text">NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83API"><span class="toc-number">1.2.1.</span> <span class="toc-text">几个核心API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector-open"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Selector.open();</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#serverSocketChannel-register-%E2%80%A6"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">serverSocketChannel.register(…)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#selector-select"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">selector.select();</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AIO%EF%BC%88NIO-2-0%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">AIO（NIO 2.0）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Netty"><span class="toc-number">2.</span> <span class="toc-text">Netty</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Rector%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">Rector响应式编程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Demo"><span class="toc-number">2.2.</span> <span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">Netty模块组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">2.4.</span> <span class="toc-text">Netty架构图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ByteBuf"><span class="toc-number">2.5.</span> <span class="toc-text">ByteBuf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty%E7%BC%96%E8%A7%A3%E7%A0%81"><span class="toc-number">2.6.</span> <span class="toc-text">Netty编解码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85"><span class="toc-number">2.7.</span> <span class="toc-text">Netty粘包拆包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">2.8.</span> <span class="toc-text">Netty心跳检测机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">2.9.</span> <span class="toc-text">源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NioEventLoopGroup"><span class="toc-number">2.9.1.</span> <span class="toc-text">NioEventLoopGroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ServerBootstrap"><span class="toc-number">2.9.2.</span> <span class="toc-text">ServerBootstrap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#group-bossGroup-workerGroup"><span class="toc-number">2.9.2.1.</span> <span class="toc-text">group(bossGroup,workerGroup)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#channel-NioServerSocketChannel-class"><span class="toc-number">2.9.2.2.</span> <span class="toc-text">channel(NioServerSocketChannel.class)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#option-ChannelOption-SO-BACKLOG-1024"><span class="toc-number">2.9.2.3.</span> <span class="toc-text">option(ChannelOption.SO_BACKLOG,1024)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#childHandler-new-ChannelInitializer-%E2%80%A6"><span class="toc-number">2.9.2.4.</span> <span class="toc-text">childHandler(new ChannelInitializer() {…}</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bind"><span class="toc-number">2.9.2.5.</span> <span class="toc-text">bind</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#this-initAndRegister-%E6%96%B9%E6%B3%95"><span class="toc-number">2.9.2.5.1.</span> <span class="toc-text">this.initAndRegister()方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#NioServerSocketChannel%E7%9A%84%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%EF%BC%9A"><span class="toc-number">2.9.2.5.1.1.</span> <span class="toc-text">NioServerSocketChannel的无参构造：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#this-init-channel"><span class="toc-number">2.9.2.5.1.2.</span> <span class="toc-text">this.init(channel);</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#this-config-group-register-channel"><span class="toc-number">2.9.2.5.1.3.</span> <span class="toc-text">this.config().group().register(channel);</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">2.10.</span> <span class="toc-text">流程图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A0%E9%94%81%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">无锁串行化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%88%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">零拷贝（直接内存的使用）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%81%B5%E6%B4%BB%E7%9A%84TCP%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%83%BD%E5%8A%9B"><span class="toc-number">5.</span> <span class="toc-text">灵活的TCP参数配置能力</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ByteBuf%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">ByteBuf扩容机制</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Netty" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Netty
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/colinstar/2022/01/06/Netty/" class="article-date">
	  <time datetime="2022-01-06T12:58:22.000Z" itemprop="datePublished">2022-01-06</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/colinstar/categories/netty/">netty</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/colinstar/tags/netty/" rel="tag">netty</a>, <a class="article-tag-link-link" href="/colinstar/tags/nio/" rel="tag">nio</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/colinstar/2022/01/06/Netty/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="BIO-amp-NIO-amp-AIO"><a href="#BIO-amp-NIO-amp-AIO" class="headerlink" title="BIO&amp;NIO&amp;AIO"></a>BIO&amp;NIO&amp;AIO</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><br>

<img src="/colinstar/2022/01/06/Netty/BIO%E6%A8%A1%E5%9E%8B.jpg" class>

<br>

<br>

<p>​    blocking  I/O , 即阻塞IO，同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）</p>
<br>

<p>先看单线程的版本</p>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9000</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            log.info(<span class="string">&quot;建立连接&quot;</span>);</span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">            <span class="keyword">if</span> (read != -<span class="number">1</span>)&#123;</span><br><span class="line">                log.info(<span class="string">&quot;收到消息：&#123;&#125;&quot;</span>,<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read));</span><br><span class="line">            &#125;</span><br><span class="line">            socket.getOutputStream().write(<span class="string">&quot;已成功接收到消息&quot;</span>.getBytes());</span><br><span class="line">            socket.getOutputStream().flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<br>

<p>Debug启动程序，在serverSocket.accept()处打上断点，同时再下一行处也打上断点，然后我们点击idea调试的Resume Program按钮，让程序直接走完；我们会发现断点没有到达下一行，程序也没有停止，而是阻塞在了accept()里。</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211228135209446.png" class>

<br>

<br>

<p>我们试着用telnet工具去连接程序</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211228135657845.png" class>

<br>

<br>

<p>按下回车连接的同时，我们也会发现程序的断点跑到了下一行</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211228135818793.png" class>

<br>

<br>

<p>我们再在 int read = inputStream.read(bytes);这一行及其下一行也打上断点；</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211228140749246.png" class>

<br>

<br>

<p>程序来到inputStream.read(bytes)这一行，我们再次选择放掉这一个断点，发现此处程序也并没有来到下一行，也是在此处进行了阻塞</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211228140830135.png" class>

<br>

<br>

<p>我们用telnet工具给服务端发送消息</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211228141003312.png" class>



<br>

<br>

<p>回到程序，发现程序执行到了下一行</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211228141032475.png" class>



<br>

<br>

<p>接下来我们重新开始，重新启动服务端，开启一个telnet（客户端1）去连接，但是不发送消息，让程序阻塞在int read = inputStream.read(bytes)这一行；与此同时，我们再另外开启一个telnet客户端（客户端2）去进行连接，然后发送消息给服务端</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211228141938073.png" class>



<br>

<br>

<p>但是我们发现，控制台并没有任何消息打印；</p>
<p>我们此时在用客户端1去发送消息</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211228142756229.png" class>



<br>

<br>

<p>发现客户端打印消息，但是打印hello2之前，输出了”建立连接“；说明此时我们其实客户端2并没有真正的连接上，而是阻塞在了serverSocket.accept()处</p>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">log.info(<span class="string">&quot;建立连接&quot;</span>);</span><br></pre></td></tr></table></figure>

<br>

<img src="/colinstar/2022/01/06/Netty/image-20211228143047146.png" class>



<br>

<br>

<blockquote>
<p><strong>在同一时刻，服务端只能响应一个客户端</strong></p>
</blockquote>
<br>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我们可以在将代码改成多线程版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBIO</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestBIO</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">        log.info(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9000</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            log.info(<span class="string">&quot;建立连接&quot;</span>);</span><br><span class="line">            threadPoolExecutor.execute(<span class="keyword">new</span> TestBIO(socket));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>)&#123; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">        <span class="keyword">if</span> (read != -<span class="number">1</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;收到消息：&#123;&#125;&quot;</span>,<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read));</span><br><span class="line">        &#125;</span><br><span class="line">        socket.getOutputStream().write(<span class="string">&quot;已成功接收到消息&quot;</span>.getBytes());</span><br><span class="line">        socket.getOutputStream().flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler(<span class="keyword">this</span>.socket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>我们再实验以上步骤</p>
<p>先开启telnet客户端1去连接阻塞，但是不发送消息</p>
<p>再开启telnet客户端2去连接，并发送消息</p>
<p>结果此次控制台能正确接收到消息</p>
<br>

<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a><strong>存在的问题</strong></h3><p>​    如果开辟大量线程，比较消耗资源，且如果我们用了线程池，如果我们线程池数量是500，某一瞬间并发量有1w，那后面的请求就只能阻塞等待。又或者500线程池，其中400个线程只是和你建立连接，并不立马发送消息给服务端，那这个线程会一直被这个连接给占用，其他人无法获取; 又或者用完线程给别人用时，线程的切换也是比较消耗资源的</p>
<ul>
<li>IO代码里read操作是阻塞操作，如果连接不做数据读写会导致线程阻塞，浪费资源</li>
<li>如果线程很多，会导致服务器线程太大，压力太大</li>
</ul>
<p>应用场景：BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高</p>
<br>

<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>​    Non Blocking IO,或者读为New IO,同步非阻塞，服务器实现模式为<strong>一个线程可以处理多个请求（连接）</strong>，客户端发送的连接请求都会注册到<strong>多路复用器selector</strong>上，多路复用器轮询到连接有IO请求就进行处理，JDK1.4开始引入</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211229140326931.png" class>

<br>

<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNIO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;SocketChannel&gt; channelList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>));</span><br><span class="line">        <span class="comment">// 设置ServerSocketChannel为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 非阻塞模式accept方法不会阻塞，否则会阻塞</span></span><br><span class="line">            <span class="comment">// NIO的非阻塞是由操作系统内部实现的，底层调用了linux内核的accept函数</span></span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123; <span class="comment">// 如果有客户端进行连接</span></span><br><span class="line">                log.info(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">                <span class="comment">// 设置SocketChannel为非阻塞</span></span><br><span class="line">                socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 保存客户端连接在list中</span></span><br><span class="line">                channelList.add(socketChannel);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历连接进行数据读取</span></span><br><span class="line">            Iterator&lt;SocketChannel&gt; iterator = channelList.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SocketChannel next = iterator.next();</span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                <span class="comment">// 非阻塞模式read方法不会阻塞</span></span><br><span class="line">                <span class="keyword">int</span> len = next.read(byteBuffer);</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;接收到消息: &#123;&#125;&quot;</span>, <span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123; <span class="comment">// 如果客户端断开，把socket从集合中删调</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    log.info(<span class="string">&quot;与客户端断开连接&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>我们先后开启两个telnet客户端去连接服务端，发送消息，服务端都能接收到;</p>
<p>会一直循环去判断是否有新的连接请求，是否有连接发送消息</p>
<br>

<p><strong>上述代码存在的问题：</strong></p>
<p>如果连接数太多的话，会有大量的无效遍历</p>
<p>比如如果我现在有10万个连接，但是经常给服务端发消息的就那个几百个，但是每次都要去遍历所有的连接</p>
<br>

<p>我们可以将那些有数据交互的连接，存储在另外一个数据结构中，每次遍历只需要遍历那些有数据交互的连接</p>
<br>

<p>NIO引入多路复用器代码示例：</p>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioSelectorServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>));</span><br><span class="line">        <span class="comment">// 设置ServerSocketChannel为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 打开selector处理Channel，即创建epoll</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 把ServerSocketChannel注册到selector上，并且selector监听客户端accept连接事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞等待需要处理的事件发生</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">// 获取selector中注册的全部事件的SelectionKey实例</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="comment">// 遍历SelectionKey对事件进行处理</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="comment">// 如果是OP_ACCEPT事件，则进行连接获取和事件注册</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    ServerSocketChannel channel =(ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="keyword">final</span> SocketChannel socketChannel = channel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 这里只注册了读事件，如果需要给客户端发送数据可以注册写事件</span></span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                    log.info(<span class="string">&quot;客户端连接成功&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123; <span class="comment">// 如果是OP_READ事件，则进行读取和打印</span></span><br><span class="line">                    SocketChannel channel =(SocketChannel)key.channel();</span><br><span class="line">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">int</span> len = channel.read(byteBuffer);</span><br><span class="line">                    <span class="keyword">if</span> (len &gt;<span class="number">0</span> )&#123;</span><br><span class="line">                        log.info(<span class="string">&quot;接收到消息:&#123;&#125;&quot;</span>,<span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == -<span class="number">1</span>)&#123;</span><br><span class="line">                        log.info(<span class="string">&quot;客户端断开连接&quot;</span>);</span><br><span class="line">                        channel.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从事件集合里删除本次处理的key,防止下次select重复处理</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>NIO有三大核心组件：<strong>Channel(通道)，Buffer(缓冲区)，Selector(多路复用器)</strong></p>
<p>1、channel类似于流，每个channel对应一个buffer缓冲区，buffer底层就是个数组</p>
<p>2、channel会注册到selector上，由selector根据channel独写事件的发生将其交由某个空闲的线程处理</p>
<p>3、NIO的Buffer和channe都是既可以读也可以写</p>
<br>

<p>先看一幅图</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211229142929435.png" class>

<br>

<br>

<p>​    我们代码最开始处，创建了一个ServerSocketChannel，并绑定9000端口,并将ServerSocketChannel注册到selector上，并且selector监听客户端accept连接事件，注册上后会返回一个key,通过这个selectionKey可以找到与之绑定的ServerSocketChannel;</p>
<br>

<p>​    我们在selector.select()处及其下一行打上断点，启动项目。</p>
<img src="/colinstar/2022/01/06/Netty/image-20211229145434837.png" class>

<br>

<br>

<p>​    放掉断点让其走完，发现程序阻塞在了这一行；</p>
<p>​    同样的，打开cmd，用telnet连接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 9000</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>​    连接上后，发现程序走到了下一行</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211229145749365.png" class>

<br>

<br>

<p>​    继续往下走一行，获取到所有的selectionKey; 因为此时我们只有一个客户端进行连接，所以此处size是1</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211229150505122.png" class>

<br>

<br>

<p>​    很显然我们此处是OP_ACCEPT事件</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211229152042072.png" class>

<br>

<br>

<p>​    通过selectionKey可以拿到与之绑定的ServerSocketChannel，并让其与客户端建立连接,并把客户端对应的socketChannel也注册到selector上，并让其监听读事件（读是相当于服务端来的，也就是监听客户端发送过来的消息）</p>
<p>​    我们一步一步调试，让程序走完，因为是死循环，在select处又会进行阻塞，因为此时既没有新的客户端连接进来，刚刚连接上的客户端也没有发送消息。</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211229154555019.png" class>

<br>

<br>

<p>​    我们用telnet再给服务端发送一条消息</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211229154651306.png" class>

<br>

<br>

<p>​    此时，程序停止了阻塞，走到了下一行</p>
<p>​    一步一步调试，很显然这次我们是OP_READ事件，通过key拿到与客户端对应的SocketChannel。也就是下图标识出来的部分，用它来读取客户端的数据</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211229155841635.png" class>

<br>

<br>

<img src="/colinstar/2022/01/06/Netty/image-20211229155400979.png" class>

<br>

<br>

<p>​    我们现在再另外开启一个telnet客户端，连接服务端</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211229162707964.png" class>

<br>

<br>

<p>​    我们可以看到，现在有两个客户端，但是拿到的selectionKey只有一个，只针对那些发生的事件进行处理</p>
<br>

<p>​    NIO底层在JDK1.4版本是用linux的内核函数select()或poll()来实现，跟上面最开始的代码类似，selector每次都会轮询所有的socketChannel看下哪个channel有读写事件，有的话就处理，没有就继续遍历，JDK1.5引入了epoll基于事件响应机制来优化NIO</p>
<br>

<br>

<h3 id="几个核心API"><a href="#几个核心API" class="headerlink" title="几个核心API"></a><strong>几个核心API</strong></h3><h4 id="Selector-open"><a href="#Selector-open" class="headerlink" title="Selector.open();"></a>Selector.open();</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>provider()方法里最终调用了下面的create()方法，发现其new 了一个WindowsSelectorProvider()。因为我们日常使用的是windows的jdk</li>
</ul>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openSelector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSelectorProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultSelectorProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowsSelectorProvider();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>下载openJdk8u的源码，搜索DefaultSelectorProvider这个类，发现有三个，分别对应unix系统，mac系统，windows系统。我们接下来看unix系统对应的源码</li>
</ul>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211230144907856.png" class>

<br>

<br>

<ul>
<li>unix系统create()方法的源码如下，发现和windows的有区别，如果是linux系统，会返回EPollSelectorProvider这个类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String osname = AccessController</span><br><span class="line">        .doPrivileged(<span class="keyword">new</span> GetPropertyAction(<span class="string">&quot;os.name&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (osname.equals(<span class="string">&quot;SunOS&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> createProvider(<span class="string">&quot;sun.nio.ch.DevPollSelectorProvider&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (osname.equals(<span class="string">&quot;Linux&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> createProvider(<span class="string">&quot;sun.nio.ch.EPollSelectorProvider&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> sun.nio.ch.PollSelectorProvider();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>open()方法里会调用openSelector()这个方法，<code>EPollSelectorProvider</code>里的实现如下，直接new 了一个EPollSelectorImpl</li>
</ul>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EPollSelectorProvider</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">SelectorProviderImpl</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractSelector <span class="title">openSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EPollSelectorImpl(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Channel <span class="title">inheritedChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InheritedChannel.getChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br>

<ul>
<li>接着我们去看看<code>EpollSelectorImpl</code>这个类的构造函数，初始化的时候， <code>new EPollArrayWrapper()</code>创建了一个EPollArrayWrapper对象</li>
</ul>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EPollSelectorImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    <span class="keyword">long</span> pipeFds = IOUtil.makePipe(<span class="keyword">false</span>);</span><br><span class="line">    fd0 = (<span class="keyword">int</span>) (pipeFds &gt;&gt;&gt; <span class="number">32</span>);</span><br><span class="line">    fd1 = (<span class="keyword">int</span>) pipeFds;</span><br><span class="line">    pollWrapper = <span class="keyword">new</span> EPollArrayWrapper();</span><br><span class="line">    pollWrapper.initInterrupt(fd0, fd1);</span><br><span class="line">    fdToKey = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>紧接着我们看到<code>EPollArrayWrapper</code>的构造函数，里面调用了一个epollCreate（）方法</li>
</ul>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EPollArrayWrapper() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// creates the epoll file descriptor</span></span><br><span class="line">    epfd = epollCreate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the epoll_event array passed to epoll_wait</span></span><br><span class="line">    <span class="keyword">int</span> allocationSize = NUM_EPOLLEVENTS * SIZE_EPOLLEVENT;</span><br><span class="line">    pollArray = <span class="keyword">new</span> AllocatedNativeObject(allocationSize, <span class="keyword">true</span>);</span><br><span class="line">    pollArrayAddress = pollArray.address();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// eventHigh needed when using file descriptors &gt; 64k</span></span><br><span class="line">    <span class="keyword">if</span> (OPEN_MAX &gt; MAX_UPDATE_ARRAY_SIZE)</span><br><span class="line">        eventsHigh = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>​    epollCreate是一个本地方法 （java的native方法是通过JNI，即java native interface来实现的，可以通过它来实现java与其他语言之间的交互）</p>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">epollCreate</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>EPollArrayWrapper.c里找到这个epollCreate方法, epoll_create是linux的一个系统函数</li>
</ul>
<br>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jint JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_sun_nio_ch_EPollArrayWrapper_epollCreate</span><span class="params">(JNIEnv *env, jobject <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * epoll_create expects a size as a hint to the kernel about how to</span></span><br><span class="line"><span class="comment">     * dimension internal structures. We can&#x27;t predict the size in advance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">if</span> (epfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       JNU_ThrowIOExceptionWithLastError(env, <span class="string">&quot;epoll_create failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> epfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li><p>我们在linux系统上执行 <code>man epoll_create</code>命令，查看这个函数的文档</p>
<p>-打开一个文件描述符，相当于创建了一个epoll对象，返回文件描述符的索引 int epfd = epoll_create(256)</p>
</li>
</ul>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20211230153144948.png" class>

<br>

<br>

<h4 id="serverSocketChannel-register-…"><a href="#serverSocketChannel-register-…" class="headerlink" title="serverSocketChannel.register(…)"></a>serverSocketChannel.register(…)</h4><br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>java.nio.channels.SelectableChannel#register(java.nio.channels.Selector, int)</li>
</ul>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ClosedChannelException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(sel, ops, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>java.nio.channels.spi.AbstractSelectableChannel#register</li>
</ul>
<p>这个方法里面最终又调用了一个register方法，我们再点进去</p>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   Object att)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ClosedChannelException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">        .....</span><br><span class="line">            <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">                k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att); <span class="comment">// 主要看这个register方法</span></span><br><span class="line">                addKey(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li><p>sun.nio.ch.SelectorImpl#register</p>
<p>这个里面又调用了一个implRegister（）方法，我们点进去是个抽象方法</p>
<p><code>protected abstract void implRegister(SelectionKeyImpl var1);</code></p>
<p>查看他的实现类，来到了WindowsSelectorImpl，这是windows系统的实现，我们去查看linux的implRegister的实现方法</p>
</li>
</ul>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(AbstractSelectableChannel var1, <span class="keyword">int</span> var2, Object var3)</span> </span>&#123;</span><br><span class="line">  	 ....</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.publicKeys) &#123;</span><br><span class="line">            <span class="keyword">this</span>.implRegister(var4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>sun.nio.ch.EPollSelectorImpl#implRegister</li>
</ul>
<p> <code>pollWrapper.add(fd);</code> fd是文件描述符，会根据这个索引找到这个文件（linux一切皆文件），在此处就是linux系统能够根据pd这个文件描述符找到这个创建好的serverSocketChannel；</p>
<p>这个pollWrapper就是上面Selector.open()里创建的pollWrapper</p>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implRegister</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">    SelChImpl ch = ski.channel;</span><br><span class="line">    <span class="keyword">int</span> fd = Integer.valueOf(ch.getFDVal());</span><br><span class="line">    fdToKey.put(fd, ski);</span><br><span class="line">    pollWrapper.add(fd);</span><br><span class="line">    keys.add(ski);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="selector-select"><a href="#selector-select" class="headerlink" title="selector.select();"></a>selector.select();</h4><br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line"> ....</span><br><span class="line">selector.select();</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>select是一个抽象方法</li>
</ul>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<br>

<p>点进实现类</p>
<ul>
<li>sun.nio.ch.SelectorImpl#select()</li>
</ul>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.select(<span class="number">0L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>lockAndDoSelect</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (var1 &lt; <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Negative timeout&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lockAndDoSelect(var1 == <span class="number">0L</span> ? -<span class="number">1L</span> : var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>sun.nio.ch.SelectorImpl#lockAndDoSelect</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lockAndDoSelect</span><span class="params">(<span class="keyword">long</span> var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   		  ......</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.publicKeys) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="keyword">this</span>.publicSelectedKeys) &#123;</span><br><span class="line">                    var10000 = <span class="keyword">this</span>.doSelect(var1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>doSelect是一个抽象方法，点进实现类来到了WindowsSelectorImpl。同样的，我们需要看linux的实现<code>EPollSelectorImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>sun.nio.ch.EPollSelectorImpl#doSelect</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   .......</span><br><span class="line">        pollWrapper.poll(timeout);</span><br><span class="line">   .......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numKeysUpdated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>sun.nio.ch.EPollArrayWrapper#poll</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    updateRegistrations();</span><br><span class="line">    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;updated; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getDescriptor(i) == incomingInterruptFD) &#123;</span><br><span class="line">            interruptedIndex = i;</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> updated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>先看updateRegistrations（）方法</p>
<br>

<ol>
<li>updateRegistrations();</li>
</ol>
<p>此方法里又调用了一个<code>epollCtl(epfd, opcode, fd, events)</code> ，点进去，这是一个本地方法</p>
<p><code>private native void epollCtl(int epfd, int opcode, int fd, int events);</code></p>
<p>内部调用的就是linux函数epoll_ctl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRegistrations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (updateLock) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; updateCount) &#123;</span><br><span class="line">                <span class="keyword">int</span> fd = updateDescriptors[j];</span><br><span class="line">                <span class="keyword">short</span> events = getUpdateEvents(fd);</span><br><span class="line">                <span class="keyword">boolean</span> isRegistered = registered.get(fd);</span><br><span class="line">                <span class="keyword">int</span> opcode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (events != KILLED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isRegistered) &#123;</span><br><span class="line">                        opcode = (events != <span class="number">0</span>) ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        opcode = (events != <span class="number">0</span>) ? EPOLL_CTL_ADD : <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (opcode != <span class="number">0</span>) &#123;</span><br><span class="line">                        epollCtl(epfd, opcode, fd, events);</span><br><span class="line">                        <span class="keyword">if</span> (opcode == EPOLL_CTL_ADD) &#123;</span><br><span class="line">                            registered.set(fd);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == EPOLL_CTL_DEL) &#123;</span><br><span class="line">                            registered.clear(fd);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            updateCount = <span class="number">0</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>在linux系统上执行命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man epoll_ctl</span><br></pre></td></tr></table></figure>

<br>

<p> 查看此函数</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20220106101739198.png" class>

<br>

<br>

<p><code>epollCtl(epfd, opcode, fd, events);</code></p>
<p>epfd epoll实例对应的文件描述符</p>
<p>fd  socketChannel对应的文件描述符<br>events 事件</p>
<p>参数opcode又以下几个值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EPOLL_CTL_ADD // 注册新的SocketChannel到epoll实例中，并关联事件event</span><br><span class="line">EPOLL_CTL_DEL // 修改已经注册的SocketChannel的监听事件</span><br><span class="line">EPOLL_CTL_MOD // 从epoll中移除SocketChannel，并且忽略掉绑定的event</span><br></pre></td></tr></table></figure>

<p>epollCtl这个方法把SocketChannel和epoll关联起来</p>
<br>

<p>2.updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);</p>
<p>再回到poll方法里，程序继续往下走，接着看epollWait这个方法，点进去也是一个本地方法，也是调用的操作系统内核函数</p>
<p>epoll_wait</p>
<blockquote>
<p>epoll_wait, epoll_pwait - wait for an I/O event on an epoll file descriptor</p>
</blockquote>
<br>

<p>epoll_wait的时候，会去查看sector里面的rdlist就绪列表里是否有数据，有数据就跳出阻塞，没有就阻塞住</p>
<br>



<p>利用操作系统回调函数，客户端有响应，把事件放进rdlist</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20220106113434967.png" class>

<br>

<br>

<h2 id="AIO（NIO-2-0）"><a href="#AIO（NIO-2-0）" class="headerlink" title="AIO（NIO 2.0）"></a>AIO（NIO 2.0）</h2><br>    

<p>​    异步非阻塞，由操作系统完成后回调通知服务端程序启动线程去处理，一般适用于连接数较多并且连接时间较长的应用</p>
<br>

<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAIO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        AsynchronousServerSocketChannel serverSocketChannel = AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>));</span><br><span class="line">        serverSocketChannel.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel socketChannel, Object attachment)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2----&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="comment">// 再此接收客户端连接,如果不写这行代码后面的客户端连接不上服务端</span></span><br><span class="line">                    serverSocketChannel.accept(attachment, <span class="keyword">this</span>);</span><br><span class="line">                    System.out.println(socketChannel.getRemoteAddress());</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    socketChannel.read(buffer, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;3---&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, result));</span><br><span class="line">                            socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;HelloClient&quot;</span>.getBytes()));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                            exc.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;1---&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br>

<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="Rector响应式编程模型"><a href="#Rector响应式编程模型" class="headerlink" title="Rector响应式编程模型"></a>Rector响应式编程模型</h2><br>

<img src="/colinstar/2022/01/06/Netty/image-20220112165624349.png" class>

<br>

<br>

<p>所谓响应式，类似于GUI编程中，给一个Button绑定一个或多个事件，对于点击事件，点击后会触发对应方法</p>
<ul>
<li>基础的Reactor设计，单线程版本; 用一个Reactor去处理客户端的连接，以及读写</li>
</ul>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20220112165808528.png" class>

<br>

<br>

<p>存在的问题：类比上面的NioSelectorServer类代码。selector.select()处会阻塞，同一时间如果有大量的读写事件发生，那么循环处理的时候，会耗费大量时间，而此时新进来的连接就会阻塞在selector.select()处。</p>
<ul>
<li>我们可以引入线程池，将读写工作交给其他线程去处理</li>
</ul>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20220112170251931.png" class>

<br>

<br>

<p>存在的问题：还是类比上面的NioSelectorServer类的代码；我们现在while (iterator.hasNext()) {….}循环去处理的时候，引入线程池，将读写事件交给线程池去处理；这样分发完后，主线程能很快的回到selector.select()处，阻塞监听新的事件。但是如果一时间的事件很多，那么分发都需要花费大量的时间，同样新进来的事件也得不到处理</p>
<ul>
<li>引入两个Reactor，一个mainReactor专门用来处理连接事件。subReactor用来处理独写事件，并且把这些读写事件分发给线程池去完成</li>
</ul>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20220112170736235.png" class>

<br>

<br>



<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><ul>
<li>NettyServer.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个线程组boss和worker;含有的子线程NioEventLoop的个数默认为cpu核数的两倍</span></span><br><span class="line">        <span class="comment">// boss组只是处理连接请求，真正的和客户端业务处理，会交给worker</span></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>); <span class="comment">// 相当于主Reactor</span></span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>); <span class="comment">// 相当于从Reactor</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 创建服务端的启动对象</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">// 使用链式编程来配置参数</span></span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup) <span class="comment">// 设置两个线程组</span></span><br><span class="line">                    <span class="comment">// 使用NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// 初始化服务器连接队列大小，服务端处理客户端连接请求是顺序处理的，所以同一时间处理一个客户端</span></span><br><span class="line">                    <span class="comment">// 多个客户端同时来连接的时候，服务端将不能处理的客户端连接请求放在队列中等待处理</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">1024</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            log.info(<span class="string">&quot;------netty server start...------&quot;</span>);</span><br><span class="line">            <span class="comment">// 绑定一个端口并且同步，生成了一个ChannelFuture异步对象，通过isDone()等方法可以判断异步事件的执行情况</span></span><br><span class="line">            <span class="comment">// 启动服务器(并绑定端口),bind是异步操作，sync方法是等待异步操作执行完毕</span></span><br><span class="line">            ChannelFuture sync = serverBootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line">            <span class="comment">// 等待服务端监听端口关闭，closeFuture是异步操作</span></span><br><span class="line">            <span class="comment">// 通过sync方法同步等待通道关闭处理完毕，这里会阻塞等待通道关闭，内部调用的是object.wait()方法</span></span><br><span class="line">            sync.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>NettyServerHandler.Java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端发送的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        System.out.println(in.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据读取完毕处理方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;[来自服务端]:congratulations~连接成功&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> ByteBuf byteBuf = Unpooled.copiedBuffer(msg.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">        ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123; <span class="comment">// (4)</span></span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>NettyClient.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端需要一个事件循环组</span></span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建客户端启动对象</span></span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap(); <span class="comment">// (1)</span></span><br><span class="line">            b.group(group); <span class="comment">// (2)</span></span><br><span class="line">            b.channel(NioSocketChannel.class); <span class="comment">// (3)</span></span><br><span class="line">            b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// (4)</span></span><br><span class="line">            b.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> NettyClientChannel());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;netty client start....&quot;</span>);</span><br><span class="line">            <span class="comment">// Start the client.</span></span><br><span class="line">            ChannelFuture f = b.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>).sync(); <span class="comment">// (5)</span></span><br><span class="line">            <span class="comment">// Wait until the connection is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>NettyClientChannel.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientChannel</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取事件时，也就是服务端发送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf m = (ByteBuf) msg; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(m.toString(CharsetUtil.UTF_8));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            m.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端连接服务器完成就会触发该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ChannelFuture f = ctx.writeAndFlush(Unpooled.copiedBuffer((<span class="string">&quot;[来自客户端]:hello server&quot;</span> ).getBytes(CharsetUtil.UTF_8))); <span class="comment">// (3)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="Netty模块组件"><a href="#Netty模块组件" class="headerlink" title="Netty模块组件"></a>Netty模块组件</h2><br>

<p>下面部分摘抄自官方文档<a target="_blank" rel="noopener" href="https://netty.io/wiki/user-guide-for-4.x.html#wiki-h3-9">https://netty.io/wiki/user-guide-for-4.x.html#wiki-h3-9</a></p>
<p>1、<a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/channel/nio/NioEventLoopGroup.html"><code>NioEventLoopGroup</code></a>是一个处理 I/O 操作的多线程事件循环，Netty提供各种NioEventLoopGroup为不同类型的传输提供了各种实现；实现一个服务器端应用程序，因此<a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/channel/nio/NioEventLoopGroup.html"><code>NioEventLoopGroup</code></a>将使用两个。第一个，通常称为“boss”，接受传入连接。第二个，通常称为“worker”，一旦boss接受连接并将接受的连接注册到worker;有多少线程使用和它们是如何映射到创建渠道取决于EventLoopGroup通过构造函数实现,甚至可能是可配置的</p>
<p>2、<a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/bootstrap/ServerBootstrap.html"><code>ServerBootstrap</code></a> is a helper class that sets up a server；ServerBootstrap是一个设置服务器的辅助类。</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/bootstrap/Bootstrap.html"><code>Bootstrap</code></a>与<a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/bootstrap/ServerBootstrap.html"><code>ServerBootstrap</code></a>类似，除了它是非服务端通道，如客户端或无连接通道。</li>
<li>如果您只指定一个<a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/channel/EventLoopGroup.html"><code>EventLoopGroup</code></a>，它将同时用作boss组和worker组。但是，boss组不用于客户端。</li>
<li><a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/channel/socket/nio/NioSocketChannel.html"><code>NioSocketChannel</code></a>被用来创建客户端<a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/channel/Channel.html"><code>Channel</code></a>，而不是<a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/channel/socket/nio/NioServerSocketChannel.html"><code>NioServerSocketChannel</code></a>；</li>
<li>注意我们不像ServerBootstrap处，使用childOption(),因为客户端SocketChannel没有父级</li>
<li>我们应该调用<code>connect()</code>方法而不是<code>bind()</code>方法。</li>
</ol>
</blockquote>
<p>3、 Netty 抽象出两组线程池BossGroup和WorkerGroup，BossGroup专门负责接收客户端的连接, WorkerGroup专 门负责网络的</p>
<p>4 、BossGroup和WorkerGroup类型都是NioEventLoopGroup </p>
<p>5、NioEventLoopGroup 相当于一个事件循环线程组, 这个组中含有多个事件循环线程 ， 每一个事件循环线程是 NioEventLoop</p>
<p>6、每个NioEventLoop都有一个selector , 用于监听注册在其上的socketChannel的网络通讯 </p>
<p>7、每个Boss NioEventLoop线程内部循环执行的步骤有 3 步 </p>
<p>   ​    处理accept事件，与client建立连接，生成NioSocketChannle</p>
<p>   ​    将NioSocketChannel注册到某个worker NIOEventLoop上的selector</p>
<p>   ​    处理任务队列的任务，即runAllTasks</p>
<p>8、每个worker NIOEventLoop线程循环执行的步骤</p>
<p>   ​     轮询注册到自己selector上的所有NioSocketChannel 的read, write事件 </p>
<p>   ​     处理 I/O 事件， 即read , write 事件， 在对应    NioSocketChannel 处理业务 </p>
<p>   ​     runAllTasks处理任务队列TaskQueue的任务 ，一些耗时的业务处理一般可以放入TaskQueue中慢慢处 理，这样不影响数据在 pipeline 中的流动处理</p>
<p>9、每个worker NIOEventLoop处理NioSocketChannel业务时，会使用 pipeline (管道)，管道中维护了很多 handler 处理器用来处理 channel 中的数据</p>
<br>

<p><strong>Bootstrap、ServerBootstrap</strong></p>
<p>一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组 件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。</p>
<br>

<p><strong>Future、ChannelFuture</strong></p>
<p>在Netty中所有的IO操作都是异步的，不能立刻得知消息是否被正确处理</p>
<p>但是可以等他执行完成或者直接注册一个监听，具体的实现就是通过Future和CahnnelFutures,他们可以注 册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</p>
<br>

<p><strong>Channel</strong></p>
<p>Netty网络通信的组件，能够用于执行网络I/O操作。Channel为用户提供</p>
<p>1、当前网络连接的通道的状态（例如是否打开？是否已连接）</p>
<p>2、网络连接的配置参数（例如接收缓冲区大小）</p>
<p>3、提供异步的网络I/O操作（如建立连接，读写，绑定端口），异步调用意味着任何I/O调用都将立即返回，并且不保证在调用结束时所请求的I/O操作已完成</p>
<p>4、调用立即返回一个ChannelFuture实例，通过注册监听器到ChannelFuture上，可以I/O操作成功、失败或取消时回调通知调用方</p>
<p>5、支持关联I/O操作与对应的处理程序。</p>
<p>不同协议、不通的阻塞类型的连接都有不同的Channel类型与之对应</p>
<p>下面是一些常用的Channel类型：</p>
<blockquote>
<p>NioSocketChannel 异步的客户端TCP Socket连接</p>
<p>NioServerSocketChannel  异步的服务器端TCP Socket连接</p>
<p>NioDatagramChannel  异步的UDP连接</p>
<p>NioSctpChannel  异步的客户端Sctp连接</p>
<p>NioSctpServerChannel 异步的Sctp服务器端连接</p>
<p>这些通道涵盖了UDP和TCP网络IO以及文件IO</p>
</blockquote>
<br>

<p><strong>Selector</strong></p>
<p>Netty基于Selector对象实现I/O多路复用，通过Selector一个线程可以监听多个连接的Channel事件。</p>
<p>当向一个Selector中注册Channel后，Selector内部的机制就可以自动不断地查询（Select）这些注册的Channel是否有已就绪的I/O事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多 个 Channel 。</p>
<br>

<p><strong>NioEventLoop</strong></p>
<p>NioEventLoop中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用NioEventLoop 的 run 方 法，执行 I/O 任务和非 I/O 任务：</p>
<p>I/O任务，即selectionKey中ready的事件，如accept、connect、read、write等，由 processSelectedKeys 方 法触发。</p>
<p>非 IO 任务，添加到 taskQueue 中的任务，如 register0、bind0 等任务，由 runAllTasks 方法触发。</p>
<br>

<p><strong>NioEventLoopGroup</strong></p>
<p>NioEventLoopGroup，主要管理eventLoop的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程（NioEventLoop)负责处理多个Channel上的事件，而一个Channel只对应于一个线程</p>
<br>

<p><strong>ChannelHandler</strong></p>
<p>ChannelHandler是一个接口，处理I/O事件或拦截I/O操作，并将其转发到其ChannelPipeline(业务处理链)中的下一个处理程序</p>
<p>ChannelHandler本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：</p>
<blockquote>
<p>ChannelInboundHandler 用于处理入站I/O事件</p>
<p>ChannelOutboundHandler 用于处理出站I/O操作</p>
</blockquote>
<p>或者使用以下适配器类</p>
<blockquote>
<p>ChannelInboundHandlerAdapter 用于处理入站I/O事件</p>
<p>ChannlOutboundHandler 用于处理出站I/O操作</p>
</blockquote>
<br>

<p><strong>ChannelHandlerContext</strong></p>
<p>保存Channel相关的上下文信息，同时关联一个ChannelHandler对象</p>
<br>

<p><strong>ChannelPipline</strong></p>
<p>​    保存ChannelHandler的List,用于处理或拦截Channel的入站事件和出站操作</p>
<p>ChannelPipeline实现了一中高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，事件的处理方式</p>
<p>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下：</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20220120102408589.png" class>

<br>

<p>​    一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组 成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。 read事件(入站事件)和write事件(出站事件)在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler，出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰</p>
<h2 id="Netty架构图"><a href="#Netty架构图" class="headerlink" title="Netty架构图"></a>Netty架构图</h2><br>

<img src="/colinstar/2022/01/06/Netty/image-20220112172945020.png" class>

<br>





<h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><br>

<p>​    从结构上来说，ByteBuf 由一串字节数组构成。数组中每个字节用来存放信息。 ByteBuf 提供了两个索引，一个用于读取数据，一个用于写入数据。这两个索引通过在字节数组中移动，来定 位需要读或者写信息的位置。 当从 ByteBuf 读取时，它的 readerIndex（读索引）将会根据读取的字节数递增。 同样，当写 ByteBuf 时，它的 writerIndex 也会根据写入的字节数进行递增。</p>
<p>​    需要注意的是极限的情况是 readerIndex 刚好读到了 writerIndex 写入的地方。 如果 readerIndex 超过了 writerIndex 的时候，Netty 会抛出 IndexOutOf-BoundsException 异常</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20220117160915775.png" class>

<br>

<br>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteBuf</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建byteBuf对象，该对象内部包含一个字符数组byte[10]</span></span><br><span class="line">        <span class="comment">// 通过readerindex和writeindex和capacity，将buffer分成三个区域，</span></span><br><span class="line">        <span class="comment">// 已经读取的区域: [0,readerindex)  注意开闭区间</span></span><br><span class="line">        <span class="comment">// 可读取的区域: [readerindex,writeindex)</span></span><br><span class="line">        <span class="comment">// 可写的区域: [writerindex,capacity）</span></span><br><span class="line">        ByteBuf buffer = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">        System.out.println(buffer);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            buffer.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(buffer);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(buffer.getByte(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(buffer.readByte());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(buffer);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">        ByteBuf byteBuf2 = Unpooled.copiedBuffer(<span class="string">&quot;hello world&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">        <span class="keyword">if</span> (byteBuf2.hasArray())&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] array = byteBuf2.array();</span><br><span class="line">            <span class="comment">// 转成字符串</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(array, CharsetUtil.UTF_8));</span><br><span class="line">            System.out.println(byteBuf2);</span><br><span class="line">            System.out.println(byteBuf2.readerIndex());</span><br><span class="line">            System.out.println(byteBuf2.writerIndex());</span><br><span class="line">            System.out.println(byteBuf2.capacity());</span><br><span class="line">            System.out.println(byteBuf2.getByte(<span class="number">0</span>)); <span class="comment">// 获取数组0这个位置的字符h的ascii码，h=104</span></span><br><span class="line">            <span class="keyword">int</span> len = byteBuf2.readableBytes(); <span class="comment">// 可读的字节数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;len = &quot;</span> + len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 范围读取</span></span><br><span class="line">        CharSequence charSequence = byteBuf2.getCharSequence(<span class="number">0</span>, <span class="number">6</span>, CharsetUtil.UTF_8);</span><br><span class="line">        System.out.println(charSequence.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Netty编解码"><a href="#Netty编解码" class="headerlink" title="Netty编解码"></a>Netty编解码</h2><br>

<p>Netty涉及到编解码的组件有Channel、ChannelHandler、ChannelPipe等</p>
<br>

<p><strong>ChannelHandler</strong></p>
<p>ChannelHandler充当了处理入站和出站数据的应用程序逻辑容器，例如，实现ChannelInboundHandler接口（或 ChannelInboundHandlerAdapter)，你就可以接收入站事件和数据，这些数据随后会被你的应用程序的业务逻辑处理。当你要给连接的客户端发送响应时，也可以从ChannelInboundHandler冲刷数据。你得业务逻辑通常写在一个或者多个ChannelInboundHandler中。ChannelOutboundHandler原理一样，只不过它用来处理出站数据的。</p>
<br>

<p><strong>ChannelPipeline</strong></p>
<p>ChannelPipeline提供了ChannelHandler链的容器。以客户端应用程序为例，如果事件的运动方向时从客户端到服务端的，那么称为这些事件为出战的，即客户端发送给服务端的数据会通过pipeline中的一系列ChannelOutboundHandler(ChannelOutboundHandler)调用是从tail到head方向逐个调用每个handler的逻辑，并被这些handler处理，反之则称为入站的，入站只调用pipeline里的ChannelInboundHandler逻辑（ChannelInboundHandler调用是从head到tail方向逐个调用每个handler的逻辑</p>
<p>所谓的入站出站，是相当于客户端/服务端来说的，即收到消息为入站，消息发送为出站。入站会从head到tail经过一系列处理调用，但是入站只是会调用继承ChannelInboundHandler的逻辑，出站是从tail到尾进行处理调用，只会调用ChannelOutboundHandler</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20220120142215255.png" class>

<br>

<br>

<p><strong>编码解码器</strong></p>
<p>​    当你通过Netty发送或者接收一个消息时，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如java对 象）；如果是出站消息，它会被编码成字节。</p>
<p>​    Netty提供了一系列的编码解码器，他们都实现了ChannelInboundHadnler或者ChannelOutboundHandler接口。在这些类中，channelRead方法已经被重写了。</p>
<p>​    以入站为例，对于每个从入站Channel读取的消息，这个方法会被调用。随后，它将调用由已知解码器 所提供的decode()方法进行解码，并将已经解码的字节转发给ChannelPipeline中的下一个ChannelInboundHandler。Netty提供了很多编解码器，比如编解码字符串的StringEncoder和StringDecoder，编解码对象的ObjectEncoder和ObjectDecoder 等。</p>
<blockquote>
<p>如果要实现高效的编解码可以用protobuf，但是protobuf需要维护大量的proto文件比较麻烦，现在一般可以使用protostuff。 protostuff是一个基于protobuf实现的序列化方法，它较于protobuf最明显的好处是，在几乎不损耗性能的情况下做到了不用我们 写.proto文件来实现序列化</p>
</blockquote>
<p>maven坐标如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dyuproject.protostuff<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protostuff‐api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dyuproject.protostuff<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protostuff‐core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dyuproject.protostuff<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protostuff‐runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Netty粘包拆包"><a href="#Netty粘包拆包" class="headerlink" title="Netty粘包拆包"></a>Netty粘包拆包</h2><pre><code> TCP是一个流协议，就是没有界限的一长串二进制数据。TCP作为传输层协议并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行数据包的划分，所以在业务上认为是一个完整的包，可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。
</code></pre>
<p>​    面向流的通信是无消息保护边界的。</p>
<p>​    如下图：client发送两个数据包D1和D2，但是server端可能会收到如下几种情况的数据</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20220124095737022.png" class>

<br>

<br>

<p><strong>解决方案</strong></p>
<p>1、消息定长度，数据传输的大小固定长度，例如每段长度固定100字节，不够空位补齐</p>
<p>2、在数据包尾部添加特殊分隔符，比如下划线等。前提是消息本体不能带分隔符</p>
<p>3、发送长度：发送每条数据的时候，将数据的长度一并发送。比如可以选取每条数据的前四位去记录长度，接受处理时可以根据长度判定开始和结束</p>
<p>Netty提供了多个解码器，可以进行分包的操作</p>
<p>LineBasedFrameDecoder (回车换行分包)</p>
<p>DelimiterBasedFrameDecoder (特殊分隔符分包)</p>
<p>FixedLengthFrameDecoder (固定长度报文分包)</p>
<h2 id="Netty心跳检测机制"><a href="#Netty心跳检测机制" class="headerlink" title="Netty心跳检测机制"></a>Netty心跳检测机制</h2><p>​    在Netty中，实现心跳机制的关键是IDleStateHandler。</p>
<img src="/colinstar/2022/01/06/Netty/image-20220126101511843.png" class>

<br>

<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span></span>&#123;</span><br><span class="line">        socketChannel.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">        socketChannel.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">        <span class="comment">// IdleStateEvent的readerIdleTime参数指定超过3秒还没收到客户端的连接，会触发</span></span><br><span class="line">        <span class="comment">// IdleStateEvent事件并且交给下一个handler处理，下一个handler必须实现userEventTriggered方法处理对应事件</span></span><br><span class="line">        socketChannel.pipeline().addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">        socketChannel.pipeline().addLast(<span class="keyword">new</span> HeartBeatServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<br>

<p>构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读超时时间；写超时时间；所有的超时时间；时间单位</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>, readerIdleTime, writerIdleTime, allIdleTime, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">boolean</span> observeOutput, <span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.writeListener = <span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           IdleStateHandler.<span class="keyword">this</span>.lastWriteTime = IdleStateHandler.<span class="keyword">this</span>.ticksInNanos();</span><br><span class="line">           IdleStateHandler.<span class="keyword">this</span>.firstWriterIdleEvent = IdleStateHandler.<span class="keyword">this</span>.firstAllIdleEvent=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.firstReaderIdleEvent = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.firstWriterIdleEvent = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.firstAllIdleEvent = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;unit&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.observeOutput = observeOutput;</span><br><span class="line">        <span class="keyword">if</span> (readerIdleTime &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.readerIdleTimeNanos = <span class="number">0L</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 赋值</span></span><br><span class="line">            <span class="keyword">this</span>.readerIdleTimeNanos = Math.max(unit.toNanos(readerIdleTime), MIN_TIMEOUT_NANOS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (writerIdleTime &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.writerIdleTimeNanos = <span class="number">0L</span>; <span class="comment">// 赋值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">this</span>.writerIdleTimeNanos = Math.max(unit.toNanos(writerIdleTime), MIN_TIMEOUT_NANOS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allIdleTime &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.allIdleTimeNanos = <span class="number">0L</span>; <span class="comment">// 赋值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">this</span>.allIdleTimeNanos = Math.max(unit.toNanos(allIdleTime), MIN_TIMEOUT_NANOS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>channelActive</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.initialize(ctx);</span><br><span class="line">    <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>initialize</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">this</span>.state) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.initOutputChanged(ctx);</span><br><span class="line">        <span class="keyword">this</span>.lastReadTime = <span class="keyword">this</span>.lastWriteTime = <span class="keyword">this</span>.ticksInNanos(); <span class="comment">// lastReadTime,lastWriteTime赋初始值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.readerIdleTimeNanos &gt; <span class="number">0L</span>) &#123; <span class="comment">// readerIdleTimeNanos就是刚构造器里赋的值</span></span><br><span class="line">            <span class="keyword">this</span>.readerIdleTimeout = <span class="keyword">this</span>.schedule(ctx, <span class="keyword">new</span> IdleStateHandler.ReaderIdleTimeoutTask(ctx), <span class="keyword">this</span>.readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.writerIdleTimeNanos &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.writerIdleTimeout = <span class="keyword">this</span>.schedule(ctx, <span class="keyword">new</span> IdleStateHandler.WriterIdleTimeoutTask(ctx), <span class="keyword">this</span>.writerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.allIdleTimeNanos &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.allIdleTimeout = <span class="keyword">this</span>.schedule(ctx, <span class="keyword">new</span> IdleStateHandler.AllIdleTimeoutTask(ctx), <span class="keyword">this</span>.allIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>schedule</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScheduledFuture&lt;?&gt; schedule(ChannelHandlerContext ctx, Runnable task, <span class="keyword">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">return</span> ctx.executor().schedule(task, delay, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>    

<p>ChannelHandlerContext ctx是<code>io.netty.channel.DefaultChannelHandlerContext</code>实例，<code>DefaultChannleHandlerContext</code>又继承了<code>AbstractChannelHandlerContext</code>，在<code>AbstractChannelHandlerContext</code>中找到executor()方法，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EventExecutor <span class="title">executor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (EventExecutor)(<span class="keyword">this</span>.executor == <span class="keyword">null</span> ? <span class="keyword">this</span>.channel().eventLoop() : <span class="keyword">this</span>.executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>    

<p>​    ctx.executor()会返回一个EventExecutor，其类图如下，跟<code>ScheduledThreadPollExecutor</code>定时线程池一样，其都继承或实现自<code>ScheduledExecutorService</code>接口</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20220126102424203.png" class>

<br>

<br>

<p>接着我们去看new IdleStateHandler.ReaderIdleTimeoutTask(ctx)，这个任务里的run方法</p>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nextDelay = IdleStateHandler.<span class="keyword">this</span>.readerIdleTimeNanos; </span><br><span class="line">    <span class="keyword">if</span> (!IdleStateHandler.<span class="keyword">this</span>.reading) &#123; <span class="comment">// nextDelay = readerIdleTimeNanos - (当前时间 - lastReadTime)</span></span><br><span class="line">        <span class="comment">// channelReadComplete()方法里，会更新lastReadTime</span></span><br><span class="line">        <span class="comment">// 其实就是在计算 读的时间间隔是否超过设定的时间</span></span><br><span class="line">        nextDelay -= IdleStateHandler.<span class="keyword">this</span>.ticksInNanos() - IdleStateHandler.<span class="keyword">this</span>.lastReadTime; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextDelay &lt;= <span class="number">0L</span>) &#123; <span class="comment">// 小于等于0，即超时了走这里</span></span><br><span class="line">        IdleStateHandler.<span class="keyword">this</span>.readerIdleTimeout = IdleStateHandler.<span class="keyword">this</span>.schedule(ctx, <span class="keyword">this</span>, IdleStateHandler.<span class="keyword">this</span>.readerIdleTimeNanos, TimeUnit.NANOSECONDS); </span><br><span class="line">        <span class="comment">// 还会提交任务，延迟时间为readerIdleTimeNanos</span></span><br><span class="line">        <span class="keyword">boolean</span> first = IdleStateHandler.<span class="keyword">this</span>.firstReaderIdleEvent;<span class="comment">// 构造函数赋初始值为true</span></span><br><span class="line">        IdleStateHandler.<span class="keyword">this</span>.firstReaderIdleEvent = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            IdleStateEvent event = IdleStateHandler.<span class="keyword">this</span>.newIdleStateEvent(IdleState.READER_IDLE, first);</span><br><span class="line">            IdleStateHandler.<span class="keyword">this</span>.channelIdle(ctx, event);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">            ctx.fireExceptionCaught(var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        IdleStateHandler.<span class="keyword">this</span>.readerIdleTimeout = IdleStateHandler.<span class="keyword">this</span>.schedule(ctx, <span class="keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelIdle</span><span class="params">(ChannelHandlerContext ctx, IdleStateEvent evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.fireUserEventTriggered(evt); <span class="comment">// 会调用到下一个handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><h3 id="NioEventLoopGroup"><a href="#NioEventLoopGroup" class="headerlink" title="NioEventLoopGroup"></a>NioEventLoopGroup</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure>

<p>构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(nThreads, (Executor)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(nThreads, executor, SelectorProvider.provider());</span><br><span class="line">    <span class="comment">//SelectorProvider.provider()就是前面NIO所说的EPollSelectorProvider,详情看Selector.open()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line"><span class="comment">// 无参构造最终会调用这个有参构造</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory, SelectorProvider selectorProvider, SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(nThreads, threadFactory, <span class="keyword">new</span> Object[]&#123;selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject()&#125;); <span class="comment">//调用父类MultithreadEventLoopGroup的构造器</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<br>

<p><code>io.netty.channel.MultithreadEventLoopGroup</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args); <span class="comment">//继续调用父类构造器，nThreads = 0的话，会传入默认的线程数，cpu核数*2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><code>io.netty.util.concurrent.MultithreadEventExecutorGroup</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>最终会调用<code>MultithreadEventExecutorGroup</code>类的这个构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123; <span class="comment">// nThreads = 16，executor = null</span></span><br><span class="line">    <span class="keyword">this</span>.terminatedChildren = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">this</span>.terminationFuture = <span class="keyword">new</span> DefaultPromise(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建一个线程池</span></span><br><span class="line">            executor = <span class="keyword">new</span> ThreadPerTaskExecutor(<span class="keyword">this</span>.newDefaultThreadFactory());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.children = <span class="keyword">new</span> EventExecutor[nThreads]; <span class="comment">// 创建一个EventExecutor数组，长度为nThreads（16）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; ++i) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> var18 = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var18 = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 循环遍历，对数组中的每个元素赋值；会去new NioEventLoop(...)</span></span><br><span class="line">                <span class="keyword">this</span>.children[i] = <span class="keyword">this</span>.newChild((Executor)executor, args);</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">                var18 = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var19) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;failed to create a child event loop&quot;</span>, var19);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                .......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br>

<ul>
<li>newChild()</li>
</ul>
<p>io.netty.channel.nio.NioEventLoopGroup#newChild</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider)args[<span class="number">0</span>], ((SelectStrategyFactory)args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler)args[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>io.netty.channel.nio.NioEventLoop 构造函数</p>
<blockquote>
<p>public final class <strong>NioEventLoop</strong> extends <strong>SingleThreadEventLoop</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler); <span class="comment">// 调用父类构造器,里面会创建一个阻塞队列taskQueue</span></span><br><span class="line">    <span class="keyword">if</span> (selectorProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;selectorProvider&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strategy == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;selectStrategy&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.provider = selectorProvider;</span><br><span class="line">        NioEventLoop.SelectorTuple selectorTuple = <span class="keyword">this</span>.openSelector(); <span class="comment">// 类比前面NIO的代码，创建selector</span></span><br><span class="line">        <span class="keyword">this</span>.selector = selectorTuple.selector;</span><br><span class="line">        <span class="keyword">this</span>.unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">        <span class="keyword">this</span>.selectStrategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>io.netty.channel.SingleThreadEventLoop 构造函数</p>
<blockquote>
<p>public abstract class <strong>SingleThreadEventLoop</strong> extends <strong>SingleThreadEventExecutor</strong> implements EventLoop </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventLoop</span><span class="params">(EventLoopGroup parent, Executor executor, <span class="keyword">boolean</span> addTaskWakesUp, <span class="keyword">int</span> maxPendingTasks, RejectedExecutionHandler rejectedExecutionHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, executor, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler);</span><br><span class="line">    <span class="keyword">this</span>.tailTasks = <span class="keyword">this</span>.newTaskQueue(maxPendingTasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>io.netty.util.concurrent.SingleThreadEventExecutor 构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventExecutor</span><span class="params">(EventExecutorGroup parent, Executor executor, <span class="keyword">boolean</span> addTaskWakesUp, <span class="keyword">int</span> maxPendingTasks, RejectedExecutionHandler rejectedHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="keyword">this</span>.threadLock = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.shutdownHooks = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.terminationFuture = <span class="keyword">new</span> DefaultPromise(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    <span class="keyword">this</span>.addTaskWakesUp = addTaskWakesUp;</span><br><span class="line">    <span class="keyword">this</span>.maxPendingTasks = Math.max(<span class="number">16</span>, maxPendingTasks);</span><br><span class="line">    <span class="keyword">this</span>.executor = ThreadExecutorMap.apply(executor, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.taskQueue = <span class="keyword">this</span>.newTaskQueue(<span class="keyword">this</span>.maxPendingTasks); <span class="comment">// 创建阻塞队列</span></span><br><span class="line">    <span class="keyword">this</span>.rejectedExecutionHandler = (RejectedExecutionHandler)ObjectUtil.checkNotNull(rejectedHandler, <span class="string">&quot;rejectedHandler&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Queue&lt;Runnable&gt; <span class="title">newTaskQueue</span><span class="params">(<span class="keyword">int</span> maxPendingTasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedBlockingQueue(maxPendingTasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h3><br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">serverBootstrap.group(bossGroup,workerGroup).....</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ServerBootstrap构造器为空方法，没有做什么逻辑处理</p>
</blockquote>
<h4 id="group-bossGroup-workerGroup"><a href="#group-bossGroup-workerGroup" class="headerlink" title="group(bossGroup,workerGroup)"></a>group(bossGroup,workerGroup)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.group(parentGroup);</span><br><span class="line">    <span class="keyword">if</span> (childGroup == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;childGroup&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.childGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;childGroup set already&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>io.netty.bootstrap.AbstractBootstrap#group</p>
<blockquote>
<p>public abstract class AbstractBootstrap&lt;B extends AbstractBootstrap&lt;B, C&gt;, C extends Channel&gt; implements Cloneable {}</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">group</span><span class="params">(EventLoopGroup group)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;group&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;group set already&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.group = group; <span class="comment">// 赋值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="channel-NioServerSocketChannel-class"><a href="#channel-NioServerSocketChannel-class" class="headerlink" title="channel(NioServerSocketChannel.class)"></a>channel(NioServerSocketChannel.class)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channelClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;channelClass&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.channelFactory((<span class="keyword">new</span> ReflectiveChannelFactory(channelClass)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>new ReflectiveChannelFactory(channelClass)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Constructor&lt;? extends T&gt; constructor; <span class="comment">// 成员属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(clazz, <span class="string">&quot;clazz&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.constructor = clazz.getConstructor(); <span class="comment">// 获取传进来class的构造函数，并赋值给成员属性</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Class &quot;</span> + StringUtil.simpleClassName(clazz) + <span class="string">&quot; does not have a public non-arg constructor&quot;</span>, var3);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<br>

<p> this.channelFactory((new ReflectiveChannelFactory(channelClass)));</p>
<p>channelFactory()方法,就是将channelFactory赋值给成员属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> </span>&#123;</span><br><span class="line">		.......</span><br><span class="line">        <span class="keyword">this</span>.channelFactory = channelFactory;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="option-ChannelOption-SO-BACKLOG-1024"><a href="#option-ChannelOption-SO-BACKLOG-1024" class="headerlink" title="option(ChannelOption.SO_BACKLOG,1024)"></a>option(ChannelOption.SO_BACKLOG,1024)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = <span class="keyword">new</span> LinkedHashMap(); <span class="comment">// 成员属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">B <span class="title">option</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (option == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;option&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.options) &#123;</span><br><span class="line">                <span class="keyword">this</span>.options.remove(option);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.options) &#123;</span><br><span class="line">                <span class="keyword">this</span>.options.put(option, value); <span class="comment">// 就是把传进来的key,value放进map</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="childHandler-new-ChannelInitializer-…"><a href="#childHandler-new-ChannelInitializer-…" class="headerlink" title="childHandler(new ChannelInitializer() {…}"></a>childHandler(new ChannelInitializer<SocketChannel>() {…}</SocketChannel></h4><p>handler()是发生在初始化的时候，childHandler()是发生在客户端连接之后</p>
<p>.childHandler(new ChannelInitializer<SocketChannel>() {<br>    @Override<br>    protected void initChannel(SocketChannel socketChannel) throws Exception {<br>        socketChannel.pipeline().addLast(new ….);<br>    }<br>});</SocketChannel></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ChannelHandler childHandler; <span class="comment">// 成员属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">childHandler</span><span class="params">(ChannelHandler childHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (childHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;childHandler&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.childHandler = childHandler;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br>

<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><blockquote>
<p>ChannelFuture cf = serverBootstrap.bind(ip,port);</p>
</blockquote>
<p>ServerBootstrap继承AbstractBootstrap，bind是父类AbstractBootstrap的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.bind(<span class="keyword">new</span> InetSocketAddress(inetPort));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用重载方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.validate(); <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;localAddress&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.doBind(localAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>validate方法 校验成员属性是否有值,也就是group()，channel()配置的那些</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">validate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.group == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;group not set&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.channelFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;channel or channelFactory not set&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>this.doBind(localAddress)方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = <span class="keyword">this</span>.initAndRegister(); <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise); <span class="comment">// ②</span></span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractBootstrap.PendingRegistrationPromise promise = <span class="keyword">new</span> AbstractBootstrap.PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.registered();</span><br><span class="line">                    AbstractBootstrap.doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h5 id="this-initAndRegister-方法"><a href="#this-initAndRegister-方法" class="headerlink" title="this.initAndRegister()方法"></a>this.initAndRegister()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// channelFactory就是channel方法赋值的 ReflectiveChannelFactory</span></span><br><span class="line">       <span class="comment">//  ReflectiveChannelFactory的newChannel()方法主要是:   return (Channel)this.constructor.newInstance();</span></span><br><span class="line">       <span class="comment">//  如前文所说，constructor也是channel方法赋值的，我们传进来的是NioServerSocketChannel.class</span></span><br><span class="line">        channel = <span class="keyword">this</span>.channelFactory.newChannel(); </span><br><span class="line">        <span class="keyword">this</span>.init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelFuture regFuture = <span class="keyword">this</span>.config().group().register(channel); <span class="comment">// 将NioServerSocketChannel注册</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="NioServerSocketChannel的无参构造："><a href="#NioServerSocketChannel的无参构造：" class="headerlink" title="NioServerSocketChannel的无参构造："></a>NioServerSocketChannel的无参构造：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider(); <span class="comment">// 成员属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>先看newSocket()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> java.nio.channels.<span class="function">ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> provider.openServerSocketChannel(); <span class="comment">// 类比文章开头的NIO代码，几乎一模一样 会去创建ServerSocketChannel对象</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;Failed to open a server socket.&quot;</span>, var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>this(newSocket(DEFAULT_SELECTOR_PROVIDER));调用重载的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(java.nio.channels.ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>((Channel)<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT); <span class="comment">// SelectionKey.OP_ACCEPT 连接事件</span></span><br><span class="line">    <span class="keyword">this</span>.config = <span class="keyword">new</span> NioServerSocketChannel.NioServerSocketChannelConfig(<span class="keyword">this</span>, <span class="keyword">this</span>.javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>父类构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioMessageChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, ch, readInterestOp); <span class="comment">// ① 继续调用父类构造器，如下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent); <span class="comment">// ② 继续往上调用,代码如下</span></span><br><span class="line">    <span class="keyword">this</span>.ch = ch;</span><br><span class="line">    <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ch.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 设置ServerSocketChannel为非阻塞</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var7) &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123; <span class="comment">// ③</span></span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    <span class="keyword">this</span>.id = <span class="keyword">this</span>.newId();</span><br><span class="line">    <span class="keyword">this</span>.unsafe = <span class="keyword">this</span>.newUnsafe();</span><br><span class="line">    <span class="keyword">this</span>.pipeline = <span class="keyword">this</span>.newChannelPipeline(); <span class="comment">// 创造pipeline</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123; <span class="comment">// ④</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123; <span class="comment">// ⑤</span></span><br><span class="line">    <span class="keyword">this</span>.channel = (Channel)ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, (EventExecutor)<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.voidPromise = <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 创建尾部节点，TailContext与HeadContext都间接实现了ChannelHandlerContext，AbstractChannelHandlerContext实现了它</span></span><br><span class="line">    <span class="comment">// class TailContext extends AbstractChannelHandlerContext implements ChannelInboundHandler </span></span><br><span class="line">    <span class="keyword">this</span>.tail = <span class="keyword">new</span> DefaultChannelPipeline.TailContext(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> DefaultChannelPipeline.HeadContext(<span class="keyword">this</span>); <span class="comment">// 创建头部节点</span></span><br><span class="line">    <span class="keyword">this</span>.head.next = <span class="keyword">this</span>.tail; <span class="comment">// 首尾互指</span></span><br><span class="line">    <span class="keyword">this</span>.tail.prev = <span class="keyword">this</span>.head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>   ch.configureBlocking(false); 即前面NIO代码的如下地方：</p>
<br>

<img src="/colinstar/2022/01/06/Netty/image-20220209143331857.png" class>



<h6 id="this-init-channel"><a href="#this-init-channel" class="headerlink" title="this.init(channel);"></a>this.init(channel);</h6><p>  this.init()是一个抽象方法，ServerBootstrap中对应实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = <span class="keyword">new</span> LinkedHashMap(); <span class="comment">// AbstractBootstrap中的成员属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">//channel ——&gt; NioServerSocketChannel实例</span></span><br><span class="line">    <span class="comment">// options0（）是父类AbstractBootstrap方法，具体逻辑就是 return this.options; </span></span><br><span class="line">    <span class="comment">// this.options是前文所说的option()方法赋的值</span></span><br><span class="line">    Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = <span class="keyword">this</span>.options0();</span><br><span class="line">    <span class="keyword">synchronized</span>(options) &#123;</span><br><span class="line">        <span class="comment">// 会去遍历options,给nioServerSocketChannel里的成员属性ServerSocketChannelConfig赋值</span></span><br><span class="line">        setChannelOptions(channel, options, logger); ，</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = <span class="keyword">this</span>.attrs0();</span><br><span class="line">    <span class="keyword">synchronized</span>(attrs) &#123;</span><br><span class="line">        Iterator var5 = attrs.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!var5.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e = (Entry)var5.next();</span><br><span class="line">            AttributeKey&lt;Object&gt; key = (AttributeKey)e.getKey();</span><br><span class="line">            channel.attr(key).set(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelPipeline p = channel.pipeline(); <span class="comment">// 拿到NioServerSocketChannel中的pipeline</span></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = <span class="keyword">this</span>.childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = <span class="keyword">this</span>.childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry[] currentChildOptions;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.childOptions) &#123;</span><br><span class="line">        currentChildOptions = (Entry[])<span class="keyword">this</span>.childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Entry[] currentChildAttrs;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.childAttrs) &#123;</span><br><span class="line">        currentChildAttrs = (Entry[])<span class="keyword">this</span>.childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123; <span class="comment">// 往pipeline里添加一个handler</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = ServerBootstrap.<span class="keyword">this</span>.config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;handler&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">new</span> ServerBootstrap.ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="this-config-group-register-channel"><a href="#this-config-group-register-channel" class="headerlink" title="this.config().group().register(channel);"></a>this.config().group().register(channel);</h6><br>

<ul>
<li>this.config()返回一个ServerBootstrapConfig对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractBootstrapConfig&lt;B, C&gt; <span class="title">config</span><span class="params">()</span></span>; <span class="comment">//抽象方法</span></span><br></pre></td></tr></table></figure>



<p>ServerBootstarp中的实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServerBootstrapConfig config = <span class="keyword">new</span> ServerBootstrapConfig(<span class="keyword">this</span>); <span class="comment">// 成员属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ServerBootstrapConfig <span class="title">config</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>ServerBootstrapConfig的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrapConfig(ServerBootstrap bootstrap) &#123;</span><br><span class="line">    <span class="keyword">super</span>(bootstrap); <span class="comment">// 往上调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrapConfig</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> B bootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractBootstrapConfig</span><span class="params">(B bootstrap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将ServerBootstarp赋值给成员属性</span></span><br><span class="line">        <span class="keyword">this</span>.bootstrap = (AbstractBootstrap)ObjectUtil.checkNotNull(bootstrap, <span class="string">&quot;bootstrap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>group()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> EventLoopGroup <span class="title">group</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.bootstrap.group(); <span class="comment">// this.bootstrap就是ServerBootstrap实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> EventLoopGroup group; <span class="comment">// 成员属性；具体在前文所说的ServerBootstrap里的group方法里赋的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> EventLoopGroup <span class="title">group</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.group; <span class="comment">// 就是NioEventLoopGroup，准确来说是boss线程组。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>register(channel)方法</li>
</ul>
<p>​    前面的this.config().group()会返回NioEventLoopGroup，register是抽象方法；而NioEventLoopGroup继承MultithreadEventLoopGroup，我们看MultithreadEventLoopGroup里的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123; <span class="comment">// channel ——&gt; NioServerSocketChannel</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.next().register(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventLoop <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (EventLoop)<span class="keyword">super</span>.next(); <span class="comment">// 拿一个NioEventLoop线程，前面所说会创建(默认长度为16的)children数组，并循环遍历对每一个赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>​    接着继续跟进返回的nioEventLoop的register方法，NioEventLoop继承SingleThreadEventLoop，所以我们看它里面的实现</p>
<p>io.netty.channel.SingleThreadEventLoop#register(io.netty.channel.Channel)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.register((ChannelPromise)(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>调用重载方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise); <span class="comment">// this ————&gt; NioEventLoop</span></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>io.netty.channel.AbstractChannel.AbstractUnsafe#register</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop; <span class="comment">// 将传进来的NioEventLoop赋值给成员属性</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123; <span class="comment">// 判断当前线程是否是NioEventLoop中的线程</span></span><br><span class="line">            <span class="keyword">this</span>.register0(promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        AbstractUnsafe.<span class="keyword">this</span>.register0(promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">               ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>先看excute方法做了什么</p>
<p>io.netty.util.concurrent.SingleThreadEventExecutor#execute</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> inEventLoop = <span class="keyword">this</span>.inEventLoop();</span><br><span class="line">        <span class="keyword">this</span>.addTask(task); <span class="comment">// 将任务添加到taskQueue队列</span></span><br><span class="line">        <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">            <span class="keyword">this</span>.startThread();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isShutdown()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> reject = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.removeTask(task)) &#123;</span><br><span class="line">                        reject = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedOperationException var5) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reject) &#123;</span><br><span class="line">                    reject();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.addTaskWakesUp &amp;&amp; <span class="keyword">this</span>.wakesUpForTask(task)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wakeup(inEventLoop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          ....</span><br><span class="line">            label1907: &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var112 = <span class="keyword">true</span>;</span><br><span class="line">                    SingleThreadEventExecutor.<span class="keyword">this</span>.run(); <span class="comment">// 调用NioEventLoop的run方法</span></span><br><span class="line">                    success = <span class="keyword">true</span>;</span><br><span class="line">                    var112 = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span> label1907;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var119) &#123;</span><br><span class="line">                    .......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;	</span><br></pre></td></tr></table></figure>

<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">switch</span>(<span class="keyword">this</span>.selectStrategy.calculateStrategy(<span class="keyword">this</span>.selectNowSupplier, <span class="keyword">this</span>.hasTasks())) &#123;</span><br><span class="line">                        <span class="keyword">case</span> -<span class="number">3</span>:</span><br><span class="line">                        <span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">                            <span class="comment">// select()，类比NIO代码</span></span><br><span class="line">                            <span class="comment">// 方法里面会去调用  selector.select(timeoutMillis);超时等待</span></span><br><span class="line">                            <span class="keyword">this</span>.select(<span class="keyword">this</span>.wakenUp.getAndSet(<span class="keyword">false</span>)); </span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">this</span>.wakenUp.get()) &#123;</span><br><span class="line">                                <span class="keyword">this</span>.selector.wakeup();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> -<span class="number">2</span>:</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var23) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.rebuildSelector0();</span><br><span class="line">                        handleLoopException(var23);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.cancelledKeys = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">this</span>.needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">                    <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">this</span>.processSelectedKeys(); <span class="comment">// 类比NIO代码,拿到SelectionKey</span></span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">this</span>.runAllTasks(); <span class="comment">// 执行任务</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                        <span class="keyword">boolean</span> var14 = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            var14 = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">this</span>.processSelectedKeys();</span><br><span class="line">                            var14 = <span class="keyword">false</span>;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (var14) &#123;</span><br><span class="line">                                <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                                <span class="keyword">this</span>.runAllTasks(ioTime * (<span class="keyword">long</span>)(<span class="number">100</span> - ioRatio) / (<span class="keyword">long</span>)ioRatio);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                        <span class="keyword">this</span>.runAllTasks(ioTime * (<span class="keyword">long</span>)(<span class="number">100</span> - ioRatio) / (<span class="keyword">long</span>)ioRatio);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var24) &#123;</span><br><span class="line">                    handleLoopException(var24);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         .......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">this</span>.inEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> ranAtLeastOne = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> fetchedAll;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        fetchedAll = <span class="keyword">this</span>.fetchFromScheduledTaskQueue();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.runAllTasksFrom(<span class="keyword">this</span>.taskQueue)) &#123; <span class="comment">// 从队列中获取任务并执行</span></span><br><span class="line">            ranAtLeastOne = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(!fetchedAll);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ranAtLeastOne) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.afterRunningAllTasks();</span><br><span class="line">    <span class="keyword">return</span> ranAtLeastOne;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>回过头来看，执行任务的逻辑，即刚刚提交任务的run方法</p>
<blockquote>
<p>eventLoop.execute(new Runnable() {<br> public void run() {<br>     AbstractUnsafe.this.<strong>register0</strong>(promise);<br> }<br>});</p>
</blockquote>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !<span class="keyword">this</span>.ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = <span class="keyword">this</span>.neverRegistered;</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.doRegister(); <span class="comment">// 注册</span></span><br><span class="line">        <span class="keyword">this</span>.neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.registered = <span class="keyword">true</span>;</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        <span class="keyword">this</span>.safeSetSuccess(promise);</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.pipeline.fireChannelRegistered(); <span class="comment">// 责任链调用pipeline中的handler</span></span><br><span class="line">        <span class="keyword">if</span> (AbstractChannel.<span class="keyword">this</span>.isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                AbstractChannel.<span class="keyword">this</span>.pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AbstractChannel.<span class="keyword">this</span>.config().isAutoRead()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">        <span class="keyword">this</span>.closeForcibly();</span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.closeFuture.setClosed();</span><br><span class="line">        <span class="keyword">this</span>.safeSetFailure(promise, var3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.selectionKey = <span class="keyword">this</span>.javaChannel().register(<span class="keyword">this</span>.eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>); <span class="comment">// 将serverSocketChannel注册到selector上，并让其对</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancelledKeyException var3) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selected) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> var3;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRegistered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelRegistered(<span class="keyword">this</span>.head); <span class="comment">// 将pipeline中的头节点传进去</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRegistered</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> </span>&#123;</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRegistered();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 接着执行</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelRegistered();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><br>

<img src="/colinstar/2022/01/06/Netty/Netty%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.jpg" class>





<h1 id="无锁串行化"><a href="#无锁串行化" class="headerlink" title="无锁串行化"></a>无锁串行化</h1><p>​    大多数场景下，并行多线程处理可以提升系统的并发能力。但是，如果对于共享资源的并发访问处理不当，会带来严重的锁竞争，这最终会导致性能的下降。为了尽可能的避免锁竞争带来的性能损耗，可以通过串行化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程的切换，这样就避免了多线程竞争和同步锁。NIO的多路复用就是一种无锁串行化的设计思想。为了尽可能提升性能，Netty采用了串行无锁化设计，在IO线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上来看，串行化的设计似乎CPU利用率不高，并发成都不够，但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优</p>
<p>Netty的NioEventLoop读到消息之后，直接调用ChannelPipeline的fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由NioEventLoop调到用户的handler,期间不进行线程切换</p>
<h1 id="零拷贝（直接内存的使用）"><a href="#零拷贝（直接内存的使用）" class="headerlink" title="零拷贝（直接内存的使用）"></a>零拷贝（直接内存的使用）</h1><br>

<img src="/colinstar/2022/01/06/Netty/image-20220303161701778.png" class>

<br>



<p><strong>直接内存</strong></p>
<p>直接内存Direct Memory,并不是虚拟机运行时数据区的一部分，某些情况下这部分内存也会被频繁地使用，而且也可能导致OOM,Java里用DirectByteBuffer可以分配一块直接内存(堆外内存)</p>
<p>​    直接内存申请较慢，但访问效率高。在java虚拟机实现上，本地IO一般会直接操作直接内存（直接内存-&gt;系统调用 -&gt;硬盘/网卡），而非直接内存则需要二次拷贝（堆内存-&gt;直接内存-&gt;系统调用-&gt;硬盘/网卡）。</p>
<p>​    Netty的接收和发送ByteBuf采用DIRECT BUFFERS ， 使用堆外内存进行Scoket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的JVM堆内存（HEAP BUFFERS)进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才能写入Socket中，Jvm堆内存的数据是不能写入Socket中的。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p>
<p>优点：</p>
<p>不占用堆内存空间，减少GC发生的频率</p>
<p>java虚拟机实现上，本地IO会直接操作直接内存（直接内存——&gt;系统调用——&gt;硬盘/网卡），而非直接内存则需要二次拷贝（堆内存——&gt;直接内存——&gt;系统调用——&gt;硬盘/网卡）</p>
<p>缺点：</p>
<p>初始分配较慢</p>
<p>没有JVM直接帮助管理内存，容易发生内存溢出，为了避免一直没有FULL GC，最终导致直接内存把物理内存耗完。我们可以指定直接内存的最大值，通过-XX:MaxDirectMemorySize来指定，当达到阈值的时候，调用system.gc来进行一次FULL GC，间接把那些没有被使用的直接内存回收掉</p>
<p>ByteBuf内存池设计</p>
<p>​    随着JVM虚拟机和JIT即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区Buffer(相当于一个内存块)，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作，为了尽量重用缓冲区，Netty提供了基于ByteBuffer内存池的缓冲区重用机制。需要的时候直接从池子里获取ByteBuf使用即可，使用完毕之后就重新放回池子里去。</p>
<h1 id="灵活的TCP参数配置能力"><a href="#灵活的TCP参数配置能力" class="headerlink" title="灵活的TCP参数配置能力"></a>灵活的TCP参数配置能力</h1><p>​    合理设置TCP参数在某些场景下对于性能的提升可以起到显著的效果，例如接收缓冲区SO_RCVBUF和发送缓冲区SO_SNDBUF。如果设置不当，对性能的影响是非常大的。通常建议值为128k或者256k</p>
<p>Netty在启动辅助类ChannelOption中可以灵活的配置TCP参数，满足不同的用户场景</p>
<h1 id="ByteBuf扩容机制"><a href="#ByteBuf扩容机制" class="headerlink" title="ByteBuf扩容机制"></a>ByteBuf扩容机制</h1><br>

<img src="/colinstar/2022/01/06/Netty/image-20220303161827343.png" class>

<br>

<p>minNewCapacity：表示用户需要写入的值大小</p>
<p>threshold：阈值，为bytebuf内部设定容量的最大值</p>
<p>maxCapacity：Netty最大能接受的容量大小，一般为int的最大值</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://c89757.gitee.io/colinstar/2022/01/06/Netty/" title="Netty" target="_blank" rel="external">http://c89757.gitee.io/colinstar/2022/01/06/Netty/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://gitee.com/c89757" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/colinstar/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://gitee.com/c89757" target="_blank"><span class="text-dark">colin</span><small class="ml-1x">悟已往之不谏，知来者之可追</small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/colinstar/2022/01/15/Synchronized%E8%AF%A6%E8%A7%A3/" title="Synchronized详解"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/colinstar/2021/12/22/%E5%85%B3%E4%BA%8Ecount()/" title="关于count(*)"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/colinstar/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2024 John Doe
        
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/colinstar/js/plugin.min.js"></script>


<script src="/colinstar/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/colinstar/',
        CONTENT_URL: '/colinstar/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/colinstar/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   


  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>